{
    "sourceFile": "public/three/script.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1708595781543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1708595799264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,17 +52,17 @@\n             render();\r\n         });\r\n }\r\n \r\n+\r\n function createOrbitControls() {\r\n     controls = new OrbitControls(camera, canvas3D);\r\n     controls.enablePan = false;\r\n     controls.enableZoom = false;\r\n     controls.enableDamping = true;\r\n     controls.minPolarAngle = .4 * Math.PI;\r\n     controls.maxPolarAngle = .4 * Math.PI;\r\n     controls.autoRotate = true;\r\n-    controls.autoRotateSpeed = 2; // Increase this value to speed up the rotation\r\n \r\n     let timestamp;\r\n     controls.addEventListener(\"start\", () => {\r\n         timestamp = Date.now();\r\n@@ -71,26 +71,8 @@\n         dragged = (Date.now() - timestamp) > 600;\r\n     });\r\n }\r\n \r\n-// function createOrbitControls() {\r\n-//     controls = new OrbitControls(camera, canvas3D);\r\n-//     controls.enablePan = false;\r\n-//     controls.enableZoom = false;\r\n-//     controls.enableDamping = true;\r\n-//     controls.minPolarAngle = .4 * Math.PI;\r\n-//     controls.maxPolarAngle = .4 * Math.PI;\r\n-//     controls.autoRotate = true;\r\n-\r\n-//     let timestamp;\r\n-//     controls.addEventListener(\"start\", () => {\r\n-//         timestamp = Date.now();\r\n-//     });\r\n-//     controls.addEventListener(\"end\", () => {\r\n-//         dragged = (Date.now() - timestamp) > 600;\r\n-//     });\r\n-// }\r\n-\r\n function createGlobe() {\r\n     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n     mapMaterial = new THREE.ShaderMaterial({\r\n         vertexShader: document.getElementById(\"vertex-shader-map\").textContent,\r\n"
                }
            ],
            "date": 1708595781543,
            "name": "Commit-0",
            "content": "import * as THREE from \"https://cdn.skypack.dev/three@0.133.1/build/three.module\";\r\nimport {OrbitControls} from \"https://cdn.skypack.dev/three@0.133.1/examples/jsm/controls/OrbitControls\";\r\nimport { gsap } from \"https://cdn.skypack.dev/gsap@3.7.0\";\r\n\r\nconst containerEl = document.querySelector(\".globe-wrapper\");\r\nconst canvas3D = containerEl.querySelector(\"#globe-3d\");\r\nconst canvas2D = containerEl.querySelector(\"#globe-2d-overlay\");\r\nconst popupEl = containerEl.querySelector(\".globe-popup\");\r\n\r\nlet renderer, scene, camera, rayCaster, controls, group;\r\nlet overlayCtx = canvas2D.getContext(\"2d\");\r\nlet coordinates2D = [0, 0];\r\nlet pointerPos;\r\nlet clock, mouse, pointer, globe, globeMesh;\r\nlet popupVisible;\r\nlet earthTexture, mapMaterial;\r\nlet popupOpenTl, popupCloseTl;\r\n\r\nlet dragged = false;\r\n\r\ninitScene();\r\nwindow.addEventListener(\"resize\", updateSize);\r\n\r\n\r\nfunction initScene() {\r\n    renderer = new THREE.WebGLRenderer({canvas: canvas3D, alpha: true});\r\n\trenderer.setPixelRatio(2);\r\n\r\n    scene = new THREE.Scene();\r\n    camera = new THREE.OrthographicCamera(-1.1, 1.1, 1.1, -1.1, 0, 3);\r\n    camera.position.z = 1.1;\r\n\r\n    rayCaster = new THREE.Raycaster();\r\n    rayCaster.far = 1.15;\r\n    mouse = new THREE.Vector2(-1, -1);\r\n    clock = new THREE.Clock();\r\n\r\n    createOrbitControls();\r\n\r\n    popupVisible = false;\r\n\r\n    new THREE.TextureLoader().load(\r\n        \"https://ksenia-k.com/img/earth-map-colored.png\",\r\n        (mapTex) => {\r\n            earthTexture = mapTex;\r\n            earthTexture.repeat.set(1, 1);\r\n            createGlobe();\r\n            createPointer();\r\n            createPopupTimelines();\r\n            addCanvasEvents();\r\n            updateSize();\r\n            render();\r\n        });\r\n}\r\n\r\nfunction createOrbitControls() {\r\n    controls = new OrbitControls(camera, canvas3D);\r\n    controls.enablePan = false;\r\n    controls.enableZoom = false;\r\n    controls.enableDamping = true;\r\n    controls.minPolarAngle = .4 * Math.PI;\r\n    controls.maxPolarAngle = .4 * Math.PI;\r\n    controls.autoRotate = true;\r\n    controls.autoRotateSpeed = 2; // Increase this value to speed up the rotation\r\n\r\n    let timestamp;\r\n    controls.addEventListener(\"start\", () => {\r\n        timestamp = Date.now();\r\n    });\r\n    controls.addEventListener(\"end\", () => {\r\n        dragged = (Date.now() - timestamp) > 600;\r\n    });\r\n}\r\n\r\n// function createOrbitControls() {\r\n//     controls = new OrbitControls(camera, canvas3D);\r\n//     controls.enablePan = false;\r\n//     controls.enableZoom = false;\r\n//     controls.enableDamping = true;\r\n//     controls.minPolarAngle = .4 * Math.PI;\r\n//     controls.maxPolarAngle = .4 * Math.PI;\r\n//     controls.autoRotate = true;\r\n\r\n//     let timestamp;\r\n//     controls.addEventListener(\"start\", () => {\r\n//         timestamp = Date.now();\r\n//     });\r\n//     controls.addEventListener(\"end\", () => {\r\n//         dragged = (Date.now() - timestamp) > 600;\r\n//     });\r\n// }\r\n\r\nfunction createGlobe() {\r\n    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n    mapMaterial = new THREE.ShaderMaterial({\r\n        vertexShader: document.getElementById(\"vertex-shader-map\").textContent,\r\n        fragmentShader: document.getElementById(\"fragment-shader-map\").textContent,\r\n        uniforms: {\r\n            u_map_tex: {type: \"t\", value: earthTexture},\r\n            u_dot_size: {type: \"f\", value: 0},\r\n            u_pointer: {type: \"v3\", value: new THREE.Vector3(.0, .0, 1.)},\r\n            u_time_since_click: {value: 0},\r\n        },\r\n        alphaTest: false,\r\n        transparent: true\r\n    });\r\n\r\n    globe = new THREE.Points(globeGeometry, mapMaterial);\r\n    scene.add(globe);\r\n\r\n    globeMesh = new THREE.Mesh(globeGeometry, new THREE.MeshBasicMaterial({\r\n        color: 0x222222,\r\n        transparent: true,\r\n        opacity: .05\r\n    }));\r\n    scene.add(globeMesh);\r\n}\r\n\r\nfunction createPointer() {\r\n    const geometry = new THREE.SphereGeometry(.04, 16, 16);\r\n    const material = new THREE.MeshBasicMaterial({\r\n        color: 0x00000,\r\n        transparent: true,\r\n        opacity: 0\r\n    });\r\n    pointer = new THREE.Mesh(geometry, material);\r\n    scene.add(pointer);\r\n}\r\n\r\n\r\nfunction updateOverlayGraphic() {\r\n    let activePointPosition = pointer.position.clone();\r\n    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n    const activePointPositionProjected = activePointPosition.clone();\r\n    activePointPositionProjected.project(camera);\r\n    coordinates2D[0] = (activePointPositionProjected.x + 1) * containerEl.offsetWidth * .5;\r\n    coordinates2D[1] = (1 - activePointPositionProjected.y) * containerEl.offsetHeight * .5;\r\n\r\n    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n\r\n    if (activePointPosition.z > -1) {\r\n        if (popupVisible === false) {\r\n            popupVisible = true;\r\n            showPopupAnimation(false);\r\n        }\r\n\r\n        let popupX = coordinates2D[0];\r\n        popupX -= (activePointPositionProjected.x * containerEl.offsetWidth * .3);\r\n\r\n        let popupY = coordinates2D[1];\r\n        const upDown = (activePointPositionProjected.y > .6);\r\n        popupY += (upDown ? 20 : -20);\r\n\r\n        gsap.set(popupEl, {\r\n            x: popupX,\r\n            y: popupY,\r\n            xPercent: -35,\r\n            yPercent: upDown ? 0 : -100\r\n        });\r\n\r\n        popupY += (upDown ? -5 : 5);\r\n        const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n        const curveMidY = popupY + (upDown ? -.5 : .1) * coordinates2D[1];\r\n\r\n        drawPopupConnector(coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n\r\n    } else {\r\n        if (popupVisible) {\r\n            popupOpenTl.pause(0);\r\n            popupCloseTl.play(0);\r\n        }\r\n        popupVisible = false;\r\n    }\r\n}\r\n\r\nfunction addCanvasEvents() {\r\n    containerEl.addEventListener(\"mousemove\", (e) => {\r\n        updateMousePosition(e.clientX, e.clientY);\r\n    });\r\n\r\n    containerEl.addEventListener(\"click\", (e) => {\r\n        if (!dragged) {\r\n            updateMousePosition(\r\n                e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n                e.targetTouches ? e.targetTouches[0].pageY : e.clientY,\r\n            );\r\n\r\n            const res = checkIntersects();\r\n            if (res.length) {\r\n                pointerPos = res[0].face.normal.clone();\r\n                pointer.position.set(res[0].face.normal.x, res[0].face.normal.y, res[0].face.normal.z);\r\n                mapMaterial.uniforms.u_pointer.value = res[0].face.normal;\r\n                popupEl.innerHTML = cartesianToLatLong();\r\n                showPopupAnimation(true);\r\n                clock.start()\r\n            }\r\n        }\r\n    });\r\n\r\n    function updateMousePosition(eX, eY) {\r\n        mouse.x = (eX - containerEl.offsetLeft) / containerEl.offsetWidth * 2 - 1;\r\n        mouse.y = -((eY - containerEl.offsetTop) / containerEl.offsetHeight) * 2 + 1;\r\n    }\r\n}\r\n\r\nfunction checkIntersects() {\r\n    rayCaster.setFromCamera(mouse, camera);\r\n    const intersects = rayCaster.intersectObject(globeMesh);\r\n    if (intersects.length) {\r\n        document.body.style.cursor = \"pointer\";\r\n    } else {\r\n        document.body.style.cursor = \"auto\";\r\n    }\r\n    return intersects;\r\n}\r\n\r\nfunction render() {\r\n    mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n    checkIntersects();\r\n    if (pointer) {\r\n        updateOverlayGraphic();\r\n    }\r\n    controls.update();\r\n    renderer.render(scene, camera);\r\n    requestAnimationFrame(render);\r\n}\r\n\r\nfunction updateSize() {\r\n    const minSide = .65 * Math.min(window.innerWidth, window.innerHeight);\r\n    containerEl.style.width = minSide + \"px\";\r\n    containerEl.style.height = minSide + \"px\";\r\n    renderer.setSize(minSide, minSide);\r\n    canvas2D.width = canvas2D.height = minSide;\r\n    mapMaterial.uniforms.u_dot_size.value = .04 * minSide;\r\n}\r\n\r\n\r\n//  ---------------------------------------\r\n//  HELPERS\r\n\r\n// popup content\r\nfunction cartesianToLatLong() {\r\n    const pos = pointer.position;\r\n    const lat = 90 - Math.acos(pos.y) * 180 / Math.PI;\r\n    const lng = (270 + Math.atan2(pos.x, pos.z) * 180 / Math.PI) % 360 - 180;\r\n    return formatCoordinate(lat, 'N', 'S') + \",&nbsp;\" + formatCoordinate(lng, 'E', 'W');\r\n}\r\n\r\nfunction formatCoordinate(coordinate, positiveDirection, negativeDirection) {\r\n    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n    return `${Math.abs(coordinate).toFixed(4)}°&nbsp${direction}`;\r\n}\r\n\r\n\r\n// popup show / hide logic\r\nfunction createPopupTimelines() {\r\n    popupOpenTl = gsap.timeline({\r\n        paused: true\r\n    })\r\n        .to(pointer.material, {\r\n            duration: .2,\r\n            opacity: 1,\r\n        }, 0)\r\n        .fromTo(canvas2D, {\r\n            opacity: 0\r\n        }, {\r\n            duration: .3,\r\n            opacity: 1\r\n        }, .15)\r\n        .fromTo(popupEl, {\r\n            opacity: 0,\r\n            scale: .9,\r\n            transformOrigin: \"center bottom\"\r\n        }, {\r\n            duration: .1,\r\n            opacity: 1,\r\n            scale: 1,\r\n        }, .15 + .1);\r\n\r\n    popupCloseTl = gsap.timeline({\r\n        paused: true\r\n    })\r\n        .to(pointer.material, {\r\n            duration: .3,\r\n            opacity: .2,\r\n        }, 0)\r\n        .to(canvas2D, {\r\n            duration: .3,\r\n            opacity: 0\r\n        }, 0)\r\n        .to(popupEl, {\r\n            duration: 0.3,\r\n            opacity: 0,\r\n            scale: 0.9,\r\n            transformOrigin: \"center bottom\"\r\n        }, 0);\r\n}\r\n\r\nfunction showPopupAnimation(lifted) {\r\n    if (lifted) {\r\n        let positionLifted = pointer.position.clone();\r\n        positionLifted.multiplyScalar(1.3);\r\n        gsap.from(pointer.position, {\r\n            duration: .25,\r\n            x: positionLifted.x,\r\n            y: positionLifted.y,\r\n            z: positionLifted.z,\r\n            ease: \"power3.out\"\r\n        });\r\n    }\r\n    popupCloseTl.pause(0);\r\n    popupOpenTl.play(0);\r\n}\r\n\r\n\r\n// overlay (line between pointer and popup)\r\nfunction drawPopupConnector(startX, startY, midX, midY, endX, endY) {\r\n    overlayCtx.strokeStyle = \"#000000\";\r\n    overlayCtx.lineWidth = 3;\r\n    overlayCtx.lineCap = \"round\";\r\n    overlayCtx.clearRect(0, 0, containerEl.offsetWidth, containerEl.offsetHeight);\r\n    overlayCtx.beginPath();\r\n    overlayCtx.moveTo(startX, startY);\r\n    overlayCtx.quadraticCurveTo(midX, midY, endX, endY);\r\n    overlayCtx.stroke();\r\n}"
        }
    ]
}