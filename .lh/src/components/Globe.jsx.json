{
    "sourceFile": "src/components/Globe.jsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 39,
            "patches": [
                {
                    "date": 1708581691851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1708582377735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,63 @@\n import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\n import { gsap } from \"gsap\";\r\n import \"./Globe.css\"; // Assuming you've moved the CSS to a separate file\r\n \r\n+// Vertex shader\r\n+const vertexShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+    uniform float u_dot_size;\r\n+    uniform float u_time_since_click;\r\n+    uniform vec3 u_pointer;\r\n+\r\n+    #define PI 3.14159265359\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vUv = uv;\r\n+\r\n+        // mask with world map\r\n+        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+        gl_PointSize = visibility * u_dot_size;\r\n+\r\n+        // make back dots semi-transparent\r\n+        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+        vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+        // add ripple\r\n+        float t = u_time_since_click - .1;\r\n+        t = max(0., t);\r\n+        float max_amp = .15;\r\n+        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+        delta *= 1. - smoothstep(.8, 1., dist);\r\n+        vec3 pos = position;\r\n+        pos *= (1. + delta);\r\n+\r\n+        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+    }\r\n+`;\r\n+\r\n+// Fragment shader\r\n+const fragmentShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+        if (dot < 0.5) discard;\r\n+        gl_FragColor = vec4(color, dot * vOpacity);\r\n+    }\r\n+`;\r\n+\r\n const Globe = () => {\r\n   const containerRef = useRef(null);\r\n   const canvas3DRef = useRef(null);\r\n   const canvas2DRef = useRef(null);\r\n@@ -106,10 +161,10 @@\n \r\n   const createGlobe = (earthTexture) => {\r\n     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n     const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: document.getElementById(\"vertex-shader-map\").textContent,\r\n-      fragmentShader: document.getElementById(\"fragment-shader-map\").textContent,\r\n+      vertexShader: vertexShader,\r\n+      fragmentShader: fragmentShader,\r\n       uniforms: {\r\n         u_map_tex: { type: \"t\", value: earthTexture },\r\n         u_dot_size: { type: \"f\", value: 0 },\r\n         u_pointer: { type: \"v3\", value: new THREE.Vector3(0, 0, 1) },\r\n"
                },
                {
                    "date": 1708582516071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,40 +158,9 @@\n \r\n     setControls(controls);\r\n   };\r\n \r\n-  const createGlobe = (earthTexture) => {\r\n-    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-    const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: vertexShader,\r\n-      fragmentShader: fragmentShader,\r\n-      uniforms: {\r\n-        u_map_tex: { type: \"t\", value: earthTexture },\r\n-        u_dot_size: { type: \"f\", value: 0 },\r\n-        u_pointer: { type: \"v3\", value: new THREE.Vector3(0, 0, 1) },\r\n-        u_time_since_click: { value: 0 },\r\n-      },\r\n-      alphaTest: false,\r\n-      transparent: true,\r\n-    });\r\n-    setMapMaterial(mapMaterial);\r\n \r\n-    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-    scene.add(globe);\r\n-    setGlobe(globe);\r\n-\r\n-    const globeMesh = new THREE.Mesh(\r\n-      globeGeometry,\r\n-      new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n-        transparent: true,\r\n-        opacity: 0.05,\r\n-      })\r\n-    );\r\n-    scene.add(globeMesh);\r\n-    setGlobeMesh(globeMesh);\r\n-  };\r\n-\r\n   const createPointer = () => {\r\n     const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n     const material = new THREE.MeshBasicMaterial({\r\n       color: 0x000000,\r\n@@ -238,9 +207,12 @@\n     mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n     mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n   };\r\n \r\n-  const checkIntersects = () => {\r\n+// Add checks for null objects in the Globe component\r\n+\r\n+const checkIntersects = () => {\r\n+    if (!globeMesh) return []; // Add this check\r\n     rayCaster.setFromCamera(mouse, camera);\r\n     const intersects = rayCaster.intersectObject(globeMesh);\r\n     if (intersects.length) {\r\n       document.body.style.cursor = \"pointer\";\r\n@@ -248,8 +220,42 @@\n       document.body.style.cursor = \"auto\";\r\n     }\r\n     return intersects;\r\n   };\r\n+  \r\n+  const createGlobe = (earthTexture) => {\r\n+    if (!scene) return; // Add this check\r\n+    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+    const mapMaterial = new THREE.ShaderMaterial({\r\n+      vertexShader: vertexShader,\r\n+      fragmentShader: fragmentShader,\r\n+      uniforms: {\r\n+        u_map_tex: { type: \"t\", value: earthTexture },\r\n+        u_dot_size: { type: \"f\", value: 0 },\r\n+        u_pointer: { type: \"v3\", value: new THREE.Vector3(0, 0, 1) },\r\n+        u_time_since_click: { value: 0 },\r\n+      },\r\n+      alphaTest: false,\r\n+      transparent: true,\r\n+    });\r\n+    setMapMaterial(mapMaterial);\r\n+  \r\n+    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+    scene.add(globe);\r\n+    setGlobe(globe);\r\n+  \r\n+    const globeMesh = new THREE.Mesh(\r\n+      globeGeometry,\r\n+      new THREE.MeshBasicMaterial({\r\n+        color: 0x222222,\r\n+        transparent: true,\r\n+        opacity: 0.05,\r\n+      })\r\n+    );\r\n+    scene.add(globeMesh);\r\n+    setGlobeMesh(globeMesh);\r\n+  };\r\n+  \r\n \r\n   const render = () => {\r\n     if (mapMaterial) {\r\n       mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n"
                },
                {
                    "date": 1708583114656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,354 @@\n+import React, { useEffect, useRef, useState } from 'react';\r\n+import * as THREE from 'three';\r\n+import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+import { gsap } from 'gsap';\r\n+import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+const Globe = () => {\r\n+  const containerRef = useRef(null);\r\n+  const canvas3DRef = useRef(null);\r\n+  const canvas2DRef = useRef(null);\r\n+  const popupRef = useRef(null);\r\n+\r\n+  const [renderer, setRenderer] = useState(null);\r\n+  const [scene, setScene] = useState(new THREE.Scene());\r\n+  const [camera, setCamera] = useState(null);\r\n+  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+  const [controls, setControls] = useState(null);\r\n+  const [pointer, setPointer] = useState(null);\r\n+  const [globe, setGlobe] = useState(null);\r\n+  const [globeMesh, setGlobeMesh] = useState(null);\r\n+  const [mapMaterial, setMapMaterial] = useState(null);\r\n+  const [popupVisible, setPopupVisible] = useState(false);\r\n+  const [pointerPos, setPointerPos] = useState(null);\r\n+  const [clock, setClock] = useState(new THREE.Clock());\r\n+  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+  const [dragged, setDragged] = useState(false);\r\n+  const [earthTexture, setEarthTexture] = useState(null);\r\n+  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+  useEffect(() => {\r\n+    initScene();\r\n+    window.addEventListener('resize', updateSize);\r\n+    return () => {\r\n+      window.removeEventListener('resize', updateSize);\r\n+    };\r\n+  }, []);\r\n+\r\n+  useEffect(() => {\r\n+    if (renderer && scene && camera) {\r\n+      updateSize();\r\n+      render();\r\n+    }\r\n+  }, [renderer, scene, camera]);\r\n+\r\n+  const initScene = () => {\r\n+    const renderer = new THREE.WebGLRenderer({\r\n+      canvas: canvas3DRef.current,\r\n+      alpha: true,\r\n+    });\r\n+    renderer.setPixelRatio(window.devicePixelRatio);\r\n+    setRenderer(renderer);\r\n+\r\n+    const camera = new THREE.OrthographicCamera(\r\n+      -1.1,\r\n+      1.1,\r\n+      1.1,\r\n+      -1.1,\r\n+      0,\r\n+      3\r\n+    );\r\n+    camera.position.z = 1.1;\r\n+    setCamera(camera);\r\n+\r\n+    createOrbitControls(camera, renderer.domElement);\r\n+\r\n+    new THREE.TextureLoader().load(\r\n+      'https://ksenia-k.com/img/earth-map-colored.png',\r\n+      (mapTex) => {\r\n+        setEarthTexture(mapTex);\r\n+        mapTex.repeat.set(1, 1);\r\n+        createGlobe(mapTex);\r\n+        createPointer();\r\n+        createPopupTimelines();\r\n+        addCanvasEvents();\r\n+      }\r\n+    );\r\n+  };\r\n+\r\n+  const createOrbitControls = (camera, canvas) => {\r\n+    const controls = new OrbitControls(camera, canvas);\r\n+    controls.enablePan = false;\r\n+    controls.enableZoom = false;\r\n+    controls.enableDamping = true;\r\n+    controls.minPolarAngle = 0.4 * Math.PI;\r\n+    controls.maxPolarAngle = 0.4 * Math.PI;\r\n+    controls.autoRotate = true;\r\n+\r\n+    let timestamp;\r\n+    controls.addEventListener('start', () => {\r\n+      timestamp = Date.now();\r\n+    });\r\n+    controls.addEventListener('end', () => {\r\n+      setDragged(Date.now() - timestamp > 600);\r\n+    });\r\n+\r\n+    setControls(controls);\r\n+  };\r\n+\r\n+  const createGlobe = (earthTexture) => {\r\n+    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+    const mapMaterial = new THREE.ShaderMaterial({\r\n+      vertexShader: vertexShader,\r\n+      fragmentShader: fragmentShader,\r\n+      uniforms: {\r\n+        u_map_tex: { type: 't', value: earthTexture },\r\n+        u_dot_size: { type: 'f', value: 0 },\r\n+        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+        u_time_since_click: { value: 0 },\r\n+      },\r\n+      alphaTest: false,\r\n+      transparent: true,\r\n+    });\r\n+    setMapMaterial(mapMaterial);\r\n+\r\n+    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+    scene.add(globe);\r\n+    setGlobe(globe);\r\n+\r\n+    const globeMesh = new THREE.Mesh(\r\n+      globeGeometry,\r\n+      new THREE.MeshBasicMaterial({\r\n+        color: 0x222222,\r\n+        transparent: true,\r\n+        opacity: 0.05,\r\n+      })\r\n+    );\r\n+    scene.add(globeMesh);\r\n+    setGlobeMesh(globeMesh);\r\n+  };\r\n+\r\n+  const createPointer = () => {\r\n+    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+    const material = new THREE.MeshBasicMaterial({\r\n+      color: 0x000000,\r\n+      transparent: true,\r\n+      opacity: 0,\r\n+    });\r\n+    const pointer = new THREE.Mesh(geometry, material);\r\n+    scene.add(pointer);\r\n+    setPointer(pointer);\r\n+  };\r\n+\r\n+  const addCanvasEvents = () => {\r\n+    containerRef.current.addEventListener('mousemove', (e) => {\r\n+      updateMousePosition(e.clientX, e.clientY);\r\n+    });\r\n+\r\n+    containerRef.current.addEventListener('click', (e) => {\r\n+      if (!dragged) {\r\n+        updateMousePosition(\r\n+          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+        );\r\n+\r\n+        const res = checkIntersects();\r\n+        if (res.length) {\r\n+          const newPointerPos = res[0].face.normal.clone();\r\n+          setPointerPos(newPointerPos);\r\n+          pointer.position.set(\r\n+            newPointerPos.x,\r\n+            newPointerPos.y,\r\n+            newPointerPos.z\r\n+          );\r\n+          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+          showPopupAnimation(true);\r\n+          clock.start();\r\n+        }\r\n+      }\r\n+    });\r\n+  };\r\n+\r\n+  const updateMousePosition = (eX, eY) => {\r\n+    const rect = containerRef.current.getBoundingClientRect();\r\n+    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+  };\r\n+\r\n+  const checkIntersects = () => {\r\n+    if (!globeMesh) return [];\r\n+    rayCaster.setFromCamera(mouse, camera);\r\n+    const intersects = rayCaster.intersectObject(globeMesh);\r\n+    if (intersects.length) {\r\n+      document.body.style.cursor = 'pointer';\r\n+    } else {\r\n+      document.body.style.cursor = 'auto';\r\n+    }\r\n+    return intersects;\r\n+  };\r\n+\r\n+  const render = () => {\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+    }\r\n+    checkIntersects();\r\n+    if (pointer) {\r\n+      updateOverlayGraphic();\r\n+    }\r\n+    controls.update();\r\n+    renderer.render(scene, camera);\r\n+    requestAnimationFrame(render);\r\n+  };\r\n+\r\n+  const updateSize = () => {\r\n+    if (!renderer) return;\r\n+    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+    containerRef.current.style.width = `${minSide}px`;\r\n+    containerRef.current.style.height = `${minSide}px`;\r\n+    renderer.setSize(minSide, minSide);\r\n+    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+    }\r\n+  };\r\n+\r\n+  const cartesianToLatLong = (pos) => {\r\n+    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+      lng,\r\n+      'E',\r\n+      'W'\r\n+    )}`;\r\n+  };\r\n+\r\n+  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+  };\r\n+\r\n+  const createPopupTimelines = () => {\r\n+    const popupOpenTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, {\r\n+        duration: 0.2,\r\n+        opacity: 1,\r\n+      }, 0)\r\n+      .fromTo(\r\n+        canvas2DRef.current,\r\n+        { opacity: 0 },\r\n+        { duration: 0.3, opacity: 1 },\r\n+        0.15\r\n+      )\r\n+      .fromTo(\r\n+        popupRef.current,\r\n+        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+        { duration: 0.1, opacity: 1, scale: 1 },\r\n+        0.25\r\n+      );\r\n+    setPopupOpenTl(popupOpenTl);\r\n+\r\n+    const popupCloseTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+      .to(popupRef.current, {\r\n+        duration: 0.3,\r\n+        opacity: 0,\r\n+        scale: 0.9,\r\n+        transformOrigin: 'center bottom',\r\n+      }, 0);\r\n+    setPopupCloseTl(popupCloseTl);\r\n+  };\r\n+\r\n+  const showPopupAnimation = (lifted) => {\r\n+    if (lifted) {\r\n+      let positionLifted = pointer.position.clone();\r\n+      positionLifted.multiplyScalar(1.3);\r\n+      gsap.from(pointer.position, {\r\n+        duration: 0.25,\r\n+        x: positionLifted.x,\r\n+        y: positionLifted.y,\r\n+        z: positionLifted.z,\r\n+        ease: 'power3.out',\r\n+      });\r\n+    }\r\n+    popupCloseTl.pause(0);\r\n+    popupOpenTl.play(0);\r\n+  };\r\n+\r\n+  const updateOverlayGraphic = () => {\r\n+    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+    let activePointPosition = pointer.position.clone();\r\n+    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+    const activePointPositionProjected = activePointPosition.clone();\r\n+    activePointPositionProjected.project(camera);\r\n+    const coordinates2D = [\r\n+      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+    ];\r\n+\r\n+    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+    if (activePointPosition.z > -1) {\r\n+      if (!popupVisible) {\r\n+        setPopupVisible(true);\r\n+        showPopupAnimation(false);\r\n+      }\r\n+\r\n+      let popupX = coordinates2D[0];\r\n+      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+      let popupY = coordinates2D[1];\r\n+      const upDown = activePointPositionProjected.y > 0.6;\r\n+      popupY += upDown ? 20 : -20;\r\n+\r\n+      gsap.set(popupRef.current, {\r\n+        x: popupX,\r\n+        y: popupY,\r\n+        xPercent: -35,\r\n+        yPercent: upDown ? 0 : -100,\r\n+      });\r\n+\r\n+      popupY += upDown ? -5 : 5;\r\n+      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+    } else {\r\n+      if (popupVisible) {\r\n+        popupOpenTl.pause(0);\r\n+        popupCloseTl.play(0);\r\n+      }\r\n+      setPopupVisible(false);\r\n+    }\r\n+  };\r\n+\r\n+  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+    ctx.strokeStyle = '#000000';\r\n+    ctx.lineWidth = 3;\r\n+    ctx.lineCap = 'round';\r\n+    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+    ctx.beginPath();\r\n+    ctx.moveTo(startX, startY);\r\n+    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+    ctx.stroke();\r\n+  };\r\n+\r\n+  return (\r\n+    <div className='page'>\r\n+      <div className='title'>Click to add a pointer</div>\r\n+      <div className='globe-wrapper' ref={containerRef}>\r\n+        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+        <div id='globe-popup-overlay'>\r\n+          <div className='globe-popup' ref={popupRef}></div>\r\n+        </div>\r\n+      </div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n"
                },
                {
                    "date": 1708583237886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,63 @@\n import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n import { gsap } from 'gsap';\r\n import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n \r\n+// Vertex shader\r\n+const vertexShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+    uniform float u_dot_size;\r\n+    uniform float u_time_since_click;\r\n+    uniform vec3 u_pointer;\r\n+\r\n+    #define PI 3.14159265359\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vUv = uv;\r\n+\r\n+        // mask with world map\r\n+        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+        gl_PointSize = visibility * u_dot_size;\r\n+\r\n+        // make back dots semi-transparent\r\n+        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+        vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+        // add ripple\r\n+        float t = u_time_since_click - .1;\r\n+        t = max(0., t);\r\n+        float max_amp = .15;\r\n+        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+        delta *= 1. - smoothstep(.8, 1., dist);\r\n+        vec3 pos = position;\r\n+        pos *= (1. + delta);\r\n+\r\n+        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+    }\r\n+`;\r\n+\r\n+// Fragment shader\r\n+const fragmentShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+        if (dot < 0.5) discard;\r\n+        gl_FragColor = vec4(color, dot * vOpacity);\r\n+    }\r\n+`;\r\n+\r\n const Globe = () => {\r\n   const containerRef = useRef(null);\r\n   const canvas3DRef = useRef(null);\r\n   const canvas2DRef = useRef(null);\r\n@@ -351,424 +406,4 @@\n   );\r\n };\r\n \r\n export default Globe;\r\n-import React, { useEffect, useRef, useState } from \"react\";\r\n-import * as THREE from \"three\";\r\n-import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\n-import { gsap } from \"gsap\";\r\n-import \"./Globe.css\"; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// Vertex shader\r\n-const vertexShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-    uniform float u_dot_size;\r\n-    uniform float u_time_since_click;\r\n-    uniform vec3 u_pointer;\r\n-\r\n-    #define PI 3.14159265359\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vUv = uv;\r\n-\r\n-        // mask with world map\r\n-        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-        gl_PointSize = visibility * u_dot_size;\r\n-\r\n-        // make back dots semi-transparent\r\n-        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-        vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-        // add ripple\r\n-        float t = u_time_since_click - .1;\r\n-        t = max(0., t);\r\n-        float max_amp = .15;\r\n-        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-        delta *= 1. - smoothstep(.8, 1., dist);\r\n-        vec3 pos = position;\r\n-        pos *= (1. + delta);\r\n-\r\n-        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-    }\r\n-`;\r\n-\r\n-// Fragment shader\r\n-const fragmentShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n-        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-        if (dot < 0.5) discard;\r\n-        gl_FragColor = vec4(color, dot * vOpacity);\r\n-    }\r\n-`;\r\n-\r\n-const Globe = () => {\r\n-  const containerRef = useRef(null);\r\n-  const canvas3DRef = useRef(null);\r\n-  const canvas2DRef = useRef(null);\r\n-  const popupRef = useRef(null);\r\n-\r\n-  const [renderer, setRenderer] = useState(null);\r\n-  const [scene, setScene] = useState(null);\r\n-  const [camera, setCamera] = useState(null);\r\n-  const [rayCaster, setRayCaster] = useState(null);\r\n-  const [controls, setControls] = useState(null);\r\n-  const [pointer, setPointer] = useState(null);\r\n-  const [globe, setGlobe] = useState(null);\r\n-  const [globeMesh, setGlobeMesh] = useState(null);\r\n-  const [mapMaterial, setMapMaterial] = useState(null);\r\n-  const [popupVisible, setPopupVisible] = useState(false);\r\n-  const [pointerPos, setPointerPos] = useState(null);\r\n-  const [clock, setClock] = useState(new THREE.Clock());\r\n-  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-  const [dragged, setDragged] = useState(false);\r\n-  const [earthTexture, setEarthTexture] = useState(null);\r\n-  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-  useEffect(() => {\r\n-    initScene();\r\n-    window.addEventListener(\"resize\", updateSize);\r\n-    return () => {\r\n-      window.removeEventListener(\"resize\", updateSize);\r\n-    };\r\n-  }, []);\r\n-\r\n-  useEffect(() => {\r\n-    if (renderer && scene && camera) {\r\n-      updateSize();\r\n-      render();\r\n-    }\r\n-  }, [renderer, scene, camera]);\r\n-\r\n-  const initScene = () => {\r\n-    const renderer = new THREE.WebGLRenderer({\r\n-      canvas: canvas3DRef.current,\r\n-      alpha: true,\r\n-    });\r\n-    renderer.setPixelRatio(window.devicePixelRatio);\r\n-    setRenderer(renderer);\r\n-\r\n-    const scene = new THREE.Scene();\r\n-    setScene(scene);\r\n-\r\n-    const camera = new THREE.OrthographicCamera(\r\n-      -1.1,\r\n-      1.1,\r\n-      1.1,\r\n-      -1.1,\r\n-      0,\r\n-      3\r\n-    );\r\n-    camera.position.z = 1.1;\r\n-    setCamera(camera);\r\n-\r\n-    const rayCaster = new THREE.Raycaster();\r\n-    rayCaster.far = 1.15;\r\n-    setRayCaster(rayCaster);\r\n-\r\n-    createOrbitControls(camera, renderer.domElement);\r\n-\r\n-    new THREE.TextureLoader().load(\r\n-      \"https://ksenia-k.com/img/earth-map-colored.png\",\r\n-      (mapTex) => {\r\n-        setEarthTexture(mapTex);\r\n-        mapTex.repeat.set(1, 1);\r\n-        createGlobe(mapTex);\r\n-        createPointer();\r\n-        createPopupTimelines();\r\n-        addCanvasEvents();\r\n-      }\r\n-    );\r\n-  };\r\n-\r\n-  const createOrbitControls = (camera, canvas) => {\r\n-    const controls = new OrbitControls(camera, canvas);\r\n-    controls.enablePan = false;\r\n-    controls.enableZoom = false;\r\n-    controls.enableDamping = true;\r\n-    controls.minPolarAngle = 0.4 * Math.PI;\r\n-    controls.maxPolarAngle = 0.4 * Math.PI;\r\n-    controls.autoRotate = true;\r\n-\r\n-    let timestamp;\r\n-    controls.addEventListener(\"start\", () => {\r\n-      timestamp = Date.now();\r\n-    });\r\n-    controls.addEventListener(\"end\", () => {\r\n-      setDragged(Date.now() - timestamp > 600);\r\n-    });\r\n-\r\n-    setControls(controls);\r\n-  };\r\n-\r\n-\r\n-  const createPointer = () => {\r\n-    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-    const material = new THREE.MeshBasicMaterial({\r\n-      color: 0x000000,\r\n-      transparent: true,\r\n-      opacity: 0,\r\n-    });\r\n-    const pointer = new THREE.Mesh(geometry, material);\r\n-    scene.add(pointer);\r\n-    setPointer(pointer);\r\n-  };\r\n-\r\n-  const addCanvasEvents = () => {\r\n-    containerRef.current.addEventListener(\"mousemove\", (e) => {\r\n-      updateMousePosition(e.clientX, e.clientY);\r\n-    });\r\n-\r\n-    containerRef.current.addEventListener(\"click\", (e) => {\r\n-      if (!dragged) {\r\n-        updateMousePosition(\r\n-          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-        );\r\n-\r\n-        const res = checkIntersects();\r\n-        if (res.length) {\r\n-          const newPointerPos = res[0].face.normal.clone();\r\n-          setPointerPos(newPointerPos);\r\n-          pointer.position.set(\r\n-            newPointerPos.x,\r\n-            newPointerPos.y,\r\n-            newPointerPos.z\r\n-          );\r\n-          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-          showPopupAnimation(true);\r\n-          clock.start();\r\n-        }\r\n-      }\r\n-    });\r\n-  };\r\n-\r\n-  const updateMousePosition = (eX, eY) => {\r\n-    const rect = containerRef.current.getBoundingClientRect();\r\n-    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-  };\r\n-\r\n-// Add checks for null objects in the Globe component\r\n-\r\n-const checkIntersects = () => {\r\n-    if (!globeMesh) return []; // Add this check\r\n-    rayCaster.setFromCamera(mouse, camera);\r\n-    const intersects = rayCaster.intersectObject(globeMesh);\r\n-    if (intersects.length) {\r\n-      document.body.style.cursor = \"pointer\";\r\n-    } else {\r\n-      document.body.style.cursor = \"auto\";\r\n-    }\r\n-    return intersects;\r\n-  };\r\n-  \r\n-  const createGlobe = (earthTexture) => {\r\n-    if (!scene) return; // Add this check\r\n-    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-    const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: vertexShader,\r\n-      fragmentShader: fragmentShader,\r\n-      uniforms: {\r\n-        u_map_tex: { type: \"t\", value: earthTexture },\r\n-        u_dot_size: { type: \"f\", value: 0 },\r\n-        u_pointer: { type: \"v3\", value: new THREE.Vector3(0, 0, 1) },\r\n-        u_time_since_click: { value: 0 },\r\n-      },\r\n-      alphaTest: false,\r\n-      transparent: true,\r\n-    });\r\n-    setMapMaterial(mapMaterial);\r\n-  \r\n-    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-    scene.add(globe);\r\n-    setGlobe(globe);\r\n-  \r\n-    const globeMesh = new THREE.Mesh(\r\n-      globeGeometry,\r\n-      new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n-        transparent: true,\r\n-        opacity: 0.05,\r\n-      })\r\n-    );\r\n-    scene.add(globeMesh);\r\n-    setGlobeMesh(globeMesh);\r\n-  };\r\n-  \r\n-\r\n-  const render = () => {\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-    }\r\n-    checkIntersects();\r\n-    if (pointer) {\r\n-      updateOverlayGraphic();\r\n-    }\r\n-    controls.update();\r\n-    renderer.render(scene, camera);\r\n-    requestAnimationFrame(render);\r\n-  };\r\n-\r\n-  const updateSize = () => {\r\n-    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-    containerRef.current.style.width = `${minSide}px`;\r\n-    containerRef.current.style.height = `${minSide}px`;\r\n-    renderer.setSize(minSide, minSide);\r\n-    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-    }\r\n-  };\r\n-\r\n-  const cartesianToLatLong = (pos) => {\r\n-    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-    return `${formatCoordinate(lat, \"N\", \"S\")}, ${formatCoordinate(\r\n-      lng,\r\n-      \"E\",\r\n-      \"W\"\r\n-    )}`;\r\n-  };\r\n-\r\n-  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-  };\r\n-\r\n-  const createPopupTimelines = () => {\r\n-    const popupOpenTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, {\r\n-        duration: 0.2,\r\n-        opacity: 1,\r\n-      }, 0)\r\n-      .fromTo(\r\n-        canvas2DRef.current,\r\n-        { opacity: 0 },\r\n-        { duration: 0.3, opacity: 1 },\r\n-        0.15\r\n-      )\r\n-      .fromTo(\r\n-        popupRef.current,\r\n-        { opacity: 0, scale: 0.9, transformOrigin: \"center bottom\" },\r\n-        { duration: 0.1, opacity: 1, scale: 1 },\r\n-        0.25\r\n-      );\r\n-    setPopupOpenTl(popupOpenTl);\r\n-\r\n-    const popupCloseTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-      .to(popupRef.current, {\r\n-        duration: 0.3,\r\n-        opacity: 0,\r\n-        scale: 0.9,\r\n-        transformOrigin: \"center bottom\",\r\n-      }, 0);\r\n-    setPopupCloseTl(popupCloseTl);\r\n-  };\r\n-\r\n-  const showPopupAnimation = (lifted) => {\r\n-    if (lifted) {\r\n-      let positionLifted = pointer.position.clone();\r\n-      positionLifted.multiplyScalar(1.3);\r\n-      gsap.from(pointer.position, {\r\n-        duration: 0.25,\r\n-        x: positionLifted.x,\r\n-        y: positionLifted.y,\r\n-        z: positionLifted.z,\r\n-        ease: \"power3.out\",\r\n-      });\r\n-    }\r\n-    popupCloseTl.pause(0);\r\n-    popupOpenTl.play(0);\r\n-  };\r\n-\r\n-  const updateOverlayGraphic = () => {\r\n-    const overlayCtx = canvas2DRef.current.getContext(\"2d\");\r\n-    let activePointPosition = pointer.position.clone();\r\n-    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-    const activePointPositionProjected = activePointPosition.clone();\r\n-    activePointPositionProjected.project(camera);\r\n-    const coordinates2D = [\r\n-      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-    ];\r\n-\r\n-    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-    if (activePointPosition.z > -1) {\r\n-      if (!popupVisible) {\r\n-        setPopupVisible(true);\r\n-        showPopupAnimation(false);\r\n-      }\r\n-\r\n-      let popupX = coordinates2D[0];\r\n-      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-      let popupY = coordinates2D[1];\r\n-      const upDown = activePointPositionProjected.y > 0.6;\r\n-      popupY += upDown ? 20 : -20;\r\n-\r\n-      gsap.set(popupRef.current, {\r\n-        x: popupX,\r\n-        y: popupY,\r\n-        xPercent: -35,\r\n-        yPercent: upDown ? 0 : -100,\r\n-      });\r\n-\r\n-      popupY += upDown ? -5 : 5;\r\n-      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-    } else {\r\n-      if (popupVisible) {\r\n-        popupOpenTl.pause(0);\r\n-        popupCloseTl.play(0);\r\n-      }\r\n-      setPopupVisible(false);\r\n-    }\r\n-  };\r\n-\r\n-  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-    ctx.strokeStyle = \"#000000\";\r\n-    ctx.lineWidth = 3;\r\n-    ctx.lineCap = \"round\";\r\n-    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-    ctx.beginPath();\r\n-    ctx.moveTo(startX, startY);\r\n-    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-    ctx.stroke();\r\n-  };\r\n-\r\n-  return (\r\n-    <div className=\"page\">\r\n-      <div className=\"title\">Click to add a pointer</div>\r\n-      <div className=\"globe-wrapper\" ref={containerRef}>\r\n-        <canvas id=\"globe-3d\" ref={canvas3DRef}></canvas>\r\n-        <canvas id=\"globe-2d-overlay\" ref={canvas2DRef}></canvas>\r\n-        <div id=\"globe-popup-overlay\">\r\n-          <div className=\"globe-popup\" ref={popupRef}></div>\r\n-        </div>\r\n-      </div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default Globe;\r\n"
                },
                {
                    "date": 1708583603754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,41 +98,26 @@\n     }\r\n   }, [renderer, scene, camera]);\r\n \r\n   const initScene = () => {\r\n-    const renderer = new THREE.WebGLRenderer({\r\n-      canvas: canvas3DRef.current,\r\n-      alpha: true,\r\n-    });\r\n-    renderer.setPixelRatio(window.devicePixelRatio);\r\n-    setRenderer(renderer);\r\n+    // Renderer, scene, and camera setup\r\n \r\n-    const camera = new THREE.OrthographicCamera(\r\n-      -1.1,\r\n-      1.1,\r\n-      1.1,\r\n-      -1.1,\r\n-      0,\r\n-      3\r\n-    );\r\n-    camera.position.z = 1.1;\r\n-    setCamera(camera);\r\n-\r\n     createOrbitControls(camera, renderer.domElement);\r\n \r\n     new THREE.TextureLoader().load(\r\n       'https://ksenia-k.com/img/earth-map-colored.png',\r\n       (mapTex) => {\r\n         setEarthTexture(mapTex);\r\n         mapTex.repeat.set(1, 1);\r\n         createGlobe(mapTex);\r\n-        createPointer();\r\n-        createPopupTimelines();\r\n+        createPointer(); // Ensure this is called before createPopupTimelines\r\n+        createPopupTimelines(); // This should be called after createPointer\r\n         addCanvasEvents();\r\n       }\r\n     );\r\n   };\r\n \r\n+\r\n   const createOrbitControls = (camera, canvas) => {\r\n     const controls = new OrbitControls(camera, canvas);\r\n     controls.enablePan = false;\r\n     controls.enableZoom = false;\r\n"
                },
                {
                    "date": 1708583760255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,12 +98,26 @@\n     }\r\n   }, [renderer, scene, camera]);\r\n \r\n   const initScene = () => {\r\n-    // Renderer, scene, and camera setup\r\n-\r\n-    createOrbitControls(camera, renderer.domElement);\r\n-\r\n+    const renderer = new THREE.WebGLRenderer({\r\n+      canvas: canvas3DRef.current,\r\n+      alpha: true,\r\n+    });\r\n+    renderer.setPixelRatio(window.devicePixelRatio);\r\n+    setRenderer(renderer);\r\n+  \r\n+    const camera = new THREE.OrthographicCamera(\r\n+      -1.1,\r\n+      1.1,\r\n+      1.1,\r\n+      -1.1,\r\n+      0,\r\n+      3\r\n+    );\r\n+    camera.position.z = 1.1;\r\n+    setCamera(camera);\r\n+  \r\n     new THREE.TextureLoader().load(\r\n       'https://ksenia-k.com/img/earth-map-colored.png',\r\n       (mapTex) => {\r\n         setEarthTexture(mapTex);\r\n@@ -113,9 +127,12 @@\n         createPopupTimelines(); // This should be called after createPointer\r\n         addCanvasEvents();\r\n       }\r\n     );\r\n+  \r\n+    createOrbitControls(camera, renderer.domElement); // Call this after renderer is set up\r\n   };\r\n+  \r\n \r\n \r\n   const createOrbitControls = (camera, canvas) => {\r\n     const controls = new OrbitControls(camera, canvas);\r\n"
                },
                {
                    "date": 1708583952390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,395 @@\n+import React, { useEffect, useRef, useState } from 'react';\r\n+import * as THREE from 'three';\r\n+import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+import { gsap } from 'gsap';\r\n+import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// Vertex shader\r\n+const vertexShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+    uniform float u_dot_size;\r\n+    uniform float u_time_since_click;\r\n+    uniform vec3 u_pointer;\r\n+\r\n+    #define PI 3.14159265359\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vUv = uv;\r\n+\r\n+        // mask with world map\r\n+        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+        gl_PointSize = visibility * u_dot_size;\r\n+\r\n+        // make back dots semi-transparent\r\n+        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+        vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+        // add ripple\r\n+        float t = u_time_since_click - .1;\r\n+        t = max(0., t);\r\n+        float max_amp = .15;\r\n+        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+        delta *= 1. - smoothstep(.8, 1., dist);\r\n+        vec3 pos = position;\r\n+        pos *= (1. + delta);\r\n+\r\n+        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+    }\r\n+`;\r\n+\r\n+// Fragment shader\r\n+const fragmentShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+        if (dot < 0.5) discard;\r\n+        gl_FragColor = vec4(color, dot * vOpacity);\r\n+    }\r\n+`;\r\n+\r\n+const Globe = () => {\r\n+  const containerRef = useRef(null);\r\n+  const canvas3DRef = useRef(null);\r\n+  const canvas2DRef = useRef(null);\r\n+  const popupRef = useRef(null);\r\n+\r\n+  const [renderer, setRenderer] = useState(null);\r\n+  const [scene, setScene] = useState(new THREE.Scene());\r\n+  const [camera, setCamera] = useState(null);\r\n+  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+  const [controls, setControls] = useState(null);\r\n+  const [pointer, setPointer] = useState(null);\r\n+  const [globe, setGlobe] = useState(null);\r\n+  const [globeMesh, setGlobeMesh] = useState(null);\r\n+  const [mapMaterial, setMapMaterial] = useState(null);\r\n+  const [popupVisible, setPopupVisible] = useState(false);\r\n+  const [pointerPos, setPointerPos] = useState(null);\r\n+  const [clock, setClock] = useState(new THREE.Clock());\r\n+  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+  const [dragged, setDragged] = useState(false);\r\n+  const [earthTexture, setEarthTexture] = useState(null);\r\n+  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+  useEffect(() => {\r\n+    initScene();\r\n+    window.addEventListener('resize', updateSize);\r\n+    return () => {\r\n+      window.removeEventListener('resize', updateSize);\r\n+    };\r\n+  }, []);\r\n+\r\n+  useEffect(() => {\r\n+    if (renderer && scene && camera) {\r\n+      updateSize();\r\n+      render();\r\n+    }\r\n+  }, [renderer, scene, camera]);\r\n+\r\n+  const initScene = () => {\r\n+    // Renderer, scene, and camera setup\r\n+\r\n+    new THREE.TextureLoader().load(\r\n+      'https://ksenia-k.com/img/earth-map-colored.png',\r\n+      (mapTex) => {\r\n+        setEarthTexture(mapTex);\r\n+        mapTex.repeat.set(1, 1);\r\n+        createGlobe(mapTex);\r\n+        createPointer(); // Ensure this is called before createPopupTimelines\r\n+        createPopupTimelines(); // This should be called after createPointer\r\n+        addCanvasEvents();\r\n+      }\r\n+    );\r\n+\r\n+    createOrbitControls(camera, renderer.domElement); // Call this after renderer is set up\r\n+  };\r\n+  \r\n+\r\n+\r\n+//   const createOrbitControls = (camera, canvas) => {\r\n+//     const controls = new OrbitControls(camera, canvas);\r\n+//     controls.enablePan = false;\r\n+//     controls.enableZoom = false;\r\n+//     controls.enableDamping = true;\r\n+//     controls.minPolarAngle = 0.4 * Math.PI;\r\n+//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n+//     controls.autoRotate = true;\r\n+\r\n+//     let timestamp;\r\n+//     controls.addEventListener('start', () => {\r\n+//       timestamp = Date.now();\r\n+//     });\r\n+//     controls.addEventListener('end', () => {\r\n+//       setDragged(Date.now() - timestamp > 600);\r\n+//     });\r\n+\r\n+//     setControls(controls);\r\n+//   };\r\n+\r\n+  const createGlobe = (earthTexture) => {\r\n+    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+    const mapMaterial = new THREE.ShaderMaterial({\r\n+      vertexShader: vertexShader,\r\n+      fragmentShader: fragmentShader,\r\n+      uniforms: {\r\n+        u_map_tex: { type: 't', value: earthTexture },\r\n+        u_dot_size: { type: 'f', value: 0 },\r\n+        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+        u_time_since_click: { value: 0 },\r\n+      },\r\n+      alphaTest: false,\r\n+      transparent: true,\r\n+    });\r\n+    setMapMaterial(mapMaterial);\r\n+\r\n+    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+    scene.add(globe);\r\n+    setGlobe(globe);\r\n+\r\n+    const globeMesh = new THREE.Mesh(\r\n+      globeGeometry,\r\n+      new THREE.MeshBasicMaterial({\r\n+        color: 0x222222,\r\n+        transparent: true,\r\n+        opacity: 0.05,\r\n+      })\r\n+    );\r\n+    scene.add(globeMesh);\r\n+    setGlobeMesh(globeMesh);\r\n+  };\r\n+\r\n+  const createPointer = () => {\r\n+    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+    const material = new THREE.MeshBasicMaterial({\r\n+      color: 0x000000,\r\n+      transparent: true,\r\n+      opacity: 0,\r\n+    });\r\n+    const pointer = new THREE.Mesh(geometry, material);\r\n+    scene.add(pointer);\r\n+    setPointer(pointer);\r\n+  };\r\n+\r\n+  const addCanvasEvents = () => {\r\n+    containerRef.current.addEventListener('mousemove', (e) => {\r\n+      updateMousePosition(e.clientX, e.clientY);\r\n+    });\r\n+\r\n+    containerRef.current.addEventListener('click', (e) => {\r\n+      if (!dragged) {\r\n+        updateMousePosition(\r\n+          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+        );\r\n+\r\n+        const res = checkIntersects();\r\n+        if (res.length) {\r\n+          const newPointerPos = res[0].face.normal.clone();\r\n+          setPointerPos(newPointerPos);\r\n+          pointer.position.set(\r\n+            newPointerPos.x,\r\n+            newPointerPos.y,\r\n+            newPointerPos.z\r\n+          );\r\n+          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+          showPopupAnimation(true);\r\n+          clock.start();\r\n+        }\r\n+      }\r\n+    });\r\n+  };\r\n+\r\n+  const updateMousePosition = (eX, eY) => {\r\n+    const rect = containerRef.current.getBoundingClientRect();\r\n+    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+  };\r\n+\r\n+  const checkIntersects = () => {\r\n+    if (!globeMesh) return [];\r\n+    rayCaster.setFromCamera(mouse, camera);\r\n+    const intersects = rayCaster.intersectObject(globeMesh);\r\n+    if (intersects.length) {\r\n+      document.body.style.cursor = 'pointer';\r\n+    } else {\r\n+      document.body.style.cursor = 'auto';\r\n+    }\r\n+    return intersects;\r\n+  };\r\n+\r\n+  const render = () => {\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+    }\r\n+    checkIntersects();\r\n+    if (pointer) {\r\n+      updateOverlayGraphic();\r\n+    }\r\n+    controls.update();\r\n+    renderer.render(scene, camera);\r\n+    requestAnimationFrame(render);\r\n+  };\r\n+\r\n+  const updateSize = () => {\r\n+    if (!renderer) return;\r\n+    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+    containerRef.current.style.width = `${minSide}px`;\r\n+    containerRef.current.style.height = `${minSide}px`;\r\n+    renderer.setSize(minSide, minSide);\r\n+    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+    }\r\n+  };\r\n+\r\n+  const cartesianToLatLong = (pos) => {\r\n+    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+      lng,\r\n+      'E',\r\n+      'W'\r\n+    )}`;\r\n+  };\r\n+\r\n+  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+  };\r\n+\r\n+  const createPopupTimelines = () => {\r\n+    const popupOpenTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, {\r\n+        duration: 0.2,\r\n+        opacity: 1,\r\n+      }, 0)\r\n+      .fromTo(\r\n+        canvas2DRef.current,\r\n+        { opacity: 0 },\r\n+        { duration: 0.3, opacity: 1 },\r\n+        0.15\r\n+      )\r\n+      .fromTo(\r\n+        popupRef.current,\r\n+        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+        { duration: 0.1, opacity: 1, scale: 1 },\r\n+        0.25\r\n+      );\r\n+    setPopupOpenTl(popupOpenTl);\r\n+\r\n+    const popupCloseTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+      .to(popupRef.current, {\r\n+        duration: 0.3,\r\n+        opacity: 0,\r\n+        scale: 0.9,\r\n+        transformOrigin: 'center bottom',\r\n+      }, 0);\r\n+    setPopupCloseTl(popupCloseTl);\r\n+  };\r\n+\r\n+  const showPopupAnimation = (lifted) => {\r\n+    if (lifted) {\r\n+      let positionLifted = pointer.position.clone();\r\n+      positionLifted.multiplyScalar(1.3);\r\n+      gsap.from(pointer.position, {\r\n+        duration: 0.25,\r\n+        x: positionLifted.x,\r\n+        y: positionLifted.y,\r\n+        z: positionLifted.z,\r\n+        ease: 'power3.out',\r\n+      });\r\n+    }\r\n+    popupCloseTl.pause(0);\r\n+    popupOpenTl.play(0);\r\n+  };\r\n+\r\n+  const updateOverlayGraphic = () => {\r\n+    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+    let activePointPosition = pointer.position.clone();\r\n+    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+    const activePointPositionProjected = activePointPosition.clone();\r\n+    activePointPositionProjected.project(camera);\r\n+    const coordinates2D = [\r\n+      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+    ];\r\n+\r\n+    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+    if (activePointPosition.z > -1) {\r\n+      if (!popupVisible) {\r\n+        setPopupVisible(true);\r\n+        showPopupAnimation(false);\r\n+      }\r\n+\r\n+      let popupX = coordinates2D[0];\r\n+      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+      let popupY = coordinates2D[1];\r\n+      const upDown = activePointPositionProjected.y > 0.6;\r\n+      popupY += upDown ? 20 : -20;\r\n+\r\n+      gsap.set(popupRef.current, {\r\n+        x: popupX,\r\n+        y: popupY,\r\n+        xPercent: -35,\r\n+        yPercent: upDown ? 0 : -100,\r\n+      });\r\n+\r\n+      popupY += upDown ? -5 : 5;\r\n+      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+    } else {\r\n+      if (popupVisible) {\r\n+        popupOpenTl.pause(0);\r\n+        popupCloseTl.play(0);\r\n+      }\r\n+      setPopupVisible(false);\r\n+    }\r\n+  };\r\n+\r\n+  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+    ctx.strokeStyle = '#000000';\r\n+    ctx.lineWidth = 3;\r\n+    ctx.lineCap = 'round';\r\n+    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+    ctx.beginPath();\r\n+    ctx.moveTo(startX, startY);\r\n+    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+    ctx.stroke();\r\n+  };\r\n+\r\n+  return (\r\n+    <div className='page'>\r\n+      <div className='title'>Click to add a pointer</div>\r\n+      <div className='globe-wrapper' ref={containerRef}>\r\n+        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+        <div id='globe-popup-overlay'>\r\n+          <div className='globe-popup' ref={popupRef}></div>\r\n+        </div>\r\n+      </div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n"
                },
                {
                    "date": 1708583959553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,419 +117,8 @@\n   };\r\n   \r\n \r\n \r\n-//   const createOrbitControls = (camera, canvas) => {\r\n-//     const controls = new OrbitControls(camera, canvas);\r\n-//     controls.enablePan = false;\r\n-//     controls.enableZoom = false;\r\n-//     controls.enableDamping = true;\r\n-//     controls.minPolarAngle = 0.4 * Math.PI;\r\n-//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n-//     controls.autoRotate = true;\r\n-\r\n-//     let timestamp;\r\n-//     controls.addEventListener('start', () => {\r\n-//       timestamp = Date.now();\r\n-//     });\r\n-//     controls.addEventListener('end', () => {\r\n-//       setDragged(Date.now() - timestamp > 600);\r\n-//     });\r\n-\r\n-//     setControls(controls);\r\n-//   };\r\n-\r\n-  const createGlobe = (earthTexture) => {\r\n-    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-    const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: vertexShader,\r\n-      fragmentShader: fragmentShader,\r\n-      uniforms: {\r\n-        u_map_tex: { type: 't', value: earthTexture },\r\n-        u_dot_size: { type: 'f', value: 0 },\r\n-        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n-        u_time_since_click: { value: 0 },\r\n-      },\r\n-      alphaTest: false,\r\n-      transparent: true,\r\n-    });\r\n-    setMapMaterial(mapMaterial);\r\n-\r\n-    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-    scene.add(globe);\r\n-    setGlobe(globe);\r\n-\r\n-    const globeMesh = new THREE.Mesh(\r\n-      globeGeometry,\r\n-      new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n-        transparent: true,\r\n-        opacity: 0.05,\r\n-      })\r\n-    );\r\n-    scene.add(globeMesh);\r\n-    setGlobeMesh(globeMesh);\r\n-  };\r\n-\r\n-  const createPointer = () => {\r\n-    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-    const material = new THREE.MeshBasicMaterial({\r\n-      color: 0x000000,\r\n-      transparent: true,\r\n-      opacity: 0,\r\n-    });\r\n-    const pointer = new THREE.Mesh(geometry, material);\r\n-    scene.add(pointer);\r\n-    setPointer(pointer);\r\n-  };\r\n-\r\n-  const addCanvasEvents = () => {\r\n-    containerRef.current.addEventListener('mousemove', (e) => {\r\n-      updateMousePosition(e.clientX, e.clientY);\r\n-    });\r\n-\r\n-    containerRef.current.addEventListener('click', (e) => {\r\n-      if (!dragged) {\r\n-        updateMousePosition(\r\n-          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-        );\r\n-\r\n-        const res = checkIntersects();\r\n-        if (res.length) {\r\n-          const newPointerPos = res[0].face.normal.clone();\r\n-          setPointerPos(newPointerPos);\r\n-          pointer.position.set(\r\n-            newPointerPos.x,\r\n-            newPointerPos.y,\r\n-            newPointerPos.z\r\n-          );\r\n-          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-          showPopupAnimation(true);\r\n-          clock.start();\r\n-        }\r\n-      }\r\n-    });\r\n-  };\r\n-\r\n-  const updateMousePosition = (eX, eY) => {\r\n-    const rect = containerRef.current.getBoundingClientRect();\r\n-    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-  };\r\n-\r\n-  const checkIntersects = () => {\r\n-    if (!globeMesh) return [];\r\n-    rayCaster.setFromCamera(mouse, camera);\r\n-    const intersects = rayCaster.intersectObject(globeMesh);\r\n-    if (intersects.length) {\r\n-      document.body.style.cursor = 'pointer';\r\n-    } else {\r\n-      document.body.style.cursor = 'auto';\r\n-    }\r\n-    return intersects;\r\n-  };\r\n-\r\n-  const render = () => {\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-    }\r\n-    checkIntersects();\r\n-    if (pointer) {\r\n-      updateOverlayGraphic();\r\n-    }\r\n-    controls.update();\r\n-    renderer.render(scene, camera);\r\n-    requestAnimationFrame(render);\r\n-  };\r\n-\r\n-  const updateSize = () => {\r\n-    if (!renderer) return;\r\n-    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-    containerRef.current.style.width = `${minSide}px`;\r\n-    containerRef.current.style.height = `${minSide}px`;\r\n-    renderer.setSize(minSide, minSide);\r\n-    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-    }\r\n-  };\r\n-\r\n-  const cartesianToLatLong = (pos) => {\r\n-    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n-      lng,\r\n-      'E',\r\n-      'W'\r\n-    )}`;\r\n-  };\r\n-\r\n-  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-  };\r\n-\r\n-  const createPopupTimelines = () => {\r\n-    const popupOpenTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, {\r\n-        duration: 0.2,\r\n-        opacity: 1,\r\n-      }, 0)\r\n-      .fromTo(\r\n-        canvas2DRef.current,\r\n-        { opacity: 0 },\r\n-        { duration: 0.3, opacity: 1 },\r\n-        0.15\r\n-      )\r\n-      .fromTo(\r\n-        popupRef.current,\r\n-        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n-        { duration: 0.1, opacity: 1, scale: 1 },\r\n-        0.25\r\n-      );\r\n-    setPopupOpenTl(popupOpenTl);\r\n-\r\n-    const popupCloseTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-      .to(popupRef.current, {\r\n-        duration: 0.3,\r\n-        opacity: 0,\r\n-        scale: 0.9,\r\n-        transformOrigin: 'center bottom',\r\n-      }, 0);\r\n-    setPopupCloseTl(popupCloseTl);\r\n-  };\r\n-\r\n-  const showPopupAnimation = (lifted) => {\r\n-    if (lifted) {\r\n-      let positionLifted = pointer.position.clone();\r\n-      positionLifted.multiplyScalar(1.3);\r\n-      gsap.from(pointer.position, {\r\n-        duration: 0.25,\r\n-        x: positionLifted.x,\r\n-        y: positionLifted.y,\r\n-        z: positionLifted.z,\r\n-        ease: 'power3.out',\r\n-      });\r\n-    }\r\n-    popupCloseTl.pause(0);\r\n-    popupOpenTl.play(0);\r\n-  };\r\n-\r\n-  const updateOverlayGraphic = () => {\r\n-    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n-    let activePointPosition = pointer.position.clone();\r\n-    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-    const activePointPositionProjected = activePointPosition.clone();\r\n-    activePointPositionProjected.project(camera);\r\n-    const coordinates2D = [\r\n-      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-    ];\r\n-\r\n-    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-    if (activePointPosition.z > -1) {\r\n-      if (!popupVisible) {\r\n-        setPopupVisible(true);\r\n-        showPopupAnimation(false);\r\n-      }\r\n-\r\n-      let popupX = coordinates2D[0];\r\n-      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-      let popupY = coordinates2D[1];\r\n-      const upDown = activePointPositionProjected.y > 0.6;\r\n-      popupY += upDown ? 20 : -20;\r\n-\r\n-      gsap.set(popupRef.current, {\r\n-        x: popupX,\r\n-        y: popupY,\r\n-        xPercent: -35,\r\n-        yPercent: upDown ? 0 : -100,\r\n-      });\r\n-\r\n-      popupY += upDown ? -5 : 5;\r\n-      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-    } else {\r\n-      if (popupVisible) {\r\n-        popupOpenTl.pause(0);\r\n-        popupCloseTl.play(0);\r\n-      }\r\n-      setPopupVisible(false);\r\n-    }\r\n-  };\r\n-\r\n-  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-    ctx.strokeStyle = '#000000';\r\n-    ctx.lineWidth = 3;\r\n-    ctx.lineCap = 'round';\r\n-    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-    ctx.beginPath();\r\n-    ctx.moveTo(startX, startY);\r\n-    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-    ctx.stroke();\r\n-  };\r\n-\r\n-  return (\r\n-    <div className='page'>\r\n-      <div className='title'>Click to add a pointer</div>\r\n-      <div className='globe-wrapper' ref={containerRef}>\r\n-        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n-        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n-        <div id='globe-popup-overlay'>\r\n-          <div className='globe-popup' ref={popupRef}></div>\r\n-        </div>\r\n-      </div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default Globe;\r\n-import React, { useEffect, useRef, useState } from 'react';\r\n-import * as THREE from 'three';\r\n-import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n-import { gsap } from 'gsap';\r\n-import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// Vertex shader\r\n-const vertexShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-    uniform float u_dot_size;\r\n-    uniform float u_time_since_click;\r\n-    uniform vec3 u_pointer;\r\n-\r\n-    #define PI 3.14159265359\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vUv = uv;\r\n-\r\n-        // mask with world map\r\n-        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-        gl_PointSize = visibility * u_dot_size;\r\n-\r\n-        // make back dots semi-transparent\r\n-        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-        vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-        // add ripple\r\n-        float t = u_time_since_click - .1;\r\n-        t = max(0., t);\r\n-        float max_amp = .15;\r\n-        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-        delta *= 1. - smoothstep(.8, 1., dist);\r\n-        vec3 pos = position;\r\n-        pos *= (1. + delta);\r\n-\r\n-        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-    }\r\n-`;\r\n-\r\n-// Fragment shader\r\n-const fragmentShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n-        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-        if (dot < 0.5) discard;\r\n-        gl_FragColor = vec4(color, dot * vOpacity);\r\n-    }\r\n-`;\r\n-\r\n-const Globe = () => {\r\n-  const containerRef = useRef(null);\r\n-  const canvas3DRef = useRef(null);\r\n-  const canvas2DRef = useRef(null);\r\n-  const popupRef = useRef(null);\r\n-\r\n-  const [renderer, setRenderer] = useState(null);\r\n-  const [scene, setScene] = useState(new THREE.Scene());\r\n-  const [camera, setCamera] = useState(null);\r\n-  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n-  const [controls, setControls] = useState(null);\r\n-  const [pointer, setPointer] = useState(null);\r\n-  const [globe, setGlobe] = useState(null);\r\n-  const [globeMesh, setGlobeMesh] = useState(null);\r\n-  const [mapMaterial, setMapMaterial] = useState(null);\r\n-  const [popupVisible, setPopupVisible] = useState(false);\r\n-  const [pointerPos, setPointerPos] = useState(null);\r\n-  const [clock, setClock] = useState(new THREE.Clock());\r\n-  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-  const [dragged, setDragged] = useState(false);\r\n-  const [earthTexture, setEarthTexture] = useState(null);\r\n-  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-  useEffect(() => {\r\n-    initScene();\r\n-    window.addEventListener('resize', updateSize);\r\n-    return () => {\r\n-      window.removeEventListener('resize', updateSize);\r\n-    };\r\n-  }, []);\r\n-\r\n-  useEffect(() => {\r\n-    if (renderer && scene && camera) {\r\n-      updateSize();\r\n-      render();\r\n-    }\r\n-  }, [renderer, scene, camera]);\r\n-\r\n-  const initScene = () => {\r\n-    const renderer = new THREE.WebGLRenderer({\r\n-      canvas: canvas3DRef.current,\r\n-      alpha: true,\r\n-    });\r\n-    renderer.setPixelRatio(window.devicePixelRatio);\r\n-    setRenderer(renderer);\r\n-  \r\n-    const camera = new THREE.OrthographicCamera(\r\n-      -1.1,\r\n-      1.1,\r\n-      1.1,\r\n-      -1.1,\r\n-      0,\r\n-      3\r\n-    );\r\n-    camera.position.z = 1.1;\r\n-    setCamera(camera);\r\n-  \r\n-    new THREE.TextureLoader().load(\r\n-      'https://ksenia-k.com/img/earth-map-colored.png',\r\n-      (mapTex) => {\r\n-        setEarthTexture(mapTex);\r\n-        mapTex.repeat.set(1, 1);\r\n-        createGlobe(mapTex);\r\n-        createPointer(); // Ensure this is called before createPopupTimelines\r\n-        createPopupTimelines(); // This should be called after createPointer\r\n-        addCanvasEvents();\r\n-      }\r\n-    );\r\n-  \r\n-    createOrbitControls(camera, renderer.domElement); // Call this after renderer is set up\r\n-  };\r\n-  \r\n-\r\n-\r\n   const createOrbitControls = (camera, canvas) => {\r\n     const controls = new OrbitControls(camera, canvas);\r\n     controls.enablePan = false;\r\n     controls.enableZoom = false;\r\n"
                },
                {
                    "date": 1708584101519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,46 +98,63 @@\n     }\r\n   }, [renderer, scene, camera]);\r\n \r\n   const initScene = () => {\r\n-    // Renderer, scene, and camera setup\r\n-\r\n+    const renderer = new THREE.WebGLRenderer({\r\n+      canvas: canvas3DRef.current,\r\n+      alpha: true,\r\n+    });\r\n+    renderer.setPixelRatio(window.devicePixelRatio);\r\n+    setRenderer(renderer);\r\n+  \r\n+    const camera = new THREE.OrthographicCamera(\r\n+      -1.1,\r\n+      1.1,\r\n+      1.1,\r\n+      -1.1,\r\n+      0,\r\n+      3\r\n+    );\r\n+    camera.position.z = 1.1;\r\n+    setCamera(camera);\r\n+  \r\n+    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n+  \r\n     new THREE.TextureLoader().load(\r\n       'https://ksenia-k.com/img/earth-map-colored.png',\r\n       (mapTex) => {\r\n         setEarthTexture(mapTex);\r\n         mapTex.repeat.set(1, 1);\r\n         createGlobe(mapTex);\r\n-        createPointer(); // Ensure this is called before createPopupTimelines\r\n-        createPopupTimelines(); // This should be called after createPointer\r\n+        createPointer();\r\n+        createPopupTimelines();\r\n         addCanvasEvents();\r\n       }\r\n     );\r\n-\r\n-    createOrbitControls(camera, renderer.domElement); // Call this after renderer is set up\r\n   };\r\n   \r\n+  \r\n \r\n \r\n-  const createOrbitControls = (camera, canvas) => {\r\n-    const controls = new OrbitControls(camera, canvas);\r\n-    controls.enablePan = false;\r\n-    controls.enableZoom = false;\r\n-    controls.enableDamping = true;\r\n-    controls.minPolarAngle = 0.4 * Math.PI;\r\n-    controls.maxPolarAngle = 0.4 * Math.PI;\r\n-    controls.autoRotate = true;\r\n+//   const createOrbitControls = (camera, canvas) => {\r\n+//     const controls = new OrbitControls(camera, canvas);\r\n+//     controls.enablePan = false;\r\n+//     controls.enableZoom = false;\r\n+//     controls.enableDamping = true;\r\n+//     controls.minPolarAngle = 0.4 * Math.PI;\r\n+//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n+//     controls.autoRotate = true;\r\n \r\n-    let timestamp;\r\n-    controls.addEventListener('start', () => {\r\n-      timestamp = Date.now();\r\n-    });\r\n-    controls.addEventListener('end', () => {\r\n-      setDragged(Date.now() - timestamp > 600);\r\n-    });\r\n+//     let timestamp;\r\n+//     controls.addEventListener('start', () => {\r\n+//       timestamp = Date.now();\r\n+//     });\r\n+//     controls.addEventListener('end', () => {\r\n+//       setDragged(Date.now() - timestamp > 600);\r\n+//     });\r\n \r\n-    setControls(controls);\r\n-  };\r\n+//     setControls(controls);\r\n+//   };\r\n \r\n   const createGlobe = (earthTexture) => {\r\n     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n     const mapMaterial = new THREE.ShaderMaterial({\r\n"
                },
                {
                    "date": 1708584111966,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,412 @@\n+import React, { useEffect, useRef, useState } from 'react';\r\n+import * as THREE from 'three';\r\n+import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+import { gsap } from 'gsap';\r\n+import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// Vertex shader\r\n+const vertexShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+    uniform float u_dot_size;\r\n+    uniform float u_time_since_click;\r\n+    uniform vec3 u_pointer;\r\n+\r\n+    #define PI 3.14159265359\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vUv = uv;\r\n+\r\n+        // mask with world map\r\n+        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+        gl_PointSize = visibility * u_dot_size;\r\n+\r\n+        // make back dots semi-transparent\r\n+        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+        vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+        // add ripple\r\n+        float t = u_time_since_click - .1;\r\n+        t = max(0., t);\r\n+        float max_amp = .15;\r\n+        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+        delta *= 1. - smoothstep(.8, 1., dist);\r\n+        vec3 pos = position;\r\n+        pos *= (1. + delta);\r\n+\r\n+        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+    }\r\n+`;\r\n+\r\n+// Fragment shader\r\n+const fragmentShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+        if (dot < 0.5) discard;\r\n+        gl_FragColor = vec4(color, dot * vOpacity);\r\n+    }\r\n+`;\r\n+\r\n+const Globe = () => {\r\n+  const containerRef = useRef(null);\r\n+  const canvas3DRef = useRef(null);\r\n+  const canvas2DRef = useRef(null);\r\n+  const popupRef = useRef(null);\r\n+\r\n+  const [renderer, setRenderer] = useState(null);\r\n+  const [scene, setScene] = useState(new THREE.Scene());\r\n+  const [camera, setCamera] = useState(null);\r\n+  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+  const [controls, setControls] = useState(null);\r\n+  const [pointer, setPointer] = useState(null);\r\n+  const [globe, setGlobe] = useState(null);\r\n+  const [globeMesh, setGlobeMesh] = useState(null);\r\n+  const [mapMaterial, setMapMaterial] = useState(null);\r\n+  const [popupVisible, setPopupVisible] = useState(false);\r\n+  const [pointerPos, setPointerPos] = useState(null);\r\n+  const [clock, setClock] = useState(new THREE.Clock());\r\n+  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+  const [dragged, setDragged] = useState(false);\r\n+  const [earthTexture, setEarthTexture] = useState(null);\r\n+  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+  useEffect(() => {\r\n+    initScene();\r\n+    window.addEventListener('resize', updateSize);\r\n+    return () => {\r\n+      window.removeEventListener('resize', updateSize);\r\n+    };\r\n+  }, []);\r\n+\r\n+  useEffect(() => {\r\n+    if (renderer && scene && camera) {\r\n+      updateSize();\r\n+      render();\r\n+    }\r\n+  }, [renderer, scene, camera]);\r\n+\r\n+  const initScene = () => {\r\n+    const renderer = new THREE.WebGLRenderer({\r\n+      canvas: canvas3DRef.current,\r\n+      alpha: true,\r\n+    });\r\n+    renderer.setPixelRatio(window.devicePixelRatio);\r\n+    setRenderer(renderer);\r\n+  \r\n+    const camera = new THREE.OrthographicCamera(\r\n+      -1.1,\r\n+      1.1,\r\n+      1.1,\r\n+      -1.1,\r\n+      0,\r\n+      3\r\n+    );\r\n+    camera.position.z = 1.1;\r\n+    setCamera(camera);\r\n+  \r\n+    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n+  \r\n+    new THREE.TextureLoader().load(\r\n+      'https://ksenia-k.com/img/earth-map-colored.png',\r\n+      (mapTex) => {\r\n+        setEarthTexture(mapTex);\r\n+        mapTex.repeat.set(1, 1);\r\n+        createGlobe(mapTex);\r\n+        createPointer();\r\n+        createPopupTimelines();\r\n+        addCanvasEvents();\r\n+      }\r\n+    );\r\n+  };\r\n+  \r\n+  \r\n+\r\n+\r\n+  const createOrbitControls = (camera, canvas) => {\r\n+    const controls = new OrbitControls(camera, canvas);\r\n+    controls.enablePan = false;\r\n+    controls.enableZoom = false;\r\n+    controls.enableDamping = true;\r\n+    controls.minPolarAngle = 0.4 * Math.PI;\r\n+    controls.maxPolarAngle = 0.4 * Math.PI;\r\n+    controls.autoRotate = true;\r\n+\r\n+    let timestamp;\r\n+    controls.addEventListener('start', () => {\r\n+      timestamp = Date.now();\r\n+    });\r\n+    controls.addEventListener('end', () => {\r\n+      setDragged(Date.now() - timestamp > 600);\r\n+    });\r\n+\r\n+    setControls(controls);\r\n+  };\r\n+\r\n+  const createGlobe = (earthTexture) => {\r\n+    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+    const mapMaterial = new THREE.ShaderMaterial({\r\n+      vertexShader: vertexShader,\r\n+      fragmentShader: fragmentShader,\r\n+      uniforms: {\r\n+        u_map_tex: { type: 't', value: earthTexture },\r\n+        u_dot_size: { type: 'f', value: 0 },\r\n+        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+        u_time_since_click: { value: 0 },\r\n+      },\r\n+      alphaTest: false,\r\n+      transparent: true,\r\n+    });\r\n+    setMapMaterial(mapMaterial);\r\n+\r\n+    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+    scene.add(globe);\r\n+    setGlobe(globe);\r\n+\r\n+    const globeMesh = new THREE.Mesh(\r\n+      globeGeometry,\r\n+      new THREE.MeshBasicMaterial({\r\n+        color: 0x222222,\r\n+        transparent: true,\r\n+        opacity: 0.05,\r\n+      })\r\n+    );\r\n+    scene.add(globeMesh);\r\n+    setGlobeMesh(globeMesh);\r\n+  };\r\n+\r\n+  const createPointer = () => {\r\n+    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+    const material = new THREE.MeshBasicMaterial({\r\n+      color: 0x000000,\r\n+      transparent: true,\r\n+      opacity: 0,\r\n+    });\r\n+    const pointer = new THREE.Mesh(geometry, material);\r\n+    scene.add(pointer);\r\n+    setPointer(pointer);\r\n+  };\r\n+\r\n+  const addCanvasEvents = () => {\r\n+    containerRef.current.addEventListener('mousemove', (e) => {\r\n+      updateMousePosition(e.clientX, e.clientY);\r\n+    });\r\n+\r\n+    containerRef.current.addEventListener('click', (e) => {\r\n+      if (!dragged) {\r\n+        updateMousePosition(\r\n+          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+        );\r\n+\r\n+        const res = checkIntersects();\r\n+        if (res.length) {\r\n+          const newPointerPos = res[0].face.normal.clone();\r\n+          setPointerPos(newPointerPos);\r\n+          pointer.position.set(\r\n+            newPointerPos.x,\r\n+            newPointerPos.y,\r\n+            newPointerPos.z\r\n+          );\r\n+          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+          showPopupAnimation(true);\r\n+          clock.start();\r\n+        }\r\n+      }\r\n+    });\r\n+  };\r\n+\r\n+  const updateMousePosition = (eX, eY) => {\r\n+    const rect = containerRef.current.getBoundingClientRect();\r\n+    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+  };\r\n+\r\n+  const checkIntersects = () => {\r\n+    if (!globeMesh) return [];\r\n+    rayCaster.setFromCamera(mouse, camera);\r\n+    const intersects = rayCaster.intersectObject(globeMesh);\r\n+    if (intersects.length) {\r\n+      document.body.style.cursor = 'pointer';\r\n+    } else {\r\n+      document.body.style.cursor = 'auto';\r\n+    }\r\n+    return intersects;\r\n+  };\r\n+\r\n+  const render = () => {\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+    }\r\n+    checkIntersects();\r\n+    if (pointer) {\r\n+      updateOverlayGraphic();\r\n+    }\r\n+    controls.update();\r\n+    renderer.render(scene, camera);\r\n+    requestAnimationFrame(render);\r\n+  };\r\n+\r\n+  const updateSize = () => {\r\n+    if (!renderer) return;\r\n+    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+    containerRef.current.style.width = `${minSide}px`;\r\n+    containerRef.current.style.height = `${minSide}px`;\r\n+    renderer.setSize(minSide, minSide);\r\n+    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+    }\r\n+  };\r\n+\r\n+  const cartesianToLatLong = (pos) => {\r\n+    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+      lng,\r\n+      'E',\r\n+      'W'\r\n+    )}`;\r\n+  };\r\n+\r\n+  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+  };\r\n+\r\n+  const createPopupTimelines = () => {\r\n+    const popupOpenTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, {\r\n+        duration: 0.2,\r\n+        opacity: 1,\r\n+      }, 0)\r\n+      .fromTo(\r\n+        canvas2DRef.current,\r\n+        { opacity: 0 },\r\n+        { duration: 0.3, opacity: 1 },\r\n+        0.15\r\n+      )\r\n+      .fromTo(\r\n+        popupRef.current,\r\n+        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+        { duration: 0.1, opacity: 1, scale: 1 },\r\n+        0.25\r\n+      );\r\n+    setPopupOpenTl(popupOpenTl);\r\n+\r\n+    const popupCloseTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+      .to(popupRef.current, {\r\n+        duration: 0.3,\r\n+        opacity: 0,\r\n+        scale: 0.9,\r\n+        transformOrigin: 'center bottom',\r\n+      }, 0);\r\n+    setPopupCloseTl(popupCloseTl);\r\n+  };\r\n+\r\n+  const showPopupAnimation = (lifted) => {\r\n+    if (lifted) {\r\n+      let positionLifted = pointer.position.clone();\r\n+      positionLifted.multiplyScalar(1.3);\r\n+      gsap.from(pointer.position, {\r\n+        duration: 0.25,\r\n+        x: positionLifted.x,\r\n+        y: positionLifted.y,\r\n+        z: positionLifted.z,\r\n+        ease: 'power3.out',\r\n+      });\r\n+    }\r\n+    popupCloseTl.pause(0);\r\n+    popupOpenTl.play(0);\r\n+  };\r\n+\r\n+  const updateOverlayGraphic = () => {\r\n+    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+    let activePointPosition = pointer.position.clone();\r\n+    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+    const activePointPositionProjected = activePointPosition.clone();\r\n+    activePointPositionProjected.project(camera);\r\n+    const coordinates2D = [\r\n+      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+    ];\r\n+\r\n+    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+    if (activePointPosition.z > -1) {\r\n+      if (!popupVisible) {\r\n+        setPopupVisible(true);\r\n+        showPopupAnimation(false);\r\n+      }\r\n+\r\n+      let popupX = coordinates2D[0];\r\n+      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+      let popupY = coordinates2D[1];\r\n+      const upDown = activePointPositionProjected.y > 0.6;\r\n+      popupY += upDown ? 20 : -20;\r\n+\r\n+      gsap.set(popupRef.current, {\r\n+        x: popupX,\r\n+        y: popupY,\r\n+        xPercent: -35,\r\n+        yPercent: upDown ? 0 : -100,\r\n+      });\r\n+\r\n+      popupY += upDown ? -5 : 5;\r\n+      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+    } else {\r\n+      if (popupVisible) {\r\n+        popupOpenTl.pause(0);\r\n+        popupCloseTl.play(0);\r\n+      }\r\n+      setPopupVisible(false);\r\n+    }\r\n+  };\r\n+\r\n+  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+    ctx.strokeStyle = '#000000';\r\n+    ctx.lineWidth = 3;\r\n+    ctx.lineCap = 'round';\r\n+    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+    ctx.beginPath();\r\n+    ctx.moveTo(startX, startY);\r\n+    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+    ctx.stroke();\r\n+  };\r\n+\r\n+  return (\r\n+    <div className='page'>\r\n+      <div className='title'>Click to add a pointer</div>\r\n+      <div className='globe-wrapper' ref={containerRef}>\r\n+        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+        <div id='globe-popup-overlay'>\r\n+          <div className='globe-popup' ref={popupRef}></div>\r\n+        </div>\r\n+      </div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n"
                },
                {
                    "date": 1708584325340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -177,9 +177,9 @@\n \r\n     const globeMesh = new THREE.Mesh(\r\n       globeGeometry,\r\n       new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n+        color: white,\r\n         transparent: true,\r\n         opacity: 0.05,\r\n       })\r\n     );\r\n@@ -409,416 +409,4 @@\n   );\r\n };\r\n \r\n export default Globe;\r\n-import React, { useEffect, useRef, useState } from 'react';\r\n-import * as THREE from 'three';\r\n-import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n-import { gsap } from 'gsap';\r\n-import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// Vertex shader\r\n-const vertexShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-    uniform float u_dot_size;\r\n-    uniform float u_time_since_click;\r\n-    uniform vec3 u_pointer;\r\n-\r\n-    #define PI 3.14159265359\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vUv = uv;\r\n-\r\n-        // mask with world map\r\n-        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-        gl_PointSize = visibility * u_dot_size;\r\n-\r\n-        // make back dots semi-transparent\r\n-        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-        vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-        // add ripple\r\n-        float t = u_time_since_click - .1;\r\n-        t = max(0., t);\r\n-        float max_amp = .15;\r\n-        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-        delta *= 1. - smoothstep(.8, 1., dist);\r\n-        vec3 pos = position;\r\n-        pos *= (1. + delta);\r\n-\r\n-        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-    }\r\n-`;\r\n-\r\n-// Fragment shader\r\n-const fragmentShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n-        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-        if (dot < 0.5) discard;\r\n-        gl_FragColor = vec4(color, dot * vOpacity);\r\n-    }\r\n-`;\r\n-\r\n-const Globe = () => {\r\n-  const containerRef = useRef(null);\r\n-  const canvas3DRef = useRef(null);\r\n-  const canvas2DRef = useRef(null);\r\n-  const popupRef = useRef(null);\r\n-\r\n-  const [renderer, setRenderer] = useState(null);\r\n-  const [scene, setScene] = useState(new THREE.Scene());\r\n-  const [camera, setCamera] = useState(null);\r\n-  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n-  const [controls, setControls] = useState(null);\r\n-  const [pointer, setPointer] = useState(null);\r\n-  const [globe, setGlobe] = useState(null);\r\n-  const [globeMesh, setGlobeMesh] = useState(null);\r\n-  const [mapMaterial, setMapMaterial] = useState(null);\r\n-  const [popupVisible, setPopupVisible] = useState(false);\r\n-  const [pointerPos, setPointerPos] = useState(null);\r\n-  const [clock, setClock] = useState(new THREE.Clock());\r\n-  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-  const [dragged, setDragged] = useState(false);\r\n-  const [earthTexture, setEarthTexture] = useState(null);\r\n-  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-  useEffect(() => {\r\n-    initScene();\r\n-    window.addEventListener('resize', updateSize);\r\n-    return () => {\r\n-      window.removeEventListener('resize', updateSize);\r\n-    };\r\n-  }, []);\r\n-\r\n-  useEffect(() => {\r\n-    if (renderer && scene && camera) {\r\n-      updateSize();\r\n-      render();\r\n-    }\r\n-  }, [renderer, scene, camera]);\r\n-\r\n-  const initScene = () => {\r\n-    const renderer = new THREE.WebGLRenderer({\r\n-      canvas: canvas3DRef.current,\r\n-      alpha: true,\r\n-    });\r\n-    renderer.setPixelRatio(window.devicePixelRatio);\r\n-    setRenderer(renderer);\r\n-  \r\n-    const camera = new THREE.OrthographicCamera(\r\n-      -1.1,\r\n-      1.1,\r\n-      1.1,\r\n-      -1.1,\r\n-      0,\r\n-      3\r\n-    );\r\n-    camera.position.z = 1.1;\r\n-    setCamera(camera);\r\n-  \r\n-    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n-  \r\n-    new THREE.TextureLoader().load(\r\n-      'https://ksenia-k.com/img/earth-map-colored.png',\r\n-      (mapTex) => {\r\n-        setEarthTexture(mapTex);\r\n-        mapTex.repeat.set(1, 1);\r\n-        createGlobe(mapTex);\r\n-        createPointer();\r\n-        createPopupTimelines();\r\n-        addCanvasEvents();\r\n-      }\r\n-    );\r\n-  };\r\n-  \r\n-  \r\n-\r\n-\r\n-//   const createOrbitControls = (camera, canvas) => {\r\n-//     const controls = new OrbitControls(camera, canvas);\r\n-//     controls.enablePan = false;\r\n-//     controls.enableZoom = false;\r\n-//     controls.enableDamping = true;\r\n-//     controls.minPolarAngle = 0.4 * Math.PI;\r\n-//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n-//     controls.autoRotate = true;\r\n-\r\n-//     let timestamp;\r\n-//     controls.addEventListener('start', () => {\r\n-//       timestamp = Date.now();\r\n-//     });\r\n-//     controls.addEventListener('end', () => {\r\n-//       setDragged(Date.now() - timestamp > 600);\r\n-//     });\r\n-\r\n-//     setControls(controls);\r\n-//   };\r\n-\r\n-  const createGlobe = (earthTexture) => {\r\n-    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-    const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: vertexShader,\r\n-      fragmentShader: fragmentShader,\r\n-      uniforms: {\r\n-        u_map_tex: { type: 't', value: earthTexture },\r\n-        u_dot_size: { type: 'f', value: 0 },\r\n-        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n-        u_time_since_click: { value: 0 },\r\n-      },\r\n-      alphaTest: false,\r\n-      transparent: true,\r\n-    });\r\n-    setMapMaterial(mapMaterial);\r\n-\r\n-    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-    scene.add(globe);\r\n-    setGlobe(globe);\r\n-\r\n-    const globeMesh = new THREE.Mesh(\r\n-      globeGeometry,\r\n-      new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n-        transparent: true,\r\n-        opacity: 0.05,\r\n-      })\r\n-    );\r\n-    scene.add(globeMesh);\r\n-    setGlobeMesh(globeMesh);\r\n-  };\r\n-\r\n-  const createPointer = () => {\r\n-    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-    const material = new THREE.MeshBasicMaterial({\r\n-      color: 0x000000,\r\n-      transparent: true,\r\n-      opacity: 0,\r\n-    });\r\n-    const pointer = new THREE.Mesh(geometry, material);\r\n-    scene.add(pointer);\r\n-    setPointer(pointer);\r\n-  };\r\n-\r\n-  const addCanvasEvents = () => {\r\n-    containerRef.current.addEventListener('mousemove', (e) => {\r\n-      updateMousePosition(e.clientX, e.clientY);\r\n-    });\r\n-\r\n-    containerRef.current.addEventListener('click', (e) => {\r\n-      if (!dragged) {\r\n-        updateMousePosition(\r\n-          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-        );\r\n-\r\n-        const res = checkIntersects();\r\n-        if (res.length) {\r\n-          const newPointerPos = res[0].face.normal.clone();\r\n-          setPointerPos(newPointerPos);\r\n-          pointer.position.set(\r\n-            newPointerPos.x,\r\n-            newPointerPos.y,\r\n-            newPointerPos.z\r\n-          );\r\n-          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-          showPopupAnimation(true);\r\n-          clock.start();\r\n-        }\r\n-      }\r\n-    });\r\n-  };\r\n-\r\n-  const updateMousePosition = (eX, eY) => {\r\n-    const rect = containerRef.current.getBoundingClientRect();\r\n-    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-  };\r\n-\r\n-  const checkIntersects = () => {\r\n-    if (!globeMesh) return [];\r\n-    rayCaster.setFromCamera(mouse, camera);\r\n-    const intersects = rayCaster.intersectObject(globeMesh);\r\n-    if (intersects.length) {\r\n-      document.body.style.cursor = 'pointer';\r\n-    } else {\r\n-      document.body.style.cursor = 'auto';\r\n-    }\r\n-    return intersects;\r\n-  };\r\n-\r\n-  const render = () => {\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-    }\r\n-    checkIntersects();\r\n-    if (pointer) {\r\n-      updateOverlayGraphic();\r\n-    }\r\n-    controls.update();\r\n-    renderer.render(scene, camera);\r\n-    requestAnimationFrame(render);\r\n-  };\r\n-\r\n-  const updateSize = () => {\r\n-    if (!renderer) return;\r\n-    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-    containerRef.current.style.width = `${minSide}px`;\r\n-    containerRef.current.style.height = `${minSide}px`;\r\n-    renderer.setSize(minSide, minSide);\r\n-    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-    }\r\n-  };\r\n-\r\n-  const cartesianToLatLong = (pos) => {\r\n-    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n-      lng,\r\n-      'E',\r\n-      'W'\r\n-    )}`;\r\n-  };\r\n-\r\n-  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-  };\r\n-\r\n-  const createPopupTimelines = () => {\r\n-    const popupOpenTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, {\r\n-        duration: 0.2,\r\n-        opacity: 1,\r\n-      }, 0)\r\n-      .fromTo(\r\n-        canvas2DRef.current,\r\n-        { opacity: 0 },\r\n-        { duration: 0.3, opacity: 1 },\r\n-        0.15\r\n-      )\r\n-      .fromTo(\r\n-        popupRef.current,\r\n-        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n-        { duration: 0.1, opacity: 1, scale: 1 },\r\n-        0.25\r\n-      );\r\n-    setPopupOpenTl(popupOpenTl);\r\n-\r\n-    const popupCloseTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-      .to(popupRef.current, {\r\n-        duration: 0.3,\r\n-        opacity: 0,\r\n-        scale: 0.9,\r\n-        transformOrigin: 'center bottom',\r\n-      }, 0);\r\n-    setPopupCloseTl(popupCloseTl);\r\n-  };\r\n-\r\n-  const showPopupAnimation = (lifted) => {\r\n-    if (lifted) {\r\n-      let positionLifted = pointer.position.clone();\r\n-      positionLifted.multiplyScalar(1.3);\r\n-      gsap.from(pointer.position, {\r\n-        duration: 0.25,\r\n-        x: positionLifted.x,\r\n-        y: positionLifted.y,\r\n-        z: positionLifted.z,\r\n-        ease: 'power3.out',\r\n-      });\r\n-    }\r\n-    popupCloseTl.pause(0);\r\n-    popupOpenTl.play(0);\r\n-  };\r\n-\r\n-  const updateOverlayGraphic = () => {\r\n-    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n-    let activePointPosition = pointer.position.clone();\r\n-    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-    const activePointPositionProjected = activePointPosition.clone();\r\n-    activePointPositionProjected.project(camera);\r\n-    const coordinates2D = [\r\n-      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-    ];\r\n-\r\n-    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-    if (activePointPosition.z > -1) {\r\n-      if (!popupVisible) {\r\n-        setPopupVisible(true);\r\n-        showPopupAnimation(false);\r\n-      }\r\n-\r\n-      let popupX = coordinates2D[0];\r\n-      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-      let popupY = coordinates2D[1];\r\n-      const upDown = activePointPositionProjected.y > 0.6;\r\n-      popupY += upDown ? 20 : -20;\r\n-\r\n-      gsap.set(popupRef.current, {\r\n-        x: popupX,\r\n-        y: popupY,\r\n-        xPercent: -35,\r\n-        yPercent: upDown ? 0 : -100,\r\n-      });\r\n-\r\n-      popupY += upDown ? -5 : 5;\r\n-      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-    } else {\r\n-      if (popupVisible) {\r\n-        popupOpenTl.pause(0);\r\n-        popupCloseTl.play(0);\r\n-      }\r\n-      setPopupVisible(false);\r\n-    }\r\n-  };\r\n-\r\n-  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-    ctx.strokeStyle = '#000000';\r\n-    ctx.lineWidth = 3;\r\n-    ctx.lineCap = 'round';\r\n-    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-    ctx.beginPath();\r\n-    ctx.moveTo(startX, startY);\r\n-    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-    ctx.stroke();\r\n-  };\r\n-\r\n-  return (\r\n-    <div className='page'>\r\n-      <div className='title'>Click to add a pointer</div>\r\n-      <div className='globe-wrapper' ref={containerRef}>\r\n-        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n-        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n-        <div id='globe-popup-overlay'>\r\n-          <div className='globe-popup' ref={popupRef}></div>\r\n-        </div>\r\n-      </div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default Globe;\r\n"
                },
                {
                    "date": 1708584438769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -178,9 +178,9 @@\n     const globeMesh = new THREE.Mesh(\r\n       globeGeometry,\r\n       new THREE.MeshBasicMaterial({\r\n         color: white,\r\n-        transparent: true,\r\n+        transparent: false,\r\n         opacity: 0.05,\r\n       })\r\n     );\r\n     scene.add(globeMesh);\r\n"
                },
                {
                    "date": 1708584445071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -177,10 +177,10 @@\n \r\n     const globeMesh = new THREE.Mesh(\r\n       globeGeometry,\r\n       new THREE.MeshBasicMaterial({\r\n-        color: white,\r\n-        transparent: false,\r\n+        color: 0x222222,\r\n+        transparent: true,\r\n         opacity: 0.05,\r\n       })\r\n     );\r\n     scene.add(globeMesh);\r\n"
                },
                {
                    "date": 1708584467909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -396,9 +396,9 @@\n   };\r\n \r\n   return (\r\n     <div className='page'>\r\n-      <div className='title'>Click to add a pointer</div>\r\n+      {/* <div className='title'>Click to add a pointer</div> */}\r\n       <div className='globe-wrapper' ref={containerRef}>\r\n         <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n         <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n         <div id='globe-popup-overlay'>\r\n"
                },
                {
                    "date": 1708584486004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n     varying float vOpacity;\r\n     varying vec2 vUv;\r\n \r\n     void main() {\r\n-        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+        vec3 color = white;\r\n         color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n         float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n         if (dot < 0.5) discard;\r\n         gl_FragColor = vec4(color, dot * vOpacity);\r\n"
                },
                {
                    "date": 1708584500112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,412 @@\n+import React, { useEffect, useRef, useState } from 'react';\r\n+import * as THREE from 'three';\r\n+import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+import { gsap } from 'gsap';\r\n+import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// Vertex shader\r\n+const vertexShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+    uniform float u_dot_size;\r\n+    uniform float u_time_since_click;\r\n+    uniform vec3 u_pointer;\r\n+\r\n+    #define PI 3.14159265359\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vUv = uv;\r\n+\r\n+        // mask with world map\r\n+        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+        gl_PointSize = visibility * u_dot_size;\r\n+\r\n+        // make back dots semi-transparent\r\n+        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+        vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+        // add ripple\r\n+        float t = u_time_since_click - .1;\r\n+        t = max(0., t);\r\n+        float max_amp = .15;\r\n+        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+        delta *= 1. - smoothstep(.8, 1., dist);\r\n+        vec3 pos = position;\r\n+        pos *= (1. + delta);\r\n+\r\n+        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+    }\r\n+`;\r\n+\r\n+// Fragment shader\r\n+const fragmentShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+        if (dot < 0.5) discard;\r\n+        gl_FragColor = vec4(color, dot * vOpacity);\r\n+    }\r\n+`;\r\n+\r\n+const Globe = () => {\r\n+  const containerRef = useRef(null);\r\n+  const canvas3DRef = useRef(null);\r\n+  const canvas2DRef = useRef(null);\r\n+  const popupRef = useRef(null);\r\n+\r\n+  const [renderer, setRenderer] = useState(null);\r\n+  const [scene, setScene] = useState(new THREE.Scene());\r\n+  const [camera, setCamera] = useState(null);\r\n+  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+  const [controls, setControls] = useState(null);\r\n+  const [pointer, setPointer] = useState(null);\r\n+  const [globe, setGlobe] = useState(null);\r\n+  const [globeMesh, setGlobeMesh] = useState(null);\r\n+  const [mapMaterial, setMapMaterial] = useState(null);\r\n+  const [popupVisible, setPopupVisible] = useState(false);\r\n+  const [pointerPos, setPointerPos] = useState(null);\r\n+  const [clock, setClock] = useState(new THREE.Clock());\r\n+  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+  const [dragged, setDragged] = useState(false);\r\n+  const [earthTexture, setEarthTexture] = useState(null);\r\n+  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+  useEffect(() => {\r\n+    initScene();\r\n+    window.addEventListener('resize', updateSize);\r\n+    return () => {\r\n+      window.removeEventListener('resize', updateSize);\r\n+    };\r\n+  }, []);\r\n+\r\n+  useEffect(() => {\r\n+    if (renderer && scene && camera) {\r\n+      updateSize();\r\n+      render();\r\n+    }\r\n+  }, [renderer, scene, camera]);\r\n+\r\n+  const initScene = () => {\r\n+    const renderer = new THREE.WebGLRenderer({\r\n+      canvas: canvas3DRef.current,\r\n+      alpha: true,\r\n+    });\r\n+    renderer.setPixelRatio(window.devicePixelRatio);\r\n+    setRenderer(renderer);\r\n+  \r\n+    const camera = new THREE.OrthographicCamera(\r\n+      -1.1,\r\n+      1.1,\r\n+      1.1,\r\n+      -1.1,\r\n+      0,\r\n+      3\r\n+    );\r\n+    camera.position.z = 1.1;\r\n+    setCamera(camera);\r\n+  \r\n+    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n+  \r\n+    new THREE.TextureLoader().load(\r\n+      'https://ksenia-k.com/img/earth-map-colored.png',\r\n+      (mapTex) => {\r\n+        setEarthTexture(mapTex);\r\n+        mapTex.repeat.set(1, 1);\r\n+        createGlobe(mapTex);\r\n+        createPointer();\r\n+        createPopupTimelines();\r\n+        addCanvasEvents();\r\n+      }\r\n+    );\r\n+  };\r\n+  \r\n+  \r\n+\r\n+\r\n+  const createOrbitControls = (camera, canvas) => {\r\n+    const controls = new OrbitControls(camera, canvas);\r\n+    controls.enablePan = false;\r\n+    controls.enableZoom = false;\r\n+    controls.enableDamping = true;\r\n+    controls.minPolarAngle = 0.4 * Math.PI;\r\n+    controls.maxPolarAngle = 0.4 * Math.PI;\r\n+    controls.autoRotate = true;\r\n+\r\n+    let timestamp;\r\n+    controls.addEventListener('start', () => {\r\n+      timestamp = Date.now();\r\n+    });\r\n+    controls.addEventListener('end', () => {\r\n+      setDragged(Date.now() - timestamp > 600);\r\n+    });\r\n+\r\n+    setControls(controls);\r\n+  };\r\n+\r\n+  const createGlobe = (earthTexture) => {\r\n+    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+    const mapMaterial = new THREE.ShaderMaterial({\r\n+      vertexShader: vertexShader,\r\n+      fragmentShader: fragmentShader,\r\n+      uniforms: {\r\n+        u_map_tex: { type: 't', value: earthTexture },\r\n+        u_dot_size: { type: 'f', value: 0 },\r\n+        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+        u_time_since_click: { value: 0 },\r\n+      },\r\n+      alphaTest: false,\r\n+      transparent: true,\r\n+    });\r\n+    setMapMaterial(mapMaterial);\r\n+\r\n+    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+    scene.add(globe);\r\n+    setGlobe(globe);\r\n+\r\n+    const globeMesh = new THREE.Mesh(\r\n+      globeGeometry,\r\n+      new THREE.MeshBasicMaterial({\r\n+        color: 0x222222,\r\n+        transparent: true,\r\n+        opacity: 0.05,\r\n+      })\r\n+    );\r\n+    scene.add(globeMesh);\r\n+    setGlobeMesh(globeMesh);\r\n+  };\r\n+\r\n+  const createPointer = () => {\r\n+    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+    const material = new THREE.MeshBasicMaterial({\r\n+      color: 0x000000,\r\n+      transparent: true,\r\n+      opacity: 0,\r\n+    });\r\n+    const pointer = new THREE.Mesh(geometry, material);\r\n+    scene.add(pointer);\r\n+    setPointer(pointer);\r\n+  };\r\n+\r\n+  const addCanvasEvents = () => {\r\n+    containerRef.current.addEventListener('mousemove', (e) => {\r\n+      updateMousePosition(e.clientX, e.clientY);\r\n+    });\r\n+\r\n+    containerRef.current.addEventListener('click', (e) => {\r\n+      if (!dragged) {\r\n+        updateMousePosition(\r\n+          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+        );\r\n+\r\n+        const res = checkIntersects();\r\n+        if (res.length) {\r\n+          const newPointerPos = res[0].face.normal.clone();\r\n+          setPointerPos(newPointerPos);\r\n+          pointer.position.set(\r\n+            newPointerPos.x,\r\n+            newPointerPos.y,\r\n+            newPointerPos.z\r\n+          );\r\n+          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+          showPopupAnimation(true);\r\n+          clock.start();\r\n+        }\r\n+      }\r\n+    });\r\n+  };\r\n+\r\n+  const updateMousePosition = (eX, eY) => {\r\n+    const rect = containerRef.current.getBoundingClientRect();\r\n+    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+  };\r\n+\r\n+  const checkIntersects = () => {\r\n+    if (!globeMesh) return [];\r\n+    rayCaster.setFromCamera(mouse, camera);\r\n+    const intersects = rayCaster.intersectObject(globeMesh);\r\n+    if (intersects.length) {\r\n+      document.body.style.cursor = 'pointer';\r\n+    } else {\r\n+      document.body.style.cursor = 'auto';\r\n+    }\r\n+    return intersects;\r\n+  };\r\n+\r\n+  const render = () => {\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+    }\r\n+    checkIntersects();\r\n+    if (pointer) {\r\n+      updateOverlayGraphic();\r\n+    }\r\n+    controls.update();\r\n+    renderer.render(scene, camera);\r\n+    requestAnimationFrame(render);\r\n+  };\r\n+\r\n+  const updateSize = () => {\r\n+    if (!renderer) return;\r\n+    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+    containerRef.current.style.width = `${minSide}px`;\r\n+    containerRef.current.style.height = `${minSide}px`;\r\n+    renderer.setSize(minSide, minSide);\r\n+    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+    }\r\n+  };\r\n+\r\n+  const cartesianToLatLong = (pos) => {\r\n+    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+      lng,\r\n+      'E',\r\n+      'W'\r\n+    )}`;\r\n+  };\r\n+\r\n+  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+  };\r\n+\r\n+  const createPopupTimelines = () => {\r\n+    const popupOpenTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, {\r\n+        duration: 0.2,\r\n+        opacity: 1,\r\n+      }, 0)\r\n+      .fromTo(\r\n+        canvas2DRef.current,\r\n+        { opacity: 0 },\r\n+        { duration: 0.3, opacity: 1 },\r\n+        0.15\r\n+      )\r\n+      .fromTo(\r\n+        popupRef.current,\r\n+        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+        { duration: 0.1, opacity: 1, scale: 1 },\r\n+        0.25\r\n+      );\r\n+    setPopupOpenTl(popupOpenTl);\r\n+\r\n+    const popupCloseTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+      .to(popupRef.current, {\r\n+        duration: 0.3,\r\n+        opacity: 0,\r\n+        scale: 0.9,\r\n+        transformOrigin: 'center bottom',\r\n+      }, 0);\r\n+    setPopupCloseTl(popupCloseTl);\r\n+  };\r\n+\r\n+  const showPopupAnimation = (lifted) => {\r\n+    if (lifted) {\r\n+      let positionLifted = pointer.position.clone();\r\n+      positionLifted.multiplyScalar(1.3);\r\n+      gsap.from(pointer.position, {\r\n+        duration: 0.25,\r\n+        x: positionLifted.x,\r\n+        y: positionLifted.y,\r\n+        z: positionLifted.z,\r\n+        ease: 'power3.out',\r\n+      });\r\n+    }\r\n+    popupCloseTl.pause(0);\r\n+    popupOpenTl.play(0);\r\n+  };\r\n+\r\n+  const updateOverlayGraphic = () => {\r\n+    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+    let activePointPosition = pointer.position.clone();\r\n+    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+    const activePointPositionProjected = activePointPosition.clone();\r\n+    activePointPositionProjected.project(camera);\r\n+    const coordinates2D = [\r\n+      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+    ];\r\n+\r\n+    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+    if (activePointPosition.z > -1) {\r\n+      if (!popupVisible) {\r\n+        setPopupVisible(true);\r\n+        showPopupAnimation(false);\r\n+      }\r\n+\r\n+      let popupX = coordinates2D[0];\r\n+      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+      let popupY = coordinates2D[1];\r\n+      const upDown = activePointPositionProjected.y > 0.6;\r\n+      popupY += upDown ? 20 : -20;\r\n+\r\n+      gsap.set(popupRef.current, {\r\n+        x: popupX,\r\n+        y: popupY,\r\n+        xPercent: -35,\r\n+        yPercent: upDown ? 0 : -100,\r\n+      });\r\n+\r\n+      popupY += upDown ? -5 : 5;\r\n+      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+    } else {\r\n+      if (popupVisible) {\r\n+        popupOpenTl.pause(0);\r\n+        popupCloseTl.play(0);\r\n+      }\r\n+      setPopupVisible(false);\r\n+    }\r\n+  };\r\n+\r\n+  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+    ctx.strokeStyle = '#000000';\r\n+    ctx.lineWidth = 3;\r\n+    ctx.lineCap = 'round';\r\n+    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+    ctx.beginPath();\r\n+    ctx.moveTo(startX, startY);\r\n+    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+    ctx.stroke();\r\n+  };\r\n+\r\n+  return (\r\n+    <div className='page'>\r\n+      {/* <div className='title'>Click to add a pointer</div> */}\r\n+      <div className='globe-wrapper' ref={containerRef}>\r\n+        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+        <div id='globe-popup-overlay'>\r\n+          <div className='globe-popup' ref={popupRef}></div>\r\n+        </div>\r\n+      </div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n"
                },
                {
                    "date": 1708584655759,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,413 @@\n+import React, { useEffect, useRef, useState } from 'react';\r\n+import * as THREE from 'three';\r\n+import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+import { gsap } from 'gsap';\r\n+import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// Vertex shader\r\n+const vertexShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+    uniform float u_dot_size;\r\n+    uniform float u_time_since_click;\r\n+    uniform vec3 u_pointer;\r\n+\r\n+    #define PI 3.14159265359\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vUv = uv;\r\n+\r\n+        // mask with world map\r\n+        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+        gl_PointSize = visibility * u_dot_size;\r\n+\r\n+        // make back dots semi-transparent\r\n+        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+        vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+        // add ripple\r\n+        float t = u_time_since_click - .1;\r\n+        t = max(0., t);\r\n+        float max_amp = .15;\r\n+        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+        delta *= 1. - smoothstep(.8, 1., dist);\r\n+        vec3 pos = position;\r\n+        pos *= (1. + delta);\r\n+\r\n+        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+    }\r\n+`;\r\n+\r\n+// Fragment shader\r\n+const fragmentShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+        if (dot < 0.5) discard;\r\n+        gl_FragColor = vec4(color, dot * vOpacity);\r\n+    }\r\n+`;\r\n+\r\n+const Globe = () => {\r\n+  const containerRef = useRef(null);\r\n+  const canvas3DRef = useRef(null);\r\n+  const canvas2DRef = useRef(null);\r\n+  const popupRef = useRef(null);\r\n+\r\n+  const [renderer, setRenderer] = useState(null);\r\n+  const [scene, setScene] = useState(new THREE.Scene());\r\n+  const [camera, setCamera] = useState(null);\r\n+  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+  const [controls, setControls] = useState(null);\r\n+  const [pointer, setPointer] = useState(null);\r\n+  const [globe, setGlobe] = useState(null);\r\n+  const [globeMesh, setGlobeMesh] = useState(null);\r\n+  const [mapMaterial, setMapMaterial] = useState(null);\r\n+  const [popupVisible, setPopupVisible] = useState(false);\r\n+  const [pointerPos, setPointerPos] = useState(null);\r\n+  const [clock, setClock] = useState(new THREE.Clock());\r\n+  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+  const [dragged, setDragged] = useState(false);\r\n+  const [earthTexture, setEarthTexture] = useState(null);\r\n+  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+  useEffect(() => {\r\n+    initScene();\r\n+    window.addEventListener('resize', updateSize);\r\n+    return () => {\r\n+      window.removeEventListener('resize', updateSize);\r\n+    };\r\n+  }, []);\r\n+\r\n+  useEffect(() => {\r\n+    if (renderer && scene && camera) {\r\n+      updateSize();\r\n+      render();\r\n+    }\r\n+  }, [renderer, scene, camera]);\r\n+\r\n+  const initScene = () => {\r\n+    const renderer = new THREE.WebGLRenderer({\r\n+      canvas: canvas3DRef.current,\r\n+      alpha: true,\r\n+    });\r\n+    renderer.setPixelRatio(window.devicePixelRatio);\r\n+    setRenderer(renderer);\r\n+  \r\n+    const camera = new THREE.OrthographicCamera(\r\n+      -1.1,\r\n+      1.1,\r\n+      1.1,\r\n+      -1.1,\r\n+      0,\r\n+      3\r\n+    );\r\n+    camera.position.z = 1.1;\r\n+    setCamera(camera);\r\n+  \r\n+    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n+  \r\n+    new THREE.TextureLoader().load(\r\n+      'https://ksenia-k.com/img/earth-map-colored.png',\r\n+      (mapTex) => {\r\n+        setEarthTexture(mapTex);\r\n+        mapTex.repeat.set(1, 1);\r\n+        createGlobe(mapTex);\r\n+        createPointer(); // Ensure this is called before createPopupTimelines\r\n+        createPopupTimelines(); // This should be called after createPointer\r\n+        addCanvasEvents();\r\n+      }\r\n+    );\r\n+  };\r\n+  \r\n+  \r\n+  \r\n+\r\n+\r\n+  const createOrbitControls = (camera, canvas) => {\r\n+    const controls = new OrbitControls(camera, canvas);\r\n+    controls.enablePan = false;\r\n+    controls.enableZoom = false;\r\n+    controls.enableDamping = true;\r\n+    controls.minPolarAngle = 0.4 * Math.PI;\r\n+    controls.maxPolarAngle = 0.4 * Math.PI;\r\n+    controls.autoRotate = true;\r\n+\r\n+    let timestamp;\r\n+    controls.addEventListener('start', () => {\r\n+      timestamp = Date.now();\r\n+    });\r\n+    controls.addEventListener('end', () => {\r\n+      setDragged(Date.now() - timestamp > 600);\r\n+    });\r\n+\r\n+    setControls(controls);\r\n+  };\r\n+\r\n+  const createGlobe = (earthTexture) => {\r\n+    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+    const mapMaterial = new THREE.ShaderMaterial({\r\n+      vertexShader: vertexShader,\r\n+      fragmentShader: fragmentShader,\r\n+      uniforms: {\r\n+        u_map_tex: { type: 't', value: earthTexture },\r\n+        u_dot_size: { type: 'f', value: 0 },\r\n+        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+        u_time_since_click: { value: 0 },\r\n+      },\r\n+      alphaTest: false,\r\n+      transparent: true,\r\n+    });\r\n+    setMapMaterial(mapMaterial);\r\n+\r\n+    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+    scene.add(globe);\r\n+    setGlobe(globe);\r\n+\r\n+    const globeMesh = new THREE.Mesh(\r\n+      globeGeometry,\r\n+      new THREE.MeshBasicMaterial({\r\n+        color: 0x222222,\r\n+        transparent: true,\r\n+        opacity: 0.05,\r\n+      })\r\n+    );\r\n+    scene.add(globeMesh);\r\n+    setGlobeMesh(globeMesh);\r\n+  };\r\n+\r\n+  const createPointer = () => {\r\n+    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+    const material = new THREE.MeshBasicMaterial({\r\n+      color: 0x000000,\r\n+      transparent: true,\r\n+      opacity: 0,\r\n+    });\r\n+    const pointer = new THREE.Mesh(geometry, material);\r\n+    scene.add(pointer);\r\n+    setPointer(pointer);\r\n+  };\r\n+\r\n+  const addCanvasEvents = () => {\r\n+    containerRef.current.addEventListener('mousemove', (e) => {\r\n+      updateMousePosition(e.clientX, e.clientY);\r\n+    });\r\n+\r\n+    containerRef.current.addEventListener('click', (e) => {\r\n+      if (!dragged) {\r\n+        updateMousePosition(\r\n+          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+        );\r\n+\r\n+        const res = checkIntersects();\r\n+        if (res.length) {\r\n+          const newPointerPos = res[0].face.normal.clone();\r\n+          setPointerPos(newPointerPos);\r\n+          pointer.position.set(\r\n+            newPointerPos.x,\r\n+            newPointerPos.y,\r\n+            newPointerPos.z\r\n+          );\r\n+          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+          showPopupAnimation(true);\r\n+          clock.start();\r\n+        }\r\n+      }\r\n+    });\r\n+  };\r\n+\r\n+  const updateMousePosition = (eX, eY) => {\r\n+    const rect = containerRef.current.getBoundingClientRect();\r\n+    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+  };\r\n+\r\n+  const checkIntersects = () => {\r\n+    if (!globeMesh) return [];\r\n+    rayCaster.setFromCamera(mouse, camera);\r\n+    const intersects = rayCaster.intersectObject(globeMesh);\r\n+    if (intersects.length) {\r\n+      document.body.style.cursor = 'pointer';\r\n+    } else {\r\n+      document.body.style.cursor = 'auto';\r\n+    }\r\n+    return intersects;\r\n+  };\r\n+\r\n+  const render = () => {\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+    }\r\n+    checkIntersects();\r\n+    if (pointer) {\r\n+      updateOverlayGraphic();\r\n+    }\r\n+    controls.update();\r\n+    renderer.render(scene, camera);\r\n+    requestAnimationFrame(render);\r\n+  };\r\n+\r\n+  const updateSize = () => {\r\n+    if (!renderer) return;\r\n+    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+    containerRef.current.style.width = `${minSide}px`;\r\n+    containerRef.current.style.height = `${minSide}px`;\r\n+    renderer.setSize(minSide, minSide);\r\n+    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+    }\r\n+  };\r\n+\r\n+  const cartesianToLatLong = (pos) => {\r\n+    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+      lng,\r\n+      'E',\r\n+      'W'\r\n+    )}`;\r\n+  };\r\n+\r\n+  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+  };\r\n+\r\n+  const createPopupTimelines = () => {\r\n+    const popupOpenTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, {\r\n+        duration: 0.2,\r\n+        opacity: 1,\r\n+      }, 0)\r\n+      .fromTo(\r\n+        canvas2DRef.current,\r\n+        { opacity: 0 },\r\n+        { duration: 0.3, opacity: 1 },\r\n+        0.15\r\n+      )\r\n+      .fromTo(\r\n+        popupRef.current,\r\n+        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+        { duration: 0.1, opacity: 1, scale: 1 },\r\n+        0.25\r\n+      );\r\n+    setPopupOpenTl(popupOpenTl);\r\n+\r\n+    const popupCloseTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+      .to(popupRef.current, {\r\n+        duration: 0.3,\r\n+        opacity: 0,\r\n+        scale: 0.9,\r\n+        transformOrigin: 'center bottom',\r\n+      }, 0);\r\n+    setPopupCloseTl(popupCloseTl);\r\n+  };\r\n+\r\n+  const showPopupAnimation = (lifted) => {\r\n+    if (lifted) {\r\n+      let positionLifted = pointer.position.clone();\r\n+      positionLifted.multiplyScalar(1.3);\r\n+      gsap.from(pointer.position, {\r\n+        duration: 0.25,\r\n+        x: positionLifted.x,\r\n+        y: positionLifted.y,\r\n+        z: positionLifted.z,\r\n+        ease: 'power3.out',\r\n+      });\r\n+    }\r\n+    popupCloseTl.pause(0);\r\n+    popupOpenTl.play(0);\r\n+  };\r\n+\r\n+  const updateOverlayGraphic = () => {\r\n+    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+    let activePointPosition = pointer.position.clone();\r\n+    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+    const activePointPositionProjected = activePointPosition.clone();\r\n+    activePointPositionProjected.project(camera);\r\n+    const coordinates2D = [\r\n+      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+    ];\r\n+\r\n+    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+    if (activePointPosition.z > -1) {\r\n+      if (!popupVisible) {\r\n+        setPopupVisible(true);\r\n+        showPopupAnimation(false);\r\n+      }\r\n+\r\n+      let popupX = coordinates2D[0];\r\n+      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+      let popupY = coordinates2D[1];\r\n+      const upDown = activePointPositionProjected.y > 0.6;\r\n+      popupY += upDown ? 20 : -20;\r\n+\r\n+      gsap.set(popupRef.current, {\r\n+        x: popupX,\r\n+        y: popupY,\r\n+        xPercent: -35,\r\n+        yPercent: upDown ? 0 : -100,\r\n+      });\r\n+\r\n+      popupY += upDown ? -5 : 5;\r\n+      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+    } else {\r\n+      if (popupVisible) {\r\n+        popupOpenTl.pause(0);\r\n+        popupCloseTl.play(0);\r\n+      }\r\n+      setPopupVisible(false);\r\n+    }\r\n+  };\r\n+\r\n+  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+    ctx.strokeStyle = '#000000';\r\n+    ctx.lineWidth = 3;\r\n+    ctx.lineCap = 'round';\r\n+    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+    ctx.beginPath();\r\n+    ctx.moveTo(startX, startY);\r\n+    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+    ctx.stroke();\r\n+  };\r\n+\r\n+  return (\r\n+    <div className='page'>\r\n+      {/* <div className='title'>Click to add a pointer</div> */}\r\n+      <div className='globe-wrapper' ref={containerRef}>\r\n+        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+        <div id='globe-popup-overlay'>\r\n+          <div className='globe-popup' ref={popupRef}></div>\r\n+        </div>\r\n+      </div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n"
                },
                {
                    "date": 1708584679133,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -135,27 +135,27 @@\n   \r\n   \r\n \r\n \r\n-  const createOrbitControls = (camera, canvas) => {\r\n-    const controls = new OrbitControls(camera, canvas);\r\n-    controls.enablePan = false;\r\n-    controls.enableZoom = false;\r\n-    controls.enableDamping = true;\r\n-    controls.minPolarAngle = 0.4 * Math.PI;\r\n-    controls.maxPolarAngle = 0.4 * Math.PI;\r\n-    controls.autoRotate = true;\r\n+//   const createOrbitControls = (camera, canvas) => {\r\n+//     const controls = new OrbitControls(camera, canvas);\r\n+//     controls.enablePan = false;\r\n+//     controls.enableZoom = false;\r\n+//     controls.enableDamping = true;\r\n+//     controls.minPolarAngle = 0.4 * Math.PI;\r\n+//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n+//     controls.autoRotate = true;\r\n \r\n-    let timestamp;\r\n-    controls.addEventListener('start', () => {\r\n-      timestamp = Date.now();\r\n-    });\r\n-    controls.addEventListener('end', () => {\r\n-      setDragged(Date.now() - timestamp > 600);\r\n-    });\r\n+//     let timestamp;\r\n+//     controls.addEventListener('start', () => {\r\n+//       timestamp = Date.now();\r\n+//     });\r\n+//     controls.addEventListener('end', () => {\r\n+//       setDragged(Date.now() - timestamp > 600);\r\n+//     });\r\n \r\n-    setControls(controls);\r\n-  };\r\n+//     setControls(controls);\r\n+//   };\r\n \r\n   const createGlobe = (earthTexture) => {\r\n     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n     const mapMaterial = new THREE.ShaderMaterial({\r\n@@ -410,828 +410,4 @@\n   );\r\n };\r\n \r\n export default Globe;\r\n-import React, { useEffect, useRef, useState } from 'react';\r\n-import * as THREE from 'three';\r\n-import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n-import { gsap } from 'gsap';\r\n-import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// Vertex shader\r\n-const vertexShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-    uniform float u_dot_size;\r\n-    uniform float u_time_since_click;\r\n-    uniform vec3 u_pointer;\r\n-\r\n-    #define PI 3.14159265359\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vUv = uv;\r\n-\r\n-        // mask with world map\r\n-        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-        gl_PointSize = visibility * u_dot_size;\r\n-\r\n-        // make back dots semi-transparent\r\n-        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-        vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-        // add ripple\r\n-        float t = u_time_since_click - .1;\r\n-        t = max(0., t);\r\n-        float max_amp = .15;\r\n-        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-        delta *= 1. - smoothstep(.8, 1., dist);\r\n-        vec3 pos = position;\r\n-        pos *= (1. + delta);\r\n-\r\n-        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-    }\r\n-`;\r\n-\r\n-// Fragment shader\r\n-const fragmentShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n-        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-        if (dot < 0.5) discard;\r\n-        gl_FragColor = vec4(color, dot * vOpacity);\r\n-    }\r\n-`;\r\n-\r\n-const Globe = () => {\r\n-  const containerRef = useRef(null);\r\n-  const canvas3DRef = useRef(null);\r\n-  const canvas2DRef = useRef(null);\r\n-  const popupRef = useRef(null);\r\n-\r\n-  const [renderer, setRenderer] = useState(null);\r\n-  const [scene, setScene] = useState(new THREE.Scene());\r\n-  const [camera, setCamera] = useState(null);\r\n-  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n-  const [controls, setControls] = useState(null);\r\n-  const [pointer, setPointer] = useState(null);\r\n-  const [globe, setGlobe] = useState(null);\r\n-  const [globeMesh, setGlobeMesh] = useState(null);\r\n-  const [mapMaterial, setMapMaterial] = useState(null);\r\n-  const [popupVisible, setPopupVisible] = useState(false);\r\n-  const [pointerPos, setPointerPos] = useState(null);\r\n-  const [clock, setClock] = useState(new THREE.Clock());\r\n-  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-  const [dragged, setDragged] = useState(false);\r\n-  const [earthTexture, setEarthTexture] = useState(null);\r\n-  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-  useEffect(() => {\r\n-    initScene();\r\n-    window.addEventListener('resize', updateSize);\r\n-    return () => {\r\n-      window.removeEventListener('resize', updateSize);\r\n-    };\r\n-  }, []);\r\n-\r\n-  useEffect(() => {\r\n-    if (renderer && scene && camera) {\r\n-      updateSize();\r\n-      render();\r\n-    }\r\n-  }, [renderer, scene, camera]);\r\n-\r\n-  const initScene = () => {\r\n-    const renderer = new THREE.WebGLRenderer({\r\n-      canvas: canvas3DRef.current,\r\n-      alpha: true,\r\n-    });\r\n-    renderer.setPixelRatio(window.devicePixelRatio);\r\n-    setRenderer(renderer);\r\n-  \r\n-    const camera = new THREE.OrthographicCamera(\r\n-      -1.1,\r\n-      1.1,\r\n-      1.1,\r\n-      -1.1,\r\n-      0,\r\n-      3\r\n-    );\r\n-    camera.position.z = 1.1;\r\n-    setCamera(camera);\r\n-  \r\n-    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n-  \r\n-    new THREE.TextureLoader().load(\r\n-      'https://ksenia-k.com/img/earth-map-colored.png',\r\n-      (mapTex) => {\r\n-        setEarthTexture(mapTex);\r\n-        mapTex.repeat.set(1, 1);\r\n-        createGlobe(mapTex);\r\n-        createPointer();\r\n-        createPopupTimelines();\r\n-        addCanvasEvents();\r\n-      }\r\n-    );\r\n-  };\r\n-  \r\n-  \r\n-\r\n-\r\n-  const createOrbitControls = (camera, canvas) => {\r\n-    const controls = new OrbitControls(camera, canvas);\r\n-    controls.enablePan = false;\r\n-    controls.enableZoom = false;\r\n-    controls.enableDamping = true;\r\n-    controls.minPolarAngle = 0.4 * Math.PI;\r\n-    controls.maxPolarAngle = 0.4 * Math.PI;\r\n-    controls.autoRotate = true;\r\n-\r\n-    let timestamp;\r\n-    controls.addEventListener('start', () => {\r\n-      timestamp = Date.now();\r\n-    });\r\n-    controls.addEventListener('end', () => {\r\n-      setDragged(Date.now() - timestamp > 600);\r\n-    });\r\n-\r\n-    setControls(controls);\r\n-  };\r\n-\r\n-  const createGlobe = (earthTexture) => {\r\n-    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-    const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: vertexShader,\r\n-      fragmentShader: fragmentShader,\r\n-      uniforms: {\r\n-        u_map_tex: { type: 't', value: earthTexture },\r\n-        u_dot_size: { type: 'f', value: 0 },\r\n-        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n-        u_time_since_click: { value: 0 },\r\n-      },\r\n-      alphaTest: false,\r\n-      transparent: true,\r\n-    });\r\n-    setMapMaterial(mapMaterial);\r\n-\r\n-    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-    scene.add(globe);\r\n-    setGlobe(globe);\r\n-\r\n-    const globeMesh = new THREE.Mesh(\r\n-      globeGeometry,\r\n-      new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n-        transparent: true,\r\n-        opacity: 0.05,\r\n-      })\r\n-    );\r\n-    scene.add(globeMesh);\r\n-    setGlobeMesh(globeMesh);\r\n-  };\r\n-\r\n-  const createPointer = () => {\r\n-    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-    const material = new THREE.MeshBasicMaterial({\r\n-      color: 0x000000,\r\n-      transparent: true,\r\n-      opacity: 0,\r\n-    });\r\n-    const pointer = new THREE.Mesh(geometry, material);\r\n-    scene.add(pointer);\r\n-    setPointer(pointer);\r\n-  };\r\n-\r\n-  const addCanvasEvents = () => {\r\n-    containerRef.current.addEventListener('mousemove', (e) => {\r\n-      updateMousePosition(e.clientX, e.clientY);\r\n-    });\r\n-\r\n-    containerRef.current.addEventListener('click', (e) => {\r\n-      if (!dragged) {\r\n-        updateMousePosition(\r\n-          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-        );\r\n-\r\n-        const res = checkIntersects();\r\n-        if (res.length) {\r\n-          const newPointerPos = res[0].face.normal.clone();\r\n-          setPointerPos(newPointerPos);\r\n-          pointer.position.set(\r\n-            newPointerPos.x,\r\n-            newPointerPos.y,\r\n-            newPointerPos.z\r\n-          );\r\n-          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-          showPopupAnimation(true);\r\n-          clock.start();\r\n-        }\r\n-      }\r\n-    });\r\n-  };\r\n-\r\n-  const updateMousePosition = (eX, eY) => {\r\n-    const rect = containerRef.current.getBoundingClientRect();\r\n-    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-  };\r\n-\r\n-  const checkIntersects = () => {\r\n-    if (!globeMesh) return [];\r\n-    rayCaster.setFromCamera(mouse, camera);\r\n-    const intersects = rayCaster.intersectObject(globeMesh);\r\n-    if (intersects.length) {\r\n-      document.body.style.cursor = 'pointer';\r\n-    } else {\r\n-      document.body.style.cursor = 'auto';\r\n-    }\r\n-    return intersects;\r\n-  };\r\n-\r\n-  const render = () => {\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-    }\r\n-    checkIntersects();\r\n-    if (pointer) {\r\n-      updateOverlayGraphic();\r\n-    }\r\n-    controls.update();\r\n-    renderer.render(scene, camera);\r\n-    requestAnimationFrame(render);\r\n-  };\r\n-\r\n-  const updateSize = () => {\r\n-    if (!renderer) return;\r\n-    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-    containerRef.current.style.width = `${minSide}px`;\r\n-    containerRef.current.style.height = `${minSide}px`;\r\n-    renderer.setSize(minSide, minSide);\r\n-    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-    }\r\n-  };\r\n-\r\n-  const cartesianToLatLong = (pos) => {\r\n-    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n-      lng,\r\n-      'E',\r\n-      'W'\r\n-    )}`;\r\n-  };\r\n-\r\n-  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-  };\r\n-\r\n-  const createPopupTimelines = () => {\r\n-    const popupOpenTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, {\r\n-        duration: 0.2,\r\n-        opacity: 1,\r\n-      }, 0)\r\n-      .fromTo(\r\n-        canvas2DRef.current,\r\n-        { opacity: 0 },\r\n-        { duration: 0.3, opacity: 1 },\r\n-        0.15\r\n-      )\r\n-      .fromTo(\r\n-        popupRef.current,\r\n-        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n-        { duration: 0.1, opacity: 1, scale: 1 },\r\n-        0.25\r\n-      );\r\n-    setPopupOpenTl(popupOpenTl);\r\n-\r\n-    const popupCloseTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-      .to(popupRef.current, {\r\n-        duration: 0.3,\r\n-        opacity: 0,\r\n-        scale: 0.9,\r\n-        transformOrigin: 'center bottom',\r\n-      }, 0);\r\n-    setPopupCloseTl(popupCloseTl);\r\n-  };\r\n-\r\n-  const showPopupAnimation = (lifted) => {\r\n-    if (lifted) {\r\n-      let positionLifted = pointer.position.clone();\r\n-      positionLifted.multiplyScalar(1.3);\r\n-      gsap.from(pointer.position, {\r\n-        duration: 0.25,\r\n-        x: positionLifted.x,\r\n-        y: positionLifted.y,\r\n-        z: positionLifted.z,\r\n-        ease: 'power3.out',\r\n-      });\r\n-    }\r\n-    popupCloseTl.pause(0);\r\n-    popupOpenTl.play(0);\r\n-  };\r\n-\r\n-  const updateOverlayGraphic = () => {\r\n-    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n-    let activePointPosition = pointer.position.clone();\r\n-    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-    const activePointPositionProjected = activePointPosition.clone();\r\n-    activePointPositionProjected.project(camera);\r\n-    const coordinates2D = [\r\n-      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-    ];\r\n-\r\n-    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-    if (activePointPosition.z > -1) {\r\n-      if (!popupVisible) {\r\n-        setPopupVisible(true);\r\n-        showPopupAnimation(false);\r\n-      }\r\n-\r\n-      let popupX = coordinates2D[0];\r\n-      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-      let popupY = coordinates2D[1];\r\n-      const upDown = activePointPositionProjected.y > 0.6;\r\n-      popupY += upDown ? 20 : -20;\r\n-\r\n-      gsap.set(popupRef.current, {\r\n-        x: popupX,\r\n-        y: popupY,\r\n-        xPercent: -35,\r\n-        yPercent: upDown ? 0 : -100,\r\n-      });\r\n-\r\n-      popupY += upDown ? -5 : 5;\r\n-      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-    } else {\r\n-      if (popupVisible) {\r\n-        popupOpenTl.pause(0);\r\n-        popupCloseTl.play(0);\r\n-      }\r\n-      setPopupVisible(false);\r\n-    }\r\n-  };\r\n-\r\n-  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-    ctx.strokeStyle = '#000000';\r\n-    ctx.lineWidth = 3;\r\n-    ctx.lineCap = 'round';\r\n-    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-    ctx.beginPath();\r\n-    ctx.moveTo(startX, startY);\r\n-    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-    ctx.stroke();\r\n-  };\r\n-\r\n-  return (\r\n-    <div className='page'>\r\n-      {/* <div className='title'>Click to add a pointer</div> */}\r\n-      <div className='globe-wrapper' ref={containerRef}>\r\n-        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n-        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n-        <div id='globe-popup-overlay'>\r\n-          <div className='globe-popup' ref={popupRef}></div>\r\n-        </div>\r\n-      </div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default Globe;\r\n-import React, { useEffect, useRef, useState } from 'react';\r\n-import * as THREE from 'three';\r\n-import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n-import { gsap } from 'gsap';\r\n-import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// Vertex shader\r\n-const vertexShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-    uniform float u_dot_size;\r\n-    uniform float u_time_since_click;\r\n-    uniform vec3 u_pointer;\r\n-\r\n-    #define PI 3.14159265359\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vUv = uv;\r\n-\r\n-        // mask with world map\r\n-        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-        gl_PointSize = visibility * u_dot_size;\r\n-\r\n-        // make back dots semi-transparent\r\n-        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-        vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-        // add ripple\r\n-        float t = u_time_since_click - .1;\r\n-        t = max(0., t);\r\n-        float max_amp = .15;\r\n-        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-        delta *= 1. - smoothstep(.8, 1., dist);\r\n-        vec3 pos = position;\r\n-        pos *= (1. + delta);\r\n-\r\n-        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-    }\r\n-`;\r\n-\r\n-// Fragment shader\r\n-const fragmentShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vec3 color = white;\r\n-        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-        if (dot < 0.5) discard;\r\n-        gl_FragColor = vec4(color, dot * vOpacity);\r\n-    }\r\n-`;\r\n-\r\n-const Globe = () => {\r\n-  const containerRef = useRef(null);\r\n-  const canvas3DRef = useRef(null);\r\n-  const canvas2DRef = useRef(null);\r\n-  const popupRef = useRef(null);\r\n-\r\n-  const [renderer, setRenderer] = useState(null);\r\n-  const [scene, setScene] = useState(new THREE.Scene());\r\n-  const [camera, setCamera] = useState(null);\r\n-  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n-  const [controls, setControls] = useState(null);\r\n-  const [pointer, setPointer] = useState(null);\r\n-  const [globe, setGlobe] = useState(null);\r\n-  const [globeMesh, setGlobeMesh] = useState(null);\r\n-  const [mapMaterial, setMapMaterial] = useState(null);\r\n-  const [popupVisible, setPopupVisible] = useState(false);\r\n-  const [pointerPos, setPointerPos] = useState(null);\r\n-  const [clock, setClock] = useState(new THREE.Clock());\r\n-  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-  const [dragged, setDragged] = useState(false);\r\n-  const [earthTexture, setEarthTexture] = useState(null);\r\n-  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-  useEffect(() => {\r\n-    initScene();\r\n-    window.addEventListener('resize', updateSize);\r\n-    return () => {\r\n-      window.removeEventListener('resize', updateSize);\r\n-    };\r\n-  }, []);\r\n-\r\n-  useEffect(() => {\r\n-    if (renderer && scene && camera) {\r\n-      updateSize();\r\n-      render();\r\n-    }\r\n-  }, [renderer, scene, camera]);\r\n-\r\n-  const initScene = () => {\r\n-    const renderer = new THREE.WebGLRenderer({\r\n-      canvas: canvas3DRef.current,\r\n-      alpha: true,\r\n-    });\r\n-    renderer.setPixelRatio(window.devicePixelRatio);\r\n-    setRenderer(renderer);\r\n-  \r\n-    const camera = new THREE.OrthographicCamera(\r\n-      -1.1,\r\n-      1.1,\r\n-      1.1,\r\n-      -1.1,\r\n-      0,\r\n-      3\r\n-    );\r\n-    camera.position.z = 1.1;\r\n-    setCamera(camera);\r\n-  \r\n-    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n-  \r\n-    new THREE.TextureLoader().load(\r\n-      'https://ksenia-k.com/img/earth-map-colored.png',\r\n-      (mapTex) => {\r\n-        setEarthTexture(mapTex);\r\n-        mapTex.repeat.set(1, 1);\r\n-        createGlobe(mapTex);\r\n-        createPointer();\r\n-        createPopupTimelines();\r\n-        addCanvasEvents();\r\n-      }\r\n-    );\r\n-  };\r\n-  \r\n-  \r\n-\r\n-\r\n-  const createOrbitControls = (camera, canvas) => {\r\n-    const controls = new OrbitControls(camera, canvas);\r\n-    controls.enablePan = false;\r\n-    controls.enableZoom = false;\r\n-    controls.enableDamping = true;\r\n-    controls.minPolarAngle = 0.4 * Math.PI;\r\n-    controls.maxPolarAngle = 0.4 * Math.PI;\r\n-    controls.autoRotate = true;\r\n-\r\n-    let timestamp;\r\n-    controls.addEventListener('start', () => {\r\n-      timestamp = Date.now();\r\n-    });\r\n-    controls.addEventListener('end', () => {\r\n-      setDragged(Date.now() - timestamp > 600);\r\n-    });\r\n-\r\n-    setControls(controls);\r\n-  };\r\n-\r\n-  const createGlobe = (earthTexture) => {\r\n-    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-    const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: vertexShader,\r\n-      fragmentShader: fragmentShader,\r\n-      uniforms: {\r\n-        u_map_tex: { type: 't', value: earthTexture },\r\n-        u_dot_size: { type: 'f', value: 0 },\r\n-        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n-        u_time_since_click: { value: 0 },\r\n-      },\r\n-      alphaTest: false,\r\n-      transparent: true,\r\n-    });\r\n-    setMapMaterial(mapMaterial);\r\n-\r\n-    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-    scene.add(globe);\r\n-    setGlobe(globe);\r\n-\r\n-    const globeMesh = new THREE.Mesh(\r\n-      globeGeometry,\r\n-      new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n-        transparent: true,\r\n-        opacity: 0.05,\r\n-      })\r\n-    );\r\n-    scene.add(globeMesh);\r\n-    setGlobeMesh(globeMesh);\r\n-  };\r\n-\r\n-  const createPointer = () => {\r\n-    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-    const material = new THREE.MeshBasicMaterial({\r\n-      color: 0x000000,\r\n-      transparent: true,\r\n-      opacity: 0,\r\n-    });\r\n-    const pointer = new THREE.Mesh(geometry, material);\r\n-    scene.add(pointer);\r\n-    setPointer(pointer);\r\n-  };\r\n-\r\n-  const addCanvasEvents = () => {\r\n-    containerRef.current.addEventListener('mousemove', (e) => {\r\n-      updateMousePosition(e.clientX, e.clientY);\r\n-    });\r\n-\r\n-    containerRef.current.addEventListener('click', (e) => {\r\n-      if (!dragged) {\r\n-        updateMousePosition(\r\n-          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-        );\r\n-\r\n-        const res = checkIntersects();\r\n-        if (res.length) {\r\n-          const newPointerPos = res[0].face.normal.clone();\r\n-          setPointerPos(newPointerPos);\r\n-          pointer.position.set(\r\n-            newPointerPos.x,\r\n-            newPointerPos.y,\r\n-            newPointerPos.z\r\n-          );\r\n-          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-          showPopupAnimation(true);\r\n-          clock.start();\r\n-        }\r\n-      }\r\n-    });\r\n-  };\r\n-\r\n-  const updateMousePosition = (eX, eY) => {\r\n-    const rect = containerRef.current.getBoundingClientRect();\r\n-    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-  };\r\n-\r\n-  const checkIntersects = () => {\r\n-    if (!globeMesh) return [];\r\n-    rayCaster.setFromCamera(mouse, camera);\r\n-    const intersects = rayCaster.intersectObject(globeMesh);\r\n-    if (intersects.length) {\r\n-      document.body.style.cursor = 'pointer';\r\n-    } else {\r\n-      document.body.style.cursor = 'auto';\r\n-    }\r\n-    return intersects;\r\n-  };\r\n-\r\n-  const render = () => {\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-    }\r\n-    checkIntersects();\r\n-    if (pointer) {\r\n-      updateOverlayGraphic();\r\n-    }\r\n-    controls.update();\r\n-    renderer.render(scene, camera);\r\n-    requestAnimationFrame(render);\r\n-  };\r\n-\r\n-  const updateSize = () => {\r\n-    if (!renderer) return;\r\n-    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-    containerRef.current.style.width = `${minSide}px`;\r\n-    containerRef.current.style.height = `${minSide}px`;\r\n-    renderer.setSize(minSide, minSide);\r\n-    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-    }\r\n-  };\r\n-\r\n-  const cartesianToLatLong = (pos) => {\r\n-    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n-      lng,\r\n-      'E',\r\n-      'W'\r\n-    )}`;\r\n-  };\r\n-\r\n-  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-  };\r\n-\r\n-  const createPopupTimelines = () => {\r\n-    const popupOpenTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, {\r\n-        duration: 0.2,\r\n-        opacity: 1,\r\n-      }, 0)\r\n-      .fromTo(\r\n-        canvas2DRef.current,\r\n-        { opacity: 0 },\r\n-        { duration: 0.3, opacity: 1 },\r\n-        0.15\r\n-      )\r\n-      .fromTo(\r\n-        popupRef.current,\r\n-        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n-        { duration: 0.1, opacity: 1, scale: 1 },\r\n-        0.25\r\n-      );\r\n-    setPopupOpenTl(popupOpenTl);\r\n-\r\n-    const popupCloseTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-      .to(popupRef.current, {\r\n-        duration: 0.3,\r\n-        opacity: 0,\r\n-        scale: 0.9,\r\n-        transformOrigin: 'center bottom',\r\n-      }, 0);\r\n-    setPopupCloseTl(popupCloseTl);\r\n-  };\r\n-\r\n-  const showPopupAnimation = (lifted) => {\r\n-    if (lifted) {\r\n-      let positionLifted = pointer.position.clone();\r\n-      positionLifted.multiplyScalar(1.3);\r\n-      gsap.from(pointer.position, {\r\n-        duration: 0.25,\r\n-        x: positionLifted.x,\r\n-        y: positionLifted.y,\r\n-        z: positionLifted.z,\r\n-        ease: 'power3.out',\r\n-      });\r\n-    }\r\n-    popupCloseTl.pause(0);\r\n-    popupOpenTl.play(0);\r\n-  };\r\n-\r\n-  const updateOverlayGraphic = () => {\r\n-    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n-    let activePointPosition = pointer.position.clone();\r\n-    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-    const activePointPositionProjected = activePointPosition.clone();\r\n-    activePointPositionProjected.project(camera);\r\n-    const coordinates2D = [\r\n-      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-    ];\r\n-\r\n-    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-    if (activePointPosition.z > -1) {\r\n-      if (!popupVisible) {\r\n-        setPopupVisible(true);\r\n-        showPopupAnimation(false);\r\n-      }\r\n-\r\n-      let popupX = coordinates2D[0];\r\n-      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-      let popupY = coordinates2D[1];\r\n-      const upDown = activePointPositionProjected.y > 0.6;\r\n-      popupY += upDown ? 20 : -20;\r\n-\r\n-      gsap.set(popupRef.current, {\r\n-        x: popupX,\r\n-        y: popupY,\r\n-        xPercent: -35,\r\n-        yPercent: upDown ? 0 : -100,\r\n-      });\r\n-\r\n-      popupY += upDown ? -5 : 5;\r\n-      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-    } else {\r\n-      if (popupVisible) {\r\n-        popupOpenTl.pause(0);\r\n-        popupCloseTl.play(0);\r\n-      }\r\n-      setPopupVisible(false);\r\n-    }\r\n-  };\r\n-\r\n-  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-    ctx.strokeStyle = '#000000';\r\n-    ctx.lineWidth = 3;\r\n-    ctx.lineCap = 'round';\r\n-    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-    ctx.beginPath();\r\n-    ctx.moveTo(startX, startY);\r\n-    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-    ctx.stroke();\r\n-  };\r\n-\r\n-  return (\r\n-    <div className='page'>\r\n-      {/* <div className='title'>Click to add a pointer</div> */}\r\n-      <div className='globe-wrapper' ref={containerRef}>\r\n-        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n-        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n-        <div id='globe-popup-overlay'>\r\n-          <div className='globe-popup' ref={popupRef}></div>\r\n-        </div>\r\n-      </div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default Globe;\r\n"
                },
                {
                    "date": 1708584686634,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,413 @@\n+import React, { useEffect, useRef, useState } from 'react';\r\n+import * as THREE from 'three';\r\n+import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+import { gsap } from 'gsap';\r\n+import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// Vertex shader\r\n+const vertexShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+    uniform float u_dot_size;\r\n+    uniform float u_time_since_click;\r\n+    uniform vec3 u_pointer;\r\n+\r\n+    #define PI 3.14159265359\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vUv = uv;\r\n+\r\n+        // mask with world map\r\n+        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+        gl_PointSize = visibility * u_dot_size;\r\n+\r\n+        // make back dots semi-transparent\r\n+        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+        vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+        // add ripple\r\n+        float t = u_time_since_click - .1;\r\n+        t = max(0., t);\r\n+        float max_amp = .15;\r\n+        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+        delta *= 1. - smoothstep(.8, 1., dist);\r\n+        vec3 pos = position;\r\n+        pos *= (1. + delta);\r\n+\r\n+        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+    }\r\n+`;\r\n+\r\n+// Fragment shader\r\n+const fragmentShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+        if (dot < 0.5) discard;\r\n+        gl_FragColor = vec4(color, dot * vOpacity);\r\n+    }\r\n+`;\r\n+\r\n+const Globe = () => {\r\n+  const containerRef = useRef(null);\r\n+  const canvas3DRef = useRef(null);\r\n+  const canvas2DRef = useRef(null);\r\n+  const popupRef = useRef(null);\r\n+\r\n+  const [renderer, setRenderer] = useState(null);\r\n+  const [scene, setScene] = useState(new THREE.Scene());\r\n+  const [camera, setCamera] = useState(null);\r\n+  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+  const [controls, setControls] = useState(null);\r\n+  const [pointer, setPointer] = useState(null);\r\n+  const [globe, setGlobe] = useState(null);\r\n+  const [globeMesh, setGlobeMesh] = useState(null);\r\n+  const [mapMaterial, setMapMaterial] = useState(null);\r\n+  const [popupVisible, setPopupVisible] = useState(false);\r\n+  const [pointerPos, setPointerPos] = useState(null);\r\n+  const [clock, setClock] = useState(new THREE.Clock());\r\n+  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+  const [dragged, setDragged] = useState(false);\r\n+  const [earthTexture, setEarthTexture] = useState(null);\r\n+  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+  useEffect(() => {\r\n+    initScene();\r\n+    window.addEventListener('resize', updateSize);\r\n+    return () => {\r\n+      window.removeEventListener('resize', updateSize);\r\n+    };\r\n+  }, []);\r\n+\r\n+  useEffect(() => {\r\n+    if (renderer && scene && camera) {\r\n+      updateSize();\r\n+      render();\r\n+    }\r\n+  }, [renderer, scene, camera]);\r\n+\r\n+  const initScene = () => {\r\n+    const renderer = new THREE.WebGLRenderer({\r\n+      canvas: canvas3DRef.current,\r\n+      alpha: true,\r\n+    });\r\n+    renderer.setPixelRatio(window.devicePixelRatio);\r\n+    setRenderer(renderer);\r\n+  \r\n+    const camera = new THREE.OrthographicCamera(\r\n+      -1.1,\r\n+      1.1,\r\n+      1.1,\r\n+      -1.1,\r\n+      0,\r\n+      3\r\n+    );\r\n+    camera.position.z = 1.1;\r\n+    setCamera(camera);\r\n+  \r\n+    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n+  \r\n+    new THREE.TextureLoader().load(\r\n+      'https://ksenia-k.com/img/earth-map-colored.png',\r\n+      (mapTex) => {\r\n+        setEarthTexture(mapTex);\r\n+        mapTex.repeat.set(1, 1);\r\n+        createGlobe(mapTex);\r\n+        createPointer(); // Ensure this is called before createPopupTimelines\r\n+        createPopupTimelines(); // This should be called after createPointer\r\n+        addCanvasEvents();\r\n+      }\r\n+    );\r\n+  };\r\n+  \r\n+  \r\n+  \r\n+\r\n+\r\n+  const createOrbitControls = (camera, canvas) => {\r\n+    const controls = new OrbitControls(camera, canvas);\r\n+    controls.enablePan = false;\r\n+    controls.enableZoom = false;\r\n+    controls.enableDamping = true;\r\n+    controls.minPolarAngle = 0.4 * Math.PI;\r\n+    controls.maxPolarAngle = 0.4 * Math.PI;\r\n+    controls.autoRotate = true;\r\n+\r\n+    let timestamp;\r\n+    controls.addEventListener('start', () => {\r\n+      timestamp = Date.now();\r\n+    });\r\n+    controls.addEventListener('end', () => {\r\n+      setDragged(Date.now() - timestamp > 600);\r\n+    });\r\n+\r\n+    setControls(controls);\r\n+  };\r\n+\r\n+  const createGlobe = (earthTexture) => {\r\n+    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+    const mapMaterial = new THREE.ShaderMaterial({\r\n+      vertexShader: vertexShader,\r\n+      fragmentShader: fragmentShader,\r\n+      uniforms: {\r\n+        u_map_tex: { type: 't', value: earthTexture },\r\n+        u_dot_size: { type: 'f', value: 0 },\r\n+        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+        u_time_since_click: { value: 0 },\r\n+      },\r\n+      alphaTest: false,\r\n+      transparent: true,\r\n+    });\r\n+    setMapMaterial(mapMaterial);\r\n+\r\n+    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+    scene.add(globe);\r\n+    setGlobe(globe);\r\n+\r\n+    const globeMesh = new THREE.Mesh(\r\n+      globeGeometry,\r\n+      new THREE.MeshBasicMaterial({\r\n+        color: 0x222222,\r\n+        transparent: true,\r\n+        opacity: 0.05,\r\n+      })\r\n+    );\r\n+    scene.add(globeMesh);\r\n+    setGlobeMesh(globeMesh);\r\n+  };\r\n+\r\n+  const createPointer = () => {\r\n+    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+    const material = new THREE.MeshBasicMaterial({\r\n+      color: 0x000000,\r\n+      transparent: true,\r\n+      opacity: 0,\r\n+    });\r\n+    const pointer = new THREE.Mesh(geometry, material);\r\n+    scene.add(pointer);\r\n+    setPointer(pointer);\r\n+  };\r\n+\r\n+  const addCanvasEvents = () => {\r\n+    containerRef.current.addEventListener('mousemove', (e) => {\r\n+      updateMousePosition(e.clientX, e.clientY);\r\n+    });\r\n+\r\n+    containerRef.current.addEventListener('click', (e) => {\r\n+      if (!dragged) {\r\n+        updateMousePosition(\r\n+          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+        );\r\n+\r\n+        const res = checkIntersects();\r\n+        if (res.length) {\r\n+          const newPointerPos = res[0].face.normal.clone();\r\n+          setPointerPos(newPointerPos);\r\n+          pointer.position.set(\r\n+            newPointerPos.x,\r\n+            newPointerPos.y,\r\n+            newPointerPos.z\r\n+          );\r\n+          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+          showPopupAnimation(true);\r\n+          clock.start();\r\n+        }\r\n+      }\r\n+    });\r\n+  };\r\n+\r\n+  const updateMousePosition = (eX, eY) => {\r\n+    const rect = containerRef.current.getBoundingClientRect();\r\n+    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+  };\r\n+\r\n+  const checkIntersects = () => {\r\n+    if (!globeMesh) return [];\r\n+    rayCaster.setFromCamera(mouse, camera);\r\n+    const intersects = rayCaster.intersectObject(globeMesh);\r\n+    if (intersects.length) {\r\n+      document.body.style.cursor = 'pointer';\r\n+    } else {\r\n+      document.body.style.cursor = 'auto';\r\n+    }\r\n+    return intersects;\r\n+  };\r\n+\r\n+  const render = () => {\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+    }\r\n+    checkIntersects();\r\n+    if (pointer) {\r\n+      updateOverlayGraphic();\r\n+    }\r\n+    controls.update();\r\n+    renderer.render(scene, camera);\r\n+    requestAnimationFrame(render);\r\n+  };\r\n+\r\n+  const updateSize = () => {\r\n+    if (!renderer) return;\r\n+    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+    containerRef.current.style.width = `${minSide}px`;\r\n+    containerRef.current.style.height = `${minSide}px`;\r\n+    renderer.setSize(minSide, minSide);\r\n+    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+    }\r\n+  };\r\n+\r\n+  const cartesianToLatLong = (pos) => {\r\n+    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+      lng,\r\n+      'E',\r\n+      'W'\r\n+    )}`;\r\n+  };\r\n+\r\n+  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+  };\r\n+\r\n+  const createPopupTimelines = () => {\r\n+    const popupOpenTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, {\r\n+        duration: 0.2,\r\n+        opacity: 1,\r\n+      }, 0)\r\n+      .fromTo(\r\n+        canvas2DRef.current,\r\n+        { opacity: 0 },\r\n+        { duration: 0.3, opacity: 1 },\r\n+        0.15\r\n+      )\r\n+      .fromTo(\r\n+        popupRef.current,\r\n+        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+        { duration: 0.1, opacity: 1, scale: 1 },\r\n+        0.25\r\n+      );\r\n+    setPopupOpenTl(popupOpenTl);\r\n+\r\n+    const popupCloseTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+      .to(popupRef.current, {\r\n+        duration: 0.3,\r\n+        opacity: 0,\r\n+        scale: 0.9,\r\n+        transformOrigin: 'center bottom',\r\n+      }, 0);\r\n+    setPopupCloseTl(popupCloseTl);\r\n+  };\r\n+\r\n+  const showPopupAnimation = (lifted) => {\r\n+    if (lifted) {\r\n+      let positionLifted = pointer.position.clone();\r\n+      positionLifted.multiplyScalar(1.3);\r\n+      gsap.from(pointer.position, {\r\n+        duration: 0.25,\r\n+        x: positionLifted.x,\r\n+        y: positionLifted.y,\r\n+        z: positionLifted.z,\r\n+        ease: 'power3.out',\r\n+      });\r\n+    }\r\n+    popupCloseTl.pause(0);\r\n+    popupOpenTl.play(0);\r\n+  };\r\n+\r\n+  const updateOverlayGraphic = () => {\r\n+    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+    let activePointPosition = pointer.position.clone();\r\n+    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+    const activePointPositionProjected = activePointPosition.clone();\r\n+    activePointPositionProjected.project(camera);\r\n+    const coordinates2D = [\r\n+      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+    ];\r\n+\r\n+    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+    if (activePointPosition.z > -1) {\r\n+      if (!popupVisible) {\r\n+        setPopupVisible(true);\r\n+        showPopupAnimation(false);\r\n+      }\r\n+\r\n+      let popupX = coordinates2D[0];\r\n+      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+      let popupY = coordinates2D[1];\r\n+      const upDown = activePointPositionProjected.y > 0.6;\r\n+      popupY += upDown ? 20 : -20;\r\n+\r\n+      gsap.set(popupRef.current, {\r\n+        x: popupX,\r\n+        y: popupY,\r\n+        xPercent: -35,\r\n+        yPercent: upDown ? 0 : -100,\r\n+      });\r\n+\r\n+      popupY += upDown ? -5 : 5;\r\n+      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+    } else {\r\n+      if (popupVisible) {\r\n+        popupOpenTl.pause(0);\r\n+        popupCloseTl.play(0);\r\n+      }\r\n+      setPopupVisible(false);\r\n+    }\r\n+  };\r\n+\r\n+  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+    ctx.strokeStyle = '#000000';\r\n+    ctx.lineWidth = 3;\r\n+    ctx.lineCap = 'round';\r\n+    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+    ctx.beginPath();\r\n+    ctx.moveTo(startX, startY);\r\n+    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+    ctx.stroke();\r\n+  };\r\n+\r\n+  return (\r\n+    <div className='page'>\r\n+      {/* <div className='title'>Click to add a pointer</div> */}\r\n+      <div className='globe-wrapper' ref={containerRef}>\r\n+        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+        <div id='globe-popup-overlay'>\r\n+          <div className='globe-popup' ref={popupRef}></div>\r\n+        </div>\r\n+      </div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n"
                },
                {
                    "date": 1708585037116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,417 +410,4 @@\n   );\r\n };\r\n \r\n export default Globe;\r\n-import React, { useEffect, useRef, useState } from 'react';\r\n-import * as THREE from 'three';\r\n-import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n-import { gsap } from 'gsap';\r\n-import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// Vertex shader\r\n-const vertexShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-    uniform float u_dot_size;\r\n-    uniform float u_time_since_click;\r\n-    uniform vec3 u_pointer;\r\n-\r\n-    #define PI 3.14159265359\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vUv = uv;\r\n-\r\n-        // mask with world map\r\n-        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-        gl_PointSize = visibility * u_dot_size;\r\n-\r\n-        // make back dots semi-transparent\r\n-        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-        vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-        // add ripple\r\n-        float t = u_time_since_click - .1;\r\n-        t = max(0., t);\r\n-        float max_amp = .15;\r\n-        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-        delta *= 1. - smoothstep(.8, 1., dist);\r\n-        vec3 pos = position;\r\n-        pos *= (1. + delta);\r\n-\r\n-        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-    }\r\n-`;\r\n-\r\n-// Fragment shader\r\n-const fragmentShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n-        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-        if (dot < 0.5) discard;\r\n-        gl_FragColor = vec4(color, dot * vOpacity);\r\n-    }\r\n-`;\r\n-\r\n-const Globe = () => {\r\n-  const containerRef = useRef(null);\r\n-  const canvas3DRef = useRef(null);\r\n-  const canvas2DRef = useRef(null);\r\n-  const popupRef = useRef(null);\r\n-\r\n-  const [renderer, setRenderer] = useState(null);\r\n-  const [scene, setScene] = useState(new THREE.Scene());\r\n-  const [camera, setCamera] = useState(null);\r\n-  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n-  const [controls, setControls] = useState(null);\r\n-  const [pointer, setPointer] = useState(null);\r\n-  const [globe, setGlobe] = useState(null);\r\n-  const [globeMesh, setGlobeMesh] = useState(null);\r\n-  const [mapMaterial, setMapMaterial] = useState(null);\r\n-  const [popupVisible, setPopupVisible] = useState(false);\r\n-  const [pointerPos, setPointerPos] = useState(null);\r\n-  const [clock, setClock] = useState(new THREE.Clock());\r\n-  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-  const [dragged, setDragged] = useState(false);\r\n-  const [earthTexture, setEarthTexture] = useState(null);\r\n-  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-  useEffect(() => {\r\n-    initScene();\r\n-    window.addEventListener('resize', updateSize);\r\n-    return () => {\r\n-      window.removeEventListener('resize', updateSize);\r\n-    };\r\n-  }, []);\r\n-\r\n-  useEffect(() => {\r\n-    if (renderer && scene && camera) {\r\n-      updateSize();\r\n-      render();\r\n-    }\r\n-  }, [renderer, scene, camera]);\r\n-\r\n-  const initScene = () => {\r\n-    const renderer = new THREE.WebGLRenderer({\r\n-      canvas: canvas3DRef.current,\r\n-      alpha: true,\r\n-    });\r\n-    renderer.setPixelRatio(window.devicePixelRatio);\r\n-    setRenderer(renderer);\r\n-  \r\n-    const camera = new THREE.OrthographicCamera(\r\n-      -1.1,\r\n-      1.1,\r\n-      1.1,\r\n-      -1.1,\r\n-      0,\r\n-      3\r\n-    );\r\n-    camera.position.z = 1.1;\r\n-    setCamera(camera);\r\n-  \r\n-    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n-  \r\n-    new THREE.TextureLoader().load(\r\n-      'https://ksenia-k.com/img/earth-map-colored.png',\r\n-      (mapTex) => {\r\n-        setEarthTexture(mapTex);\r\n-        mapTex.repeat.set(1, 1);\r\n-        createGlobe(mapTex);\r\n-        createPointer(); // Ensure this is called before createPopupTimelines\r\n-        createPopupTimelines(); // This should be called after createPointer\r\n-        addCanvasEvents();\r\n-      }\r\n-    );\r\n-  };\r\n-  \r\n-  \r\n-  \r\n-\r\n-\r\n-//   const createOrbitControls = (camera, canvas) => {\r\n-//     const controls = new OrbitControls(camera, canvas);\r\n-//     controls.enablePan = false;\r\n-//     controls.enableZoom = false;\r\n-//     controls.enableDamping = true;\r\n-//     controls.minPolarAngle = 0.4 * Math.PI;\r\n-//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n-//     controls.autoRotate = true;\r\n-\r\n-//     let timestamp;\r\n-//     controls.addEventListener('start', () => {\r\n-//       timestamp = Date.now();\r\n-//     });\r\n-//     controls.addEventListener('end', () => {\r\n-//       setDragged(Date.now() - timestamp > 600);\r\n-//     });\r\n-\r\n-//     setControls(controls);\r\n-//   };\r\n-\r\n-  const createGlobe = (earthTexture) => {\r\n-    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-    const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: vertexShader,\r\n-      fragmentShader: fragmentShader,\r\n-      uniforms: {\r\n-        u_map_tex: { type: 't', value: earthTexture },\r\n-        u_dot_size: { type: 'f', value: 0 },\r\n-        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n-        u_time_since_click: { value: 0 },\r\n-      },\r\n-      alphaTest: false,\r\n-      transparent: true,\r\n-    });\r\n-    setMapMaterial(mapMaterial);\r\n-\r\n-    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-    scene.add(globe);\r\n-    setGlobe(globe);\r\n-\r\n-    const globeMesh = new THREE.Mesh(\r\n-      globeGeometry,\r\n-      new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n-        transparent: true,\r\n-        opacity: 0.05,\r\n-      })\r\n-    );\r\n-    scene.add(globeMesh);\r\n-    setGlobeMesh(globeMesh);\r\n-  };\r\n-\r\n-  const createPointer = () => {\r\n-    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-    const material = new THREE.MeshBasicMaterial({\r\n-      color: 0x000000,\r\n-      transparent: true,\r\n-      opacity: 0,\r\n-    });\r\n-    const pointer = new THREE.Mesh(geometry, material);\r\n-    scene.add(pointer);\r\n-    setPointer(pointer);\r\n-  };\r\n-\r\n-  const addCanvasEvents = () => {\r\n-    containerRef.current.addEventListener('mousemove', (e) => {\r\n-      updateMousePosition(e.clientX, e.clientY);\r\n-    });\r\n-\r\n-    containerRef.current.addEventListener('click', (e) => {\r\n-      if (!dragged) {\r\n-        updateMousePosition(\r\n-          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-        );\r\n-\r\n-        const res = checkIntersects();\r\n-        if (res.length) {\r\n-          const newPointerPos = res[0].face.normal.clone();\r\n-          setPointerPos(newPointerPos);\r\n-          pointer.position.set(\r\n-            newPointerPos.x,\r\n-            newPointerPos.y,\r\n-            newPointerPos.z\r\n-          );\r\n-          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-          showPopupAnimation(true);\r\n-          clock.start();\r\n-        }\r\n-      }\r\n-    });\r\n-  };\r\n-\r\n-  const updateMousePosition = (eX, eY) => {\r\n-    const rect = containerRef.current.getBoundingClientRect();\r\n-    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-  };\r\n-\r\n-  const checkIntersects = () => {\r\n-    if (!globeMesh) return [];\r\n-    rayCaster.setFromCamera(mouse, camera);\r\n-    const intersects = rayCaster.intersectObject(globeMesh);\r\n-    if (intersects.length) {\r\n-      document.body.style.cursor = 'pointer';\r\n-    } else {\r\n-      document.body.style.cursor = 'auto';\r\n-    }\r\n-    return intersects;\r\n-  };\r\n-\r\n-  const render = () => {\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-    }\r\n-    checkIntersects();\r\n-    if (pointer) {\r\n-      updateOverlayGraphic();\r\n-    }\r\n-    controls.update();\r\n-    renderer.render(scene, camera);\r\n-    requestAnimationFrame(render);\r\n-  };\r\n-\r\n-  const updateSize = () => {\r\n-    if (!renderer) return;\r\n-    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-    containerRef.current.style.width = `${minSide}px`;\r\n-    containerRef.current.style.height = `${minSide}px`;\r\n-    renderer.setSize(minSide, minSide);\r\n-    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-    }\r\n-  };\r\n-\r\n-  const cartesianToLatLong = (pos) => {\r\n-    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n-      lng,\r\n-      'E',\r\n-      'W'\r\n-    )}`;\r\n-  };\r\n-\r\n-  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-  };\r\n-\r\n-  const createPopupTimelines = () => {\r\n-    const popupOpenTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, {\r\n-        duration: 0.2,\r\n-        opacity: 1,\r\n-      }, 0)\r\n-      .fromTo(\r\n-        canvas2DRef.current,\r\n-        { opacity: 0 },\r\n-        { duration: 0.3, opacity: 1 },\r\n-        0.15\r\n-      )\r\n-      .fromTo(\r\n-        popupRef.current,\r\n-        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n-        { duration: 0.1, opacity: 1, scale: 1 },\r\n-        0.25\r\n-      );\r\n-    setPopupOpenTl(popupOpenTl);\r\n-\r\n-    const popupCloseTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-      .to(popupRef.current, {\r\n-        duration: 0.3,\r\n-        opacity: 0,\r\n-        scale: 0.9,\r\n-        transformOrigin: 'center bottom',\r\n-      }, 0);\r\n-    setPopupCloseTl(popupCloseTl);\r\n-  };\r\n-\r\n-  const showPopupAnimation = (lifted) => {\r\n-    if (lifted) {\r\n-      let positionLifted = pointer.position.clone();\r\n-      positionLifted.multiplyScalar(1.3);\r\n-      gsap.from(pointer.position, {\r\n-        duration: 0.25,\r\n-        x: positionLifted.x,\r\n-        y: positionLifted.y,\r\n-        z: positionLifted.z,\r\n-        ease: 'power3.out',\r\n-      });\r\n-    }\r\n-    popupCloseTl.pause(0);\r\n-    popupOpenTl.play(0);\r\n-  };\r\n-\r\n-  const updateOverlayGraphic = () => {\r\n-    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n-    let activePointPosition = pointer.position.clone();\r\n-    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-    const activePointPositionProjected = activePointPosition.clone();\r\n-    activePointPositionProjected.project(camera);\r\n-    const coordinates2D = [\r\n-      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-    ];\r\n-\r\n-    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-    if (activePointPosition.z > -1) {\r\n-      if (!popupVisible) {\r\n-        setPopupVisible(true);\r\n-        showPopupAnimation(false);\r\n-      }\r\n-\r\n-      let popupX = coordinates2D[0];\r\n-      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-      let popupY = coordinates2D[1];\r\n-      const upDown = activePointPositionProjected.y > 0.6;\r\n-      popupY += upDown ? 20 : -20;\r\n-\r\n-      gsap.set(popupRef.current, {\r\n-        x: popupX,\r\n-        y: popupY,\r\n-        xPercent: -35,\r\n-        yPercent: upDown ? 0 : -100,\r\n-      });\r\n-\r\n-      popupY += upDown ? -5 : 5;\r\n-      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-    } else {\r\n-      if (popupVisible) {\r\n-        popupOpenTl.pause(0);\r\n-        popupCloseTl.play(0);\r\n-      }\r\n-      setPopupVisible(false);\r\n-    }\r\n-  };\r\n-\r\n-  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-    ctx.strokeStyle = '#000000';\r\n-    ctx.lineWidth = 3;\r\n-    ctx.lineCap = 'round';\r\n-    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-    ctx.beginPath();\r\n-    ctx.moveTo(startX, startY);\r\n-    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-    ctx.stroke();\r\n-  };\r\n-\r\n-  return (\r\n-    <div className='page'>\r\n-      {/* <div className='title'>Click to add a pointer</div> */}\r\n-      <div className='globe-wrapper' ref={containerRef}>\r\n-        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n-        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n-        <div id='globe-popup-overlay'>\r\n-          <div className='globe-popup' ref={popupRef}></div>\r\n-        </div>\r\n-      </div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default Globe;\r\n"
                },
                {
                    "date": 1708592913889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,414 @@\n+import React, { useEffect, useRef, useState } from 'react';\r\n+import * as THREE from 'three';\r\n+import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+import { gsap } from 'gsap';\r\n+import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// Vertex shader\r\n+const vertexShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+    uniform float u_dot_size;\r\n+    uniform float u_time_since_click;\r\n+    uniform vec3 u_pointer;\r\n+\r\n+    #define PI 3.14159265359\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vUv = uv;\r\n+\r\n+        // mask with world map\r\n+        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+        gl_PointSize = visibility * u_dot_size;\r\n+\r\n+        // make back dots semi-transparent\r\n+        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+        vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+        // add ripple\r\n+        float t = u_time_since_click - .1;\r\n+        t = max(0., t);\r\n+        float max_amp = .15;\r\n+        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+        delta *= 1. - smoothstep(.8, 1., dist);\r\n+        vec3 pos = position;\r\n+        pos *= (1. + delta);\r\n+\r\n+        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+    }\r\n+`;\r\n+\r\n+// Fragment shader\r\n+const fragmentShader = `\r\n+    uniform sampler2D u_map_tex;\r\n+\r\n+    varying float vOpacity;\r\n+    varying vec2 vUv;\r\n+\r\n+    void main() {\r\n+        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+        if (dot < 0.5) discard;\r\n+        gl_FragColor = vec4(color, dot * vOpacity);\r\n+    }\r\n+`;\r\n+\r\n+const Globe = () => {\r\n+  const containerRef = useRef(null);\r\n+  const canvas3DRef = useRef(null);\r\n+  const canvas2DRef = useRef(null);\r\n+  const popupRef = useRef(null);\r\n+\r\n+  const [renderer, setRenderer] = useState(null);\r\n+  const [scene, setScene] = useState(new THREE.Scene());\r\n+  const [camera, setCamera] = useState(null);\r\n+  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+  const [controls, setControls] = useState(null);\r\n+  const [pointer, setPointer] = useState(null);\r\n+  const [globe, setGlobe] = useState(null);\r\n+  const [globeMesh, setGlobeMesh] = useState(null);\r\n+  const [mapMaterial, setMapMaterial] = useState(null);\r\n+  const [popupVisible, setPopupVisible] = useState(false);\r\n+  const [pointerPos, setPointerPos] = useState(null);\r\n+  const [clock, setClock] = useState(new THREE.Clock());\r\n+  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+  const [dragged, setDragged] = useState(false);\r\n+  const [earthTexture, setEarthTexture] = useState(null);\r\n+  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+  useEffect(() => {\r\n+    initScene();\r\n+    window.addEventListener('resize', updateSize);\r\n+    return () => {\r\n+      window.removeEventListener('resize', updateSize);\r\n+    };\r\n+  }, []);\r\n+\r\n+  useEffect(() => {\r\n+    if (renderer && scene && camera) {\r\n+      updateSize();\r\n+      render();\r\n+    }\r\n+  }, [renderer, scene, camera]);\r\n+\r\n+  const initScene = () => {\r\n+    const renderer = new THREE.WebGLRenderer({\r\n+      canvas: canvas3DRef.current,\r\n+      alpha: true,\r\n+    });\r\n+    renderer.setPixelRatio(window.devicePixelRatio);\r\n+    setRenderer(renderer);\r\n+  \r\n+    const camera = new THREE.OrthographicCamera(\r\n+      -1.1,\r\n+      1.1,\r\n+      1.1,\r\n+      -1.1,\r\n+      0,\r\n+      3\r\n+    );\r\n+    camera.position.z = 1.1;\r\n+    setCamera(camera);\r\n+  \r\n+    createOrbitControls(camera, renderer.domElement);\r\n+  \r\n+    new THREE.TextureLoader().load(\r\n+      'https://ksenia-k.com/img/earth-map-colored.png',\r\n+      (mapTex) => {\r\n+        setEarthTexture(mapTex);\r\n+        mapTex.repeat.set(1, 1);\r\n+        createGlobe(mapTex);\r\n+        createPointer();\r\n+        createPopupTimelines();\r\n+        addCanvasEvents();\r\n+        updateSize(); // Update the size of the renderer and camera\r\n+        render(); // Start the rendering loop\r\n+      }\r\n+    );\r\n+  };\r\n+  \r\n+  \r\n+\r\n+\r\n+  const createOrbitControls = (camera, canvas) => {\r\n+    const controls = new OrbitControls(camera, canvas);\r\n+    controls.enablePan = false;\r\n+    controls.enableZoom = false;\r\n+    controls.enableDamping = true;\r\n+    controls.minPolarAngle = 0.4 * Math.PI;\r\n+    controls.maxPolarAngle = 0.4 * Math.PI;\r\n+    controls.autoRotate = true;\r\n+\r\n+    let timestamp;\r\n+    controls.addEventListener('start', () => {\r\n+      timestamp = Date.now();\r\n+    });\r\n+    controls.addEventListener('end', () => {\r\n+      setDragged(Date.now() - timestamp > 600);\r\n+    });\r\n+\r\n+    setControls(controls);\r\n+  };\r\n+\r\n+  const createGlobe = (earthTexture) => {\r\n+    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+    const mapMaterial = new THREE.ShaderMaterial({\r\n+      vertexShader: vertexShader,\r\n+      fragmentShader: fragmentShader,\r\n+      uniforms: {\r\n+        u_map_tex: { type: 't', value: earthTexture },\r\n+        u_dot_size: { type: 'f', value: 0 },\r\n+        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+        u_time_since_click: { value: 0 },\r\n+      },\r\n+      alphaTest: false,\r\n+      transparent: true,\r\n+    });\r\n+    setMapMaterial(mapMaterial);\r\n+\r\n+    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+    scene.add(globe);\r\n+    setGlobe(globe);\r\n+\r\n+    const globeMesh = new THREE.Mesh(\r\n+      globeGeometry,\r\n+      new THREE.MeshBasicMaterial({\r\n+        color: 0x222222,\r\n+        transparent: true,\r\n+        opacity: 0.05,\r\n+      })\r\n+    );\r\n+    scene.add(globeMesh);\r\n+    setGlobeMesh(globeMesh);\r\n+  };\r\n+\r\n+  const createPointer = () => {\r\n+    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+    const material = new THREE.MeshBasicMaterial({\r\n+      color: 0x000000,\r\n+      transparent: true,\r\n+      opacity: 0,\r\n+    });\r\n+    const pointer = new THREE.Mesh(geometry, material);\r\n+    scene.add(pointer);\r\n+    setPointer(pointer);\r\n+  };\r\n+\r\n+  const addCanvasEvents = () => {\r\n+    containerRef.current.addEventListener('mousemove', (e) => {\r\n+      updateMousePosition(e.clientX, e.clientY);\r\n+    });\r\n+\r\n+    containerRef.current.addEventListener('click', (e) => {\r\n+      if (!dragged) {\r\n+        updateMousePosition(\r\n+          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+        );\r\n+\r\n+        const res = checkIntersects();\r\n+        if (res.length) {\r\n+          const newPointerPos = res[0].face.normal.clone();\r\n+          setPointerPos(newPointerPos);\r\n+          pointer.position.set(\r\n+            newPointerPos.x,\r\n+            newPointerPos.y,\r\n+            newPointerPos.z\r\n+          );\r\n+          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+          showPopupAnimation(true);\r\n+          clock.start();\r\n+        }\r\n+      }\r\n+    });\r\n+  };\r\n+\r\n+  const updateMousePosition = (eX, eY) => {\r\n+    const rect = containerRef.current.getBoundingClientRect();\r\n+    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+  };\r\n+\r\n+  const checkIntersects = () => {\r\n+    if (!globeMesh) return [];\r\n+    rayCaster.setFromCamera(mouse, camera);\r\n+    const intersects = rayCaster.intersectObject(globeMesh);\r\n+    if (intersects.length) {\r\n+      document.body.style.cursor = 'pointer';\r\n+    } else {\r\n+      document.body.style.cursor = 'auto';\r\n+    }\r\n+    return intersects;\r\n+  };\r\n+\r\n+  const render = () => {\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+    }\r\n+    checkIntersects();\r\n+    if (pointer) {\r\n+      updateOverlayGraphic();\r\n+    }\r\n+    controls.update();\r\n+    renderer.render(scene, camera);\r\n+    requestAnimationFrame(render);\r\n+  };\r\n+\r\n+  const updateSize = () => {\r\n+    if (!renderer) return;\r\n+    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+    containerRef.current.style.width = `${minSide}px`;\r\n+    containerRef.current.style.height = `${minSide}px`;\r\n+    renderer.setSize(minSide, minSide);\r\n+    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+    if (mapMaterial) {\r\n+      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+    }\r\n+  };\r\n+\r\n+  const cartesianToLatLong = (pos) => {\r\n+    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+      lng,\r\n+      'E',\r\n+      'W'\r\n+    )}`;\r\n+  };\r\n+\r\n+  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+  };\r\n+\r\n+  const createPopupTimelines = () => {\r\n+    const popupOpenTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, {\r\n+        duration: 0.2,\r\n+        opacity: 1,\r\n+      }, 0)\r\n+      .fromTo(\r\n+        canvas2DRef.current,\r\n+        { opacity: 0 },\r\n+        { duration: 0.3, opacity: 1 },\r\n+        0.15\r\n+      )\r\n+      .fromTo(\r\n+        popupRef.current,\r\n+        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+        { duration: 0.1, opacity: 1, scale: 1 },\r\n+        0.25\r\n+      );\r\n+    setPopupOpenTl(popupOpenTl);\r\n+\r\n+    const popupCloseTl = gsap.timeline({ paused: true })\r\n+      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+      .to(popupRef.current, {\r\n+        duration: 0.3,\r\n+        opacity: 0,\r\n+        scale: 0.9,\r\n+        transformOrigin: 'center bottom',\r\n+      }, 0);\r\n+    setPopupCloseTl(popupCloseTl);\r\n+  };\r\n+\r\n+  const showPopupAnimation = (lifted) => {\r\n+    if (lifted) {\r\n+      let positionLifted = pointer.position.clone();\r\n+      positionLifted.multiplyScalar(1.3);\r\n+      gsap.from(pointer.position, {\r\n+        duration: 0.25,\r\n+        x: positionLifted.x,\r\n+        y: positionLifted.y,\r\n+        z: positionLifted.z,\r\n+        ease: 'power3.out',\r\n+      });\r\n+    }\r\n+    popupCloseTl.pause(0);\r\n+    popupOpenTl.play(0);\r\n+  };\r\n+\r\n+  const updateOverlayGraphic = () => {\r\n+    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+    let activePointPosition = pointer.position.clone();\r\n+    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+    const activePointPositionProjected = activePointPosition.clone();\r\n+    activePointPositionProjected.project(camera);\r\n+    const coordinates2D = [\r\n+      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+    ];\r\n+\r\n+    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+    if (activePointPosition.z > -1) {\r\n+      if (!popupVisible) {\r\n+        setPopupVisible(true);\r\n+        showPopupAnimation(false);\r\n+      }\r\n+\r\n+      let popupX = coordinates2D[0];\r\n+      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+      let popupY = coordinates2D[1];\r\n+      const upDown = activePointPositionProjected.y > 0.6;\r\n+      popupY += upDown ? 20 : -20;\r\n+\r\n+      gsap.set(popupRef.current, {\r\n+        x: popupX,\r\n+        y: popupY,\r\n+        xPercent: -35,\r\n+        yPercent: upDown ? 0 : -100,\r\n+      });\r\n+\r\n+      popupY += upDown ? -5 : 5;\r\n+      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+    } else {\r\n+      if (popupVisible) {\r\n+        popupOpenTl.pause(0);\r\n+        popupCloseTl.play(0);\r\n+      }\r\n+      setPopupVisible(false);\r\n+    }\r\n+  };\r\n+\r\n+  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+    ctx.strokeStyle = '#000000';\r\n+    ctx.lineWidth = 3;\r\n+    ctx.lineCap = 'round';\r\n+    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+    ctx.beginPath();\r\n+    ctx.moveTo(startX, startY);\r\n+    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+    ctx.stroke();\r\n+  };\r\n+\r\n+  return (\r\n+    <div className='page'>\r\n+      {/* <div className='title'>Click to add a pointer</div> */}\r\n+      <div className='globe-wrapper' ref={containerRef}>\r\n+        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+        <div id='globe-popup-overlay'>\r\n+          <div className='globe-popup' ref={popupRef}></div>\r\n+        </div>\r\n+      </div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n"
                },
                {
                    "date": 1708593825622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,425 @@\n+// import React, { useEffect, useRef, useState } from 'react';\r\n+// import * as THREE from 'three';\r\n+// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+// import { gsap } from 'gsap';\r\n+// import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// // Vertex shader\r\n+// const vertexShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+//     uniform float u_dot_size;\r\n+//     uniform float u_time_since_click;\r\n+//     uniform vec3 u_pointer;\r\n+\r\n+//     #define PI 3.14159265359\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vUv = uv;\r\n+\r\n+//         // mask with world map\r\n+//         float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+//         gl_PointSize = visibility * u_dot_size;\r\n+\r\n+//         // make back dots semi-transparent\r\n+//         vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+//         vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+//         vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+//         // add ripple\r\n+//         float t = u_time_since_click - .1;\r\n+//         t = max(0., t);\r\n+//         float max_amp = .15;\r\n+//         float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+//         float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+//         float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+//         delta *= 1. - smoothstep(.8, 1., dist);\r\n+//         vec3 pos = position;\r\n+//         pos *= (1. + delta);\r\n+\r\n+//         gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+//     }\r\n+// `;\r\n+\r\n+// // Fragment shader\r\n+// const fragmentShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+//         color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+//         float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+//         if (dot < 0.5) discard;\r\n+//         gl_FragColor = vec4(color, dot * vOpacity);\r\n+//     }\r\n+// `;\r\n+\r\n+// const Globe = () => {\r\n+//   const containerRef = useRef(null);\r\n+//   const canvas3DRef = useRef(null);\r\n+//   const canvas2DRef = useRef(null);\r\n+//   const popupRef = useRef(null);\r\n+\r\n+//   const [renderer, setRenderer] = useState(null);\r\n+//   const [scene, setScene] = useState(new THREE.Scene());\r\n+//   const [camera, setCamera] = useState(null);\r\n+//   const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+//   const [controls, setControls] = useState(null);\r\n+//   const [pointer, setPointer] = useState(null);\r\n+//   const [globe, setGlobe] = useState(null);\r\n+//   const [globeMesh, setGlobeMesh] = useState(null);\r\n+//   const [mapMaterial, setMapMaterial] = useState(null);\r\n+//   const [popupVisible, setPopupVisible] = useState(false);\r\n+//   const [pointerPos, setPointerPos] = useState(null);\r\n+//   const [clock, setClock] = useState(new THREE.Clock());\r\n+//   const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+//   const [dragged, setDragged] = useState(false);\r\n+//   const [earthTexture, setEarthTexture] = useState(null);\r\n+//   const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+//   const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+//   useEffect(() => {\r\n+//     initScene();\r\n+//     window.addEventListener('resize', updateSize);\r\n+//     return () => {\r\n+//       window.removeEventListener('resize', updateSize);\r\n+//     };\r\n+//   }, []);\r\n+\r\n+//   useEffect(() => {\r\n+//     if (renderer && scene && camera) {\r\n+//       updateSize();\r\n+//       render();\r\n+//     }\r\n+//   }, [renderer, scene, camera]);\r\n+\r\n+//   const initScene = () => {\r\n+//     const renderer = new THREE.WebGLRenderer({\r\n+//       canvas: canvas3DRef.current,\r\n+//       alpha: true,\r\n+//     });\r\n+//     renderer.setPixelRatio(window.devicePixelRatio);\r\n+//     setRenderer(renderer);\r\n+  \r\n+//     const camera = new THREE.OrthographicCamera(\r\n+//       -1.1,\r\n+//       1.1,\r\n+//       1.1,\r\n+//       -1.1,\r\n+//       0,\r\n+//       3\r\n+//     );\r\n+//     camera.position.z = 1.1;\r\n+//     setCamera(camera);\r\n+  \r\n+//     createOrbitControls(camera, renderer.domElement);\r\n+  \r\n+//     new THREE.TextureLoader().load(\r\n+//       'https://ksenia-k.com/img/earth-map-colored.png',\r\n+//       (mapTex) => {\r\n+//         setEarthTexture(mapTex);\r\n+//         mapTex.repeat.set(1, 1);\r\n+//         createGlobe(mapTex);\r\n+//         createPointer();\r\n+//         createPopupTimelines();\r\n+//         addCanvasEvents();\r\n+//         updateSize(); // Update the size of the renderer and camera\r\n+//         render(); // Start the rendering loop\r\n+//       }\r\n+//     );\r\n+//   };\r\n+  \r\n+  \r\n+\r\n+\r\n+//   const createOrbitControls = (camera, canvas) => {\r\n+//     const controls = new OrbitControls(camera, canvas);\r\n+//     controls.enablePan = false;\r\n+//     controls.enableZoom = false;\r\n+//     controls.enableDamping = true;\r\n+//     controls.minPolarAngle = 0.4 * Math.PI;\r\n+//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n+//     controls.autoRotate = true;\r\n+\r\n+//     let timestamp;\r\n+//     controls.addEventListener('start', () => {\r\n+//       timestamp = Date.now();\r\n+//     });\r\n+//     controls.addEventListener('end', () => {\r\n+//       setDragged(Date.now() - timestamp > 600);\r\n+//     });\r\n+\r\n+//     setControls(controls);\r\n+//   };\r\n+\r\n+//   const createGlobe = (earthTexture) => {\r\n+//     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+//     const mapMaterial = new THREE.ShaderMaterial({\r\n+//       vertexShader: vertexShader,\r\n+//       fragmentShader: fragmentShader,\r\n+//       uniforms: {\r\n+//         u_map_tex: { type: 't', value: earthTexture },\r\n+//         u_dot_size: { type: 'f', value: 0 },\r\n+//         u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+//         u_time_since_click: { value: 0 },\r\n+//       },\r\n+//       alphaTest: false,\r\n+//       transparent: true,\r\n+//     });\r\n+//     setMapMaterial(mapMaterial);\r\n+\r\n+//     const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+//     scene.add(globe);\r\n+//     setGlobe(globe);\r\n+\r\n+//     const globeMesh = new THREE.Mesh(\r\n+//       globeGeometry,\r\n+//       new THREE.MeshBasicMaterial({\r\n+//         color: 0x222222,\r\n+//         transparent: true,\r\n+//         opacity: 0.05,\r\n+//       })\r\n+//     );\r\n+//     scene.add(globeMesh);\r\n+//     setGlobeMesh(globeMesh);\r\n+//   };\r\n+\r\n+//   const createPointer = () => {\r\n+//     const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+//     const material = new THREE.MeshBasicMaterial({\r\n+//       color: 0x000000,\r\n+//       transparent: true,\r\n+//       opacity: 0,\r\n+//     });\r\n+//     const pointer = new THREE.Mesh(geometry, material);\r\n+//     scene.add(pointer);\r\n+//     setPointer(pointer);\r\n+//   };\r\n+\r\n+//   const addCanvasEvents = () => {\r\n+//     containerRef.current.addEventListener('mousemove', (e) => {\r\n+//       updateMousePosition(e.clientX, e.clientY);\r\n+//     });\r\n+\r\n+//     containerRef.current.addEventListener('click', (e) => {\r\n+//       if (!dragged) {\r\n+//         updateMousePosition(\r\n+//           e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+//           e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+//         );\r\n+\r\n+//         const res = checkIntersects();\r\n+//         if (res.length) {\r\n+//           const newPointerPos = res[0].face.normal.clone();\r\n+//           setPointerPos(newPointerPos);\r\n+//           pointer.position.set(\r\n+//             newPointerPos.x,\r\n+//             newPointerPos.y,\r\n+//             newPointerPos.z\r\n+//           );\r\n+//           mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+//           popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+//           showPopupAnimation(true);\r\n+//           clock.start();\r\n+//         }\r\n+//       }\r\n+//     });\r\n+//   };\r\n+\r\n+//   const updateMousePosition = (eX, eY) => {\r\n+//     const rect = containerRef.current.getBoundingClientRect();\r\n+//     mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+//     mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+//   };\r\n+\r\n+//   const checkIntersects = () => {\r\n+//     if (!globeMesh) return [];\r\n+//     rayCaster.setFromCamera(mouse, camera);\r\n+//     const intersects = rayCaster.intersectObject(globeMesh);\r\n+//     if (intersects.length) {\r\n+//       document.body.style.cursor = 'pointer';\r\n+//     } else {\r\n+//       document.body.style.cursor = 'auto';\r\n+//     }\r\n+//     return intersects;\r\n+//   };\r\n+\r\n+//   const render = () => {\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+//     }\r\n+//     checkIntersects();\r\n+//     if (pointer) {\r\n+//       updateOverlayGraphic();\r\n+//     }\r\n+//     controls.update();\r\n+//     renderer.render(scene, camera);\r\n+//     requestAnimationFrame(render);\r\n+//   };\r\n+\r\n+//   const updateSize = () => {\r\n+//     if (!renderer) return;\r\n+//     const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+//     containerRef.current.style.width = `${minSide}px`;\r\n+//     containerRef.current.style.height = `${minSide}px`;\r\n+//     renderer.setSize(minSide, minSide);\r\n+//     canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+//     }\r\n+//   };\r\n+\r\n+//   const cartesianToLatLong = (pos) => {\r\n+//     const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+//     const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+//     return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+//       lng,\r\n+//       'E',\r\n+//       'W'\r\n+//     )}`;\r\n+//   };\r\n+\r\n+//   const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+//     const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+//     return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+//   };\r\n+\r\n+//   const createPopupTimelines = () => {\r\n+//     const popupOpenTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, {\r\n+//         duration: 0.2,\r\n+//         opacity: 1,\r\n+//       }, 0)\r\n+//       .fromTo(\r\n+//         canvas2DRef.current,\r\n+//         { opacity: 0 },\r\n+//         { duration: 0.3, opacity: 1 },\r\n+//         0.15\r\n+//       )\r\n+//       .fromTo(\r\n+//         popupRef.current,\r\n+//         { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+//         { duration: 0.1, opacity: 1, scale: 1 },\r\n+//         0.25\r\n+//       );\r\n+//     setPopupOpenTl(popupOpenTl);\r\n+\r\n+//     const popupCloseTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+//       .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+//       .to(popupRef.current, {\r\n+//         duration: 0.3,\r\n+//         opacity: 0,\r\n+//         scale: 0.9,\r\n+//         transformOrigin: 'center bottom',\r\n+//       }, 0);\r\n+//     setPopupCloseTl(popupCloseTl);\r\n+//   };\r\n+\r\n+//   const showPopupAnimation = (lifted) => {\r\n+//     if (lifted) {\r\n+//       let positionLifted = pointer.position.clone();\r\n+//       positionLifted.multiplyScalar(1.3);\r\n+//       gsap.from(pointer.position, {\r\n+//         duration: 0.25,\r\n+//         x: positionLifted.x,\r\n+//         y: positionLifted.y,\r\n+//         z: positionLifted.z,\r\n+//         ease: 'power3.out',\r\n+//       });\r\n+//     }\r\n+//     popupCloseTl.pause(0);\r\n+//     popupOpenTl.play(0);\r\n+//   };\r\n+\r\n+//   const updateOverlayGraphic = () => {\r\n+//     const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+//     let activePointPosition = pointer.position.clone();\r\n+//     activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+//     const activePointPositionProjected = activePointPosition.clone();\r\n+//     activePointPositionProjected.project(camera);\r\n+//     const coordinates2D = [\r\n+//       (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+//       (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+//     ];\r\n+\r\n+//     const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+//     activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+//     if (activePointPosition.z > -1) {\r\n+//       if (!popupVisible) {\r\n+//         setPopupVisible(true);\r\n+//         showPopupAnimation(false);\r\n+//       }\r\n+\r\n+//       let popupX = coordinates2D[0];\r\n+//       popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+//       let popupY = coordinates2D[1];\r\n+//       const upDown = activePointPositionProjected.y > 0.6;\r\n+//       popupY += upDown ? 20 : -20;\r\n+\r\n+//       gsap.set(popupRef.current, {\r\n+//         x: popupX,\r\n+//         y: popupY,\r\n+//         xPercent: -35,\r\n+//         yPercent: upDown ? 0 : -100,\r\n+//       });\r\n+\r\n+//       popupY += upDown ? -5 : 5;\r\n+//       const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+//       const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+//       drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+//     } else {\r\n+//       if (popupVisible) {\r\n+//         popupOpenTl.pause(0);\r\n+//         popupCloseTl.play(0);\r\n+//       }\r\n+//       setPopupVisible(false);\r\n+//     }\r\n+//   };\r\n+\r\n+//   const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+//     ctx.strokeStyle = '#000000';\r\n+//     ctx.lineWidth = 3;\r\n+//     ctx.lineCap = 'round';\r\n+//     ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+//     ctx.beginPath();\r\n+//     ctx.moveTo(startX, startY);\r\n+//     ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+//     ctx.stroke();\r\n+//   };\r\n+\r\n+//   return (\r\n+//     <div className='page'>\r\n+//       {/* <div className='title'>Click to add a pointer</div> */}\r\n+//       <div className='globe-wrapper' ref={containerRef}>\r\n+//         <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+//         <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+//         <div id='globe-popup-overlay'>\r\n+//           <div className='globe-popup' ref={popupRef}></div>\r\n+//         </div>\r\n+//       </div>\r\n+//     </div>\r\n+//   );\r\n+// };\r\n+\r\n+\r\n+// export default Globe;\r\n+\r\n+import React from 'react'\r\n+import three from \"./three/index.html\"\r\n+const Globe = () => {\r\n+  return (\r\n+        <iframe src={three}></iframe>\r\n+    )\r\n+}\r\n+\r\n+export default Globe\n\\ No newline at end of file\n"
                },
                {
                    "date": 1708594019154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,9 +104,9 @@\n //       alpha: true,\r\n //     });\r\n //     renderer.setPixelRatio(window.devicePixelRatio);\r\n //     setRenderer(renderer);\r\n-  \r\n+\r\n //     const camera = new THREE.OrthographicCamera(\r\n //       -1.1,\r\n //       1.1,\r\n //       1.1,\r\n@@ -115,11 +115,11 @@\n //       3\r\n //     );\r\n //     camera.position.z = 1.1;\r\n //     setCamera(camera);\r\n-  \r\n+\r\n //     createOrbitControls(camera, renderer.domElement);\r\n-  \r\n+\r\n //     new THREE.TextureLoader().load(\r\n //       'https://ksenia-k.com/img/earth-map-colored.png',\r\n //       (mapTex) => {\r\n //         setEarthTexture(mapTex);\r\n@@ -132,12 +132,9 @@\n //         render(); // Start the rendering loop\r\n //       }\r\n //     );\r\n //   };\r\n-  \r\n-  \r\n \r\n-\r\n //   const createOrbitControls = (camera, canvas) => {\r\n //     const controls = new OrbitControls(camera, canvas);\r\n //     controls.enablePan = false;\r\n //     controls.enableZoom = false;\r\n@@ -410,843 +407,21 @@\n //     </div>\r\n //   );\r\n // };\r\n \r\n-\r\n // export default Globe;\r\n \r\n-import React from 'react'\r\n-import three from \"./three/index.html\"\r\n-const Globe = () => {\r\n-  return (\r\n-        <iframe src={three}></iframe>\r\n-    )\r\n-}\r\n+import React from \"react\";\r\n \r\n-export default Globe\n-import React, { useEffect, useRef, useState } from 'react';\r\n-import * as THREE from 'three';\r\n-import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n-import { gsap } from 'gsap';\r\n-import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// Vertex shader\r\n-const vertexShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-    uniform float u_dot_size;\r\n-    uniform float u_time_since_click;\r\n-    uniform vec3 u_pointer;\r\n-\r\n-    #define PI 3.14159265359\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vUv = uv;\r\n-\r\n-        // mask with world map\r\n-        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-        gl_PointSize = visibility * u_dot_size;\r\n-\r\n-        // make back dots semi-transparent\r\n-        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-        vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-        // add ripple\r\n-        float t = u_time_since_click - .1;\r\n-        t = max(0., t);\r\n-        float max_amp = .15;\r\n-        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-        delta *= 1. - smoothstep(.8, 1., dist);\r\n-        vec3 pos = position;\r\n-        pos *= (1. + delta);\r\n-\r\n-        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-    }\r\n-`;\r\n-\r\n-// Fragment shader\r\n-const fragmentShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n-        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-        if (dot < 0.5) discard;\r\n-        gl_FragColor = vec4(color, dot * vOpacity);\r\n-    }\r\n-`;\r\n-\r\n const Globe = () => {\r\n-  const containerRef = useRef(null);\r\n-  const canvas3DRef = useRef(null);\r\n-  const canvas2DRef = useRef(null);\r\n-  const popupRef = useRef(null);\r\n-\r\n-  const [renderer, setRenderer] = useState(null);\r\n-  const [scene, setScene] = useState(new THREE.Scene());\r\n-  const [camera, setCamera] = useState(null);\r\n-  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n-  const [controls, setControls] = useState(null);\r\n-  const [pointer, setPointer] = useState(null);\r\n-  const [globe, setGlobe] = useState(null);\r\n-  const [globeMesh, setGlobeMesh] = useState(null);\r\n-  const [mapMaterial, setMapMaterial] = useState(null);\r\n-  const [popupVisible, setPopupVisible] = useState(false);\r\n-  const [pointerPos, setPointerPos] = useState(null);\r\n-  const [clock, setClock] = useState(new THREE.Clock());\r\n-  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-  const [dragged, setDragged] = useState(false);\r\n-  const [earthTexture, setEarthTexture] = useState(null);\r\n-  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-  useEffect(() => {\r\n-    initScene();\r\n-    window.addEventListener('resize', updateSize);\r\n-    return () => {\r\n-      window.removeEventListener('resize', updateSize);\r\n-    };\r\n-  }, []);\r\n-\r\n-  useEffect(() => {\r\n-    if (renderer && scene && camera) {\r\n-      updateSize();\r\n-      render();\r\n-    }\r\n-  }, [renderer, scene, camera]);\r\n-\r\n-  const initScene = () => {\r\n-    const renderer = new THREE.WebGLRenderer({\r\n-      canvas: canvas3DRef.current,\r\n-      alpha: true,\r\n-    });\r\n-    renderer.setPixelRatio(window.devicePixelRatio);\r\n-    setRenderer(renderer);\r\n-  \r\n-    const camera = new THREE.OrthographicCamera(\r\n-      -1.1,\r\n-      1.1,\r\n-      1.1,\r\n-      -1.1,\r\n-      0,\r\n-      3\r\n-    );\r\n-    camera.position.z = 1.1;\r\n-    setCamera(camera);\r\n-  \r\n-    createOrbitControls(camera, renderer.domElement);\r\n-  \r\n-    new THREE.TextureLoader().load(\r\n-      'https://ksenia-k.com/img/earth-map-colored.png',\r\n-      (mapTex) => {\r\n-        setEarthTexture(mapTex);\r\n-        mapTex.repeat.set(1, 1);\r\n-        createGlobe(mapTex);\r\n-        createPointer();\r\n-        createPopupTimelines();\r\n-        addCanvasEvents();\r\n-        updateSize(); // Update the size of the renderer and camera\r\n-        render(); // Start the rendering loop\r\n-      }\r\n-    );\r\n-  };\r\n-  \r\n-  \r\n-\r\n-\r\n-  const createOrbitControls = (camera, canvas) => {\r\n-    const controls = new OrbitControls(camera, canvas);\r\n-    controls.enablePan = false;\r\n-    controls.enableZoom = false;\r\n-    controls.enableDamping = true;\r\n-    controls.minPolarAngle = 0.4 * Math.PI;\r\n-    controls.maxPolarAngle = 0.4 * Math.PI;\r\n-    controls.autoRotate = true;\r\n-\r\n-    let timestamp;\r\n-    controls.addEventListener('start', () => {\r\n-      timestamp = Date.now();\r\n-    });\r\n-    controls.addEventListener('end', () => {\r\n-      setDragged(Date.now() - timestamp > 600);\r\n-    });\r\n-\r\n-    setControls(controls);\r\n-  };\r\n-\r\n-  const createGlobe = (earthTexture) => {\r\n-    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-    const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: vertexShader,\r\n-      fragmentShader: fragmentShader,\r\n-      uniforms: {\r\n-        u_map_tex: { type: 't', value: earthTexture },\r\n-        u_dot_size: { type: 'f', value: 0 },\r\n-        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n-        u_time_since_click: { value: 0 },\r\n-      },\r\n-      alphaTest: false,\r\n-      transparent: true,\r\n-    });\r\n-    setMapMaterial(mapMaterial);\r\n-\r\n-    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-    scene.add(globe);\r\n-    setGlobe(globe);\r\n-\r\n-    const globeMesh = new THREE.Mesh(\r\n-      globeGeometry,\r\n-      new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n-        transparent: true,\r\n-        opacity: 0.05,\r\n-      })\r\n-    );\r\n-    scene.add(globeMesh);\r\n-    setGlobeMesh(globeMesh);\r\n-  };\r\n-\r\n-  const createPointer = () => {\r\n-    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-    const material = new THREE.MeshBasicMaterial({\r\n-      color: 0x000000,\r\n-      transparent: true,\r\n-      opacity: 0,\r\n-    });\r\n-    const pointer = new THREE.Mesh(geometry, material);\r\n-    scene.add(pointer);\r\n-    setPointer(pointer);\r\n-  };\r\n-\r\n-  const addCanvasEvents = () => {\r\n-    containerRef.current.addEventListener('mousemove', (e) => {\r\n-      updateMousePosition(e.clientX, e.clientY);\r\n-    });\r\n-\r\n-    containerRef.current.addEventListener('click', (e) => {\r\n-      if (!dragged) {\r\n-        updateMousePosition(\r\n-          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-        );\r\n-\r\n-        const res = checkIntersects();\r\n-        if (res.length) {\r\n-          const newPointerPos = res[0].face.normal.clone();\r\n-          setPointerPos(newPointerPos);\r\n-          pointer.position.set(\r\n-            newPointerPos.x,\r\n-            newPointerPos.y,\r\n-            newPointerPos.z\r\n-          );\r\n-          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-          showPopupAnimation(true);\r\n-          clock.start();\r\n-        }\r\n-      }\r\n-    });\r\n-  };\r\n-\r\n-  const updateMousePosition = (eX, eY) => {\r\n-    const rect = containerRef.current.getBoundingClientRect();\r\n-    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-  };\r\n-\r\n-  const checkIntersects = () => {\r\n-    if (!globeMesh) return [];\r\n-    rayCaster.setFromCamera(mouse, camera);\r\n-    const intersects = rayCaster.intersectObject(globeMesh);\r\n-    if (intersects.length) {\r\n-      document.body.style.cursor = 'pointer';\r\n-    } else {\r\n-      document.body.style.cursor = 'auto';\r\n-    }\r\n-    return intersects;\r\n-  };\r\n-\r\n-  const render = () => {\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-    }\r\n-    checkIntersects();\r\n-    if (pointer) {\r\n-      updateOverlayGraphic();\r\n-    }\r\n-    controls.update();\r\n-    renderer.render(scene, camera);\r\n-    requestAnimationFrame(render);\r\n-  };\r\n-\r\n-  const updateSize = () => {\r\n-    if (!renderer) return;\r\n-    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-    containerRef.current.style.width = `${minSide}px`;\r\n-    containerRef.current.style.height = `${minSide}px`;\r\n-    renderer.setSize(minSide, minSide);\r\n-    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-    }\r\n-  };\r\n-\r\n-  const cartesianToLatLong = (pos) => {\r\n-    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n-      lng,\r\n-      'E',\r\n-      'W'\r\n-    )}`;\r\n-  };\r\n-\r\n-  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-  };\r\n-\r\n-  const createPopupTimelines = () => {\r\n-    const popupOpenTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, {\r\n-        duration: 0.2,\r\n-        opacity: 1,\r\n-      }, 0)\r\n-      .fromTo(\r\n-        canvas2DRef.current,\r\n-        { opacity: 0 },\r\n-        { duration: 0.3, opacity: 1 },\r\n-        0.15\r\n-      )\r\n-      .fromTo(\r\n-        popupRef.current,\r\n-        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n-        { duration: 0.1, opacity: 1, scale: 1 },\r\n-        0.25\r\n-      );\r\n-    setPopupOpenTl(popupOpenTl);\r\n-\r\n-    const popupCloseTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-      .to(popupRef.current, {\r\n-        duration: 0.3,\r\n-        opacity: 0,\r\n-        scale: 0.9,\r\n-        transformOrigin: 'center bottom',\r\n-      }, 0);\r\n-    setPopupCloseTl(popupCloseTl);\r\n-  };\r\n-\r\n-  const showPopupAnimation = (lifted) => {\r\n-    if (lifted) {\r\n-      let positionLifted = pointer.position.clone();\r\n-      positionLifted.multiplyScalar(1.3);\r\n-      gsap.from(pointer.position, {\r\n-        duration: 0.25,\r\n-        x: positionLifted.x,\r\n-        y: positionLifted.y,\r\n-        z: positionLifted.z,\r\n-        ease: 'power3.out',\r\n-      });\r\n-    }\r\n-    popupCloseTl.pause(0);\r\n-    popupOpenTl.play(0);\r\n-  };\r\n-\r\n-  const updateOverlayGraphic = () => {\r\n-    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n-    let activePointPosition = pointer.position.clone();\r\n-    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-    const activePointPositionProjected = activePointPosition.clone();\r\n-    activePointPositionProjected.project(camera);\r\n-    const coordinates2D = [\r\n-      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-    ];\r\n-\r\n-    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-    if (activePointPosition.z > -1) {\r\n-      if (!popupVisible) {\r\n-        setPopupVisible(true);\r\n-        showPopupAnimation(false);\r\n-      }\r\n-\r\n-      let popupX = coordinates2D[0];\r\n-      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-      let popupY = coordinates2D[1];\r\n-      const upDown = activePointPositionProjected.y > 0.6;\r\n-      popupY += upDown ? 20 : -20;\r\n-\r\n-      gsap.set(popupRef.current, {\r\n-        x: popupX,\r\n-        y: popupY,\r\n-        xPercent: -35,\r\n-        yPercent: upDown ? 0 : -100,\r\n-      });\r\n-\r\n-      popupY += upDown ? -5 : 5;\r\n-      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-    } else {\r\n-      if (popupVisible) {\r\n-        popupOpenTl.pause(0);\r\n-        popupCloseTl.play(0);\r\n-      }\r\n-      setPopupVisible(false);\r\n-    }\r\n-  };\r\n-\r\n-  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-    ctx.strokeStyle = '#000000';\r\n-    ctx.lineWidth = 3;\r\n-    ctx.lineCap = 'round';\r\n-    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-    ctx.beginPath();\r\n-    ctx.moveTo(startX, startY);\r\n-    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-    ctx.stroke();\r\n-  };\r\n-\r\n   return (\r\n-    <div className='page'>\r\n-      {/* <div className='title'>Click to add a pointer</div> */}\r\n-      <div className='globe-wrapper' ref={containerRef}>\r\n-        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n-        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n-        <div id='globe-popup-overlay'>\r\n-          <div className='globe-popup' ref={popupRef}></div>\r\n-        </div>\r\n-      </div>\r\n-    </div>\r\n+    <iframe\r\n+      src={`${process.env.PUBLIC_URL}/three/index.html`}\r\n+      title=\"Three.js Globe\"\r\n+      width=\"100%\"\r\n+      height=\"500px\"\r\n+      style={{ border: \"none\" }}\r\n+    ></iframe>\r\n   );\r\n };\r\n \r\n export default Globe;\r\n-import React, { useEffect, useRef, useState } from 'react';\r\n-import * as THREE from 'three';\r\n-import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n-import { gsap } from 'gsap';\r\n-import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// Vertex shader\r\n-const vertexShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-    uniform float u_dot_size;\r\n-    uniform float u_time_since_click;\r\n-    uniform vec3 u_pointer;\r\n-\r\n-    #define PI 3.14159265359\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vUv = uv;\r\n-\r\n-        // mask with world map\r\n-        float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-        gl_PointSize = visibility * u_dot_size;\r\n-\r\n-        // make back dots semi-transparent\r\n-        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-        vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-        vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-        // add ripple\r\n-        float t = u_time_since_click - .1;\r\n-        t = max(0., t);\r\n-        float max_amp = .15;\r\n-        float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-        float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-        float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-        delta *= 1. - smoothstep(.8, 1., dist);\r\n-        vec3 pos = position;\r\n-        pos *= (1. + delta);\r\n-\r\n-        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-    }\r\n-`;\r\n-\r\n-// Fragment shader\r\n-const fragmentShader = `\r\n-    uniform sampler2D u_map_tex;\r\n-\r\n-    varying float vOpacity;\r\n-    varying vec2 vUv;\r\n-\r\n-    void main() {\r\n-        vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n-        color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-        float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-        if (dot < 0.5) discard;\r\n-        gl_FragColor = vec4(color, dot * vOpacity);\r\n-    }\r\n-`;\r\n-\r\n-const Globe = () => {\r\n-  const containerRef = useRef(null);\r\n-  const canvas3DRef = useRef(null);\r\n-  const canvas2DRef = useRef(null);\r\n-  const popupRef = useRef(null);\r\n-\r\n-  const [renderer, setRenderer] = useState(null);\r\n-  const [scene, setScene] = useState(new THREE.Scene());\r\n-  const [camera, setCamera] = useState(null);\r\n-  const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n-  const [controls, setControls] = useState(null);\r\n-  const [pointer, setPointer] = useState(null);\r\n-  const [globe, setGlobe] = useState(null);\r\n-  const [globeMesh, setGlobeMesh] = useState(null);\r\n-  const [mapMaterial, setMapMaterial] = useState(null);\r\n-  const [popupVisible, setPopupVisible] = useState(false);\r\n-  const [pointerPos, setPointerPos] = useState(null);\r\n-  const [clock, setClock] = useState(new THREE.Clock());\r\n-  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-  const [dragged, setDragged] = useState(false);\r\n-  const [earthTexture, setEarthTexture] = useState(null);\r\n-  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-  useEffect(() => {\r\n-    initScene();\r\n-    window.addEventListener('resize', updateSize);\r\n-    return () => {\r\n-      window.removeEventListener('resize', updateSize);\r\n-    };\r\n-  }, []);\r\n-\r\n-  useEffect(() => {\r\n-    if (renderer && scene && camera) {\r\n-      updateSize();\r\n-      render();\r\n-    }\r\n-  }, [renderer, scene, camera]);\r\n-\r\n-  const initScene = () => {\r\n-    const renderer = new THREE.WebGLRenderer({\r\n-      canvas: canvas3DRef.current,\r\n-      alpha: true,\r\n-    });\r\n-    renderer.setPixelRatio(window.devicePixelRatio);\r\n-    setRenderer(renderer);\r\n-  \r\n-    const camera = new THREE.OrthographicCamera(\r\n-      -1.1,\r\n-      1.1,\r\n-      1.1,\r\n-      -1.1,\r\n-      0,\r\n-      3\r\n-    );\r\n-    camera.position.z = 1.1;\r\n-    setCamera(camera);\r\n-  \r\n-    createOrbitControls(camera, renderer.domElement); // Call this after renderer and camera are set up\r\n-  \r\n-    new THREE.TextureLoader().load(\r\n-      'https://ksenia-k.com/img/earth-map-colored.png',\r\n-      (mapTex) => {\r\n-        setEarthTexture(mapTex);\r\n-        mapTex.repeat.set(1, 1);\r\n-        createGlobe(mapTex);\r\n-        createPointer(); // Ensure this is called before createPopupTimelines\r\n-        createPopupTimelines(); // This should be called after createPointer\r\n-        addCanvasEvents();\r\n-      }\r\n-    );\r\n-  };\r\n-  \r\n-  \r\n-  \r\n-\r\n-\r\n-  const createOrbitControls = (camera, canvas) => {\r\n-    const controls = new OrbitControls(camera, canvas);\r\n-    controls.enablePan = false;\r\n-    controls.enableZoom = false;\r\n-    controls.enableDamping = true;\r\n-    controls.minPolarAngle = 0.4 * Math.PI;\r\n-    controls.maxPolarAngle = 0.4 * Math.PI;\r\n-    controls.autoRotate = true;\r\n-\r\n-    let timestamp;\r\n-    controls.addEventListener('start', () => {\r\n-      timestamp = Date.now();\r\n-    });\r\n-    controls.addEventListener('end', () => {\r\n-      setDragged(Date.now() - timestamp > 600);\r\n-    });\r\n-\r\n-    setControls(controls);\r\n-  };\r\n-\r\n-  const createGlobe = (earthTexture) => {\r\n-    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-    const mapMaterial = new THREE.ShaderMaterial({\r\n-      vertexShader: vertexShader,\r\n-      fragmentShader: fragmentShader,\r\n-      uniforms: {\r\n-        u_map_tex: { type: 't', value: earthTexture },\r\n-        u_dot_size: { type: 'f', value: 0 },\r\n-        u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n-        u_time_since_click: { value: 0 },\r\n-      },\r\n-      alphaTest: false,\r\n-      transparent: true,\r\n-    });\r\n-    setMapMaterial(mapMaterial);\r\n-\r\n-    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-    scene.add(globe);\r\n-    setGlobe(globe);\r\n-\r\n-    const globeMesh = new THREE.Mesh(\r\n-      globeGeometry,\r\n-      new THREE.MeshBasicMaterial({\r\n-        color: 0x222222,\r\n-        transparent: true,\r\n-        opacity: 0.05,\r\n-      })\r\n-    );\r\n-    scene.add(globeMesh);\r\n-    setGlobeMesh(globeMesh);\r\n-  };\r\n-\r\n-  const createPointer = () => {\r\n-    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-    const material = new THREE.MeshBasicMaterial({\r\n-      color: 0x000000,\r\n-      transparent: true,\r\n-      opacity: 0,\r\n-    });\r\n-    const pointer = new THREE.Mesh(geometry, material);\r\n-    scene.add(pointer);\r\n-    setPointer(pointer);\r\n-  };\r\n-\r\n-  const addCanvasEvents = () => {\r\n-    containerRef.current.addEventListener('mousemove', (e) => {\r\n-      updateMousePosition(e.clientX, e.clientY);\r\n-    });\r\n-\r\n-    containerRef.current.addEventListener('click', (e) => {\r\n-      if (!dragged) {\r\n-        updateMousePosition(\r\n-          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-        );\r\n-\r\n-        const res = checkIntersects();\r\n-        if (res.length) {\r\n-          const newPointerPos = res[0].face.normal.clone();\r\n-          setPointerPos(newPointerPos);\r\n-          pointer.position.set(\r\n-            newPointerPos.x,\r\n-            newPointerPos.y,\r\n-            newPointerPos.z\r\n-          );\r\n-          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-          showPopupAnimation(true);\r\n-          clock.start();\r\n-        }\r\n-      }\r\n-    });\r\n-  };\r\n-\r\n-  const updateMousePosition = (eX, eY) => {\r\n-    const rect = containerRef.current.getBoundingClientRect();\r\n-    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-  };\r\n-\r\n-  const checkIntersects = () => {\r\n-    if (!globeMesh) return [];\r\n-    rayCaster.setFromCamera(mouse, camera);\r\n-    const intersects = rayCaster.intersectObject(globeMesh);\r\n-    if (intersects.length) {\r\n-      document.body.style.cursor = 'pointer';\r\n-    } else {\r\n-      document.body.style.cursor = 'auto';\r\n-    }\r\n-    return intersects;\r\n-  };\r\n-\r\n-  const render = () => {\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-    }\r\n-    checkIntersects();\r\n-    if (pointer) {\r\n-      updateOverlayGraphic();\r\n-    }\r\n-    controls.update();\r\n-    renderer.render(scene, camera);\r\n-    requestAnimationFrame(render);\r\n-  };\r\n-\r\n-  const updateSize = () => {\r\n-    if (!renderer) return;\r\n-    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-    containerRef.current.style.width = `${minSide}px`;\r\n-    containerRef.current.style.height = `${minSide}px`;\r\n-    renderer.setSize(minSide, minSide);\r\n-    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-    if (mapMaterial) {\r\n-      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-    }\r\n-  };\r\n-\r\n-  const cartesianToLatLong = (pos) => {\r\n-    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-    return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n-      lng,\r\n-      'E',\r\n-      'W'\r\n-    )}`;\r\n-  };\r\n-\r\n-  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-  };\r\n-\r\n-  const createPopupTimelines = () => {\r\n-    const popupOpenTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, {\r\n-        duration: 0.2,\r\n-        opacity: 1,\r\n-      }, 0)\r\n-      .fromTo(\r\n-        canvas2DRef.current,\r\n-        { opacity: 0 },\r\n-        { duration: 0.3, opacity: 1 },\r\n-        0.15\r\n-      )\r\n-      .fromTo(\r\n-        popupRef.current,\r\n-        { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n-        { duration: 0.1, opacity: 1, scale: 1 },\r\n-        0.25\r\n-      );\r\n-    setPopupOpenTl(popupOpenTl);\r\n-\r\n-    const popupCloseTl = gsap.timeline({ paused: true })\r\n-      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-      .to(popupRef.current, {\r\n-        duration: 0.3,\r\n-        opacity: 0,\r\n-        scale: 0.9,\r\n-        transformOrigin: 'center bottom',\r\n-      }, 0);\r\n-    setPopupCloseTl(popupCloseTl);\r\n-  };\r\n-\r\n-  const showPopupAnimation = (lifted) => {\r\n-    if (lifted) {\r\n-      let positionLifted = pointer.position.clone();\r\n-      positionLifted.multiplyScalar(1.3);\r\n-      gsap.from(pointer.position, {\r\n-        duration: 0.25,\r\n-        x: positionLifted.x,\r\n-        y: positionLifted.y,\r\n-        z: positionLifted.z,\r\n-        ease: 'power3.out',\r\n-      });\r\n-    }\r\n-    popupCloseTl.pause(0);\r\n-    popupOpenTl.play(0);\r\n-  };\r\n-\r\n-  const updateOverlayGraphic = () => {\r\n-    const overlayCtx = canvas2DRef.current.getContext('2d');\r\n-    let activePointPosition = pointer.position.clone();\r\n-    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-    const activePointPositionProjected = activePointPosition.clone();\r\n-    activePointPositionProjected.project(camera);\r\n-    const coordinates2D = [\r\n-      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-    ];\r\n-\r\n-    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-    if (activePointPosition.z > -1) {\r\n-      if (!popupVisible) {\r\n-        setPopupVisible(true);\r\n-        showPopupAnimation(false);\r\n-      }\r\n-\r\n-      let popupX = coordinates2D[0];\r\n-      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-      let popupY = coordinates2D[1];\r\n-      const upDown = activePointPositionProjected.y > 0.6;\r\n-      popupY += upDown ? 20 : -20;\r\n-\r\n-      gsap.set(popupRef.current, {\r\n-        x: popupX,\r\n-        y: popupY,\r\n-        xPercent: -35,\r\n-        yPercent: upDown ? 0 : -100,\r\n-      });\r\n-\r\n-      popupY += upDown ? -5 : 5;\r\n-      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-    } else {\r\n-      if (popupVisible) {\r\n-        popupOpenTl.pause(0);\r\n-        popupCloseTl.play(0);\r\n-      }\r\n-      setPopupVisible(false);\r\n-    }\r\n-  };\r\n-\r\n-  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-    ctx.strokeStyle = '#000000';\r\n-    ctx.lineWidth = 3;\r\n-    ctx.lineCap = 'round';\r\n-    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-    ctx.beginPath();\r\n-    ctx.moveTo(startX, startY);\r\n-    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-    ctx.stroke();\r\n-  };\r\n-\r\n-  return (\r\n-    <div className='page'>\r\n-      {/* <div className='title'>Click to add a pointer</div> */}\r\n-      <div className='globe-wrapper' ref={containerRef}>\r\n-        <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n-        <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n-        <div id='globe-popup-overlay'>\r\n\\ No newline at end of file\n-          <div className='globe-popup' ref={popupRef}></div>\r\n-        </div>\r\n-      </div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default Globe;\n"
                },
                {
                    "date": 1708594164227,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -411,8 +411,9 @@\n // export default Globe;\r\n \r\n import React from \"react\";\r\n \r\n+\r\n const Globe = () => {\r\n   return (\r\n     <iframe\r\n       src={`${process.env.PUBLIC_URL}/three/index.html`}\r\n"
                },
                {
                    "date": 1708594215321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,428 @@\n+// import React, { useEffect, useRef, useState } from 'react';\r\n+// import * as THREE from 'three';\r\n+// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+// import { gsap } from 'gsap';\r\n+// import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// // Vertex shader\r\n+// const vertexShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+//     uniform float u_dot_size;\r\n+//     uniform float u_time_since_click;\r\n+//     uniform vec3 u_pointer;\r\n+\r\n+//     #define PI 3.14159265359\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vUv = uv;\r\n+\r\n+//         // mask with world map\r\n+//         float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+//         gl_PointSize = visibility * u_dot_size;\r\n+\r\n+//         // make back dots semi-transparent\r\n+//         vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+//         vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+//         vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+//         // add ripple\r\n+//         float t = u_time_since_click - .1;\r\n+//         t = max(0., t);\r\n+//         float max_amp = .15;\r\n+//         float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+//         float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+//         float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+//         delta *= 1. - smoothstep(.8, 1., dist);\r\n+//         vec3 pos = position;\r\n+//         pos *= (1. + delta);\r\n+\r\n+//         gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+//     }\r\n+// `;\r\n+\r\n+// // Fragment shader\r\n+// const fragmentShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+//         color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+//         float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+//         if (dot < 0.5) discard;\r\n+//         gl_FragColor = vec4(color, dot * vOpacity);\r\n+//     }\r\n+// `;\r\n+\r\n+// const Globe = () => {\r\n+//   const containerRef = useRef(null);\r\n+//   const canvas3DRef = useRef(null);\r\n+//   const canvas2DRef = useRef(null);\r\n+//   const popupRef = useRef(null);\r\n+\r\n+//   const [renderer, setRenderer] = useState(null);\r\n+//   const [scene, setScene] = useState(new THREE.Scene());\r\n+//   const [camera, setCamera] = useState(null);\r\n+//   const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+//   const [controls, setControls] = useState(null);\r\n+//   const [pointer, setPointer] = useState(null);\r\n+//   const [globe, setGlobe] = useState(null);\r\n+//   const [globeMesh, setGlobeMesh] = useState(null);\r\n+//   const [mapMaterial, setMapMaterial] = useState(null);\r\n+//   const [popupVisible, setPopupVisible] = useState(false);\r\n+//   const [pointerPos, setPointerPos] = useState(null);\r\n+//   const [clock, setClock] = useState(new THREE.Clock());\r\n+//   const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+//   const [dragged, setDragged] = useState(false);\r\n+//   const [earthTexture, setEarthTexture] = useState(null);\r\n+//   const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+//   const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+//   useEffect(() => {\r\n+//     initScene();\r\n+//     window.addEventListener('resize', updateSize);\r\n+//     return () => {\r\n+//       window.removeEventListener('resize', updateSize);\r\n+//     };\r\n+//   }, []);\r\n+\r\n+//   useEffect(() => {\r\n+//     if (renderer && scene && camera) {\r\n+//       updateSize();\r\n+//       render();\r\n+//     }\r\n+//   }, [renderer, scene, camera]);\r\n+\r\n+//   const initScene = () => {\r\n+//     const renderer = new THREE.WebGLRenderer({\r\n+//       canvas: canvas3DRef.current,\r\n+//       alpha: true,\r\n+//     });\r\n+//     renderer.setPixelRatio(window.devicePixelRatio);\r\n+//     setRenderer(renderer);\r\n+\r\n+//     const camera = new THREE.OrthographicCamera(\r\n+//       -1.1,\r\n+//       1.1,\r\n+//       1.1,\r\n+//       -1.1,\r\n+//       0,\r\n+//       3\r\n+//     );\r\n+//     camera.position.z = 1.1;\r\n+//     setCamera(camera);\r\n+\r\n+//     createOrbitControls(camera, renderer.domElement);\r\n+\r\n+//     new THREE.TextureLoader().load(\r\n+//       'https://ksenia-k.com/img/earth-map-colored.png',\r\n+//       (mapTex) => {\r\n+//         setEarthTexture(mapTex);\r\n+//         mapTex.repeat.set(1, 1);\r\n+//         createGlobe(mapTex);\r\n+//         createPointer();\r\n+//         createPopupTimelines();\r\n+//         addCanvasEvents();\r\n+//         updateSize(); // Update the size of the renderer and camera\r\n+//         render(); // Start the rendering loop\r\n+//       }\r\n+//     );\r\n+//   };\r\n+\r\n+//   const createOrbitControls = (camera, canvas) => {\r\n+//     const controls = new OrbitControls(camera, canvas);\r\n+//     controls.enablePan = false;\r\n+//     controls.enableZoom = false;\r\n+//     controls.enableDamping = true;\r\n+//     controls.minPolarAngle = 0.4 * Math.PI;\r\n+//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n+//     controls.autoRotate = true;\r\n+\r\n+//     let timestamp;\r\n+//     controls.addEventListener('start', () => {\r\n+//       timestamp = Date.now();\r\n+//     });\r\n+//     controls.addEventListener('end', () => {\r\n+//       setDragged(Date.now() - timestamp > 600);\r\n+//     });\r\n+\r\n+//     setControls(controls);\r\n+//   };\r\n+\r\n+//   const createGlobe = (earthTexture) => {\r\n+//     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+//     const mapMaterial = new THREE.ShaderMaterial({\r\n+//       vertexShader: vertexShader,\r\n+//       fragmentShader: fragmentShader,\r\n+//       uniforms: {\r\n+//         u_map_tex: { type: 't', value: earthTexture },\r\n+//         u_dot_size: { type: 'f', value: 0 },\r\n+//         u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+//         u_time_since_click: { value: 0 },\r\n+//       },\r\n+//       alphaTest: false,\r\n+//       transparent: true,\r\n+//     });\r\n+//     setMapMaterial(mapMaterial);\r\n+\r\n+//     const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+//     scene.add(globe);\r\n+//     setGlobe(globe);\r\n+\r\n+//     const globeMesh = new THREE.Mesh(\r\n+//       globeGeometry,\r\n+//       new THREE.MeshBasicMaterial({\r\n+//         color: 0x222222,\r\n+//         transparent: true,\r\n+//         opacity: 0.05,\r\n+//       })\r\n+//     );\r\n+//     scene.add(globeMesh);\r\n+//     setGlobeMesh(globeMesh);\r\n+//   };\r\n+\r\n+//   const createPointer = () => {\r\n+//     const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+//     const material = new THREE.MeshBasicMaterial({\r\n+//       color: 0x000000,\r\n+//       transparent: true,\r\n+//       opacity: 0,\r\n+//     });\r\n+//     const pointer = new THREE.Mesh(geometry, material);\r\n+//     scene.add(pointer);\r\n+//     setPointer(pointer);\r\n+//   };\r\n+\r\n+//   const addCanvasEvents = () => {\r\n+//     containerRef.current.addEventListener('mousemove', (e) => {\r\n+//       updateMousePosition(e.clientX, e.clientY);\r\n+//     });\r\n+\r\n+//     containerRef.current.addEventListener('click', (e) => {\r\n+//       if (!dragged) {\r\n+//         updateMousePosition(\r\n+//           e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+//           e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+//         );\r\n+\r\n+//         const res = checkIntersects();\r\n+//         if (res.length) {\r\n+//           const newPointerPos = res[0].face.normal.clone();\r\n+//           setPointerPos(newPointerPos);\r\n+//           pointer.position.set(\r\n+//             newPointerPos.x,\r\n+//             newPointerPos.y,\r\n+//             newPointerPos.z\r\n+//           );\r\n+//           mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+//           popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+//           showPopupAnimation(true);\r\n+//           clock.start();\r\n+//         }\r\n+//       }\r\n+//     });\r\n+//   };\r\n+\r\n+//   const updateMousePosition = (eX, eY) => {\r\n+//     const rect = containerRef.current.getBoundingClientRect();\r\n+//     mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+//     mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+//   };\r\n+\r\n+//   const checkIntersects = () => {\r\n+//     if (!globeMesh) return [];\r\n+//     rayCaster.setFromCamera(mouse, camera);\r\n+//     const intersects = rayCaster.intersectObject(globeMesh);\r\n+//     if (intersects.length) {\r\n+//       document.body.style.cursor = 'pointer';\r\n+//     } else {\r\n+//       document.body.style.cursor = 'auto';\r\n+//     }\r\n+//     return intersects;\r\n+//   };\r\n+\r\n+//   const render = () => {\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+//     }\r\n+//     checkIntersects();\r\n+//     if (pointer) {\r\n+//       updateOverlayGraphic();\r\n+//     }\r\n+//     controls.update();\r\n+//     renderer.render(scene, camera);\r\n+//     requestAnimationFrame(render);\r\n+//   };\r\n+\r\n+//   const updateSize = () => {\r\n+//     if (!renderer) return;\r\n+//     const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+//     containerRef.current.style.width = `${minSide}px`;\r\n+//     containerRef.current.style.height = `${minSide}px`;\r\n+//     renderer.setSize(minSide, minSide);\r\n+//     canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+//     }\r\n+//   };\r\n+\r\n+//   const cartesianToLatLong = (pos) => {\r\n+//     const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+//     const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+//     return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+//       lng,\r\n+//       'E',\r\n+//       'W'\r\n+//     )}`;\r\n+//   };\r\n+\r\n+//   const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+//     const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+//     return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+//   };\r\n+\r\n+//   const createPopupTimelines = () => {\r\n+//     const popupOpenTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, {\r\n+//         duration: 0.2,\r\n+//         opacity: 1,\r\n+//       }, 0)\r\n+//       .fromTo(\r\n+//         canvas2DRef.current,\r\n+//         { opacity: 0 },\r\n+//         { duration: 0.3, opacity: 1 },\r\n+//         0.15\r\n+//       )\r\n+//       .fromTo(\r\n+//         popupRef.current,\r\n+//         { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+//         { duration: 0.1, opacity: 1, scale: 1 },\r\n+//         0.25\r\n+//       );\r\n+//     setPopupOpenTl(popupOpenTl);\r\n+\r\n+//     const popupCloseTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+//       .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+//       .to(popupRef.current, {\r\n+//         duration: 0.3,\r\n+//         opacity: 0,\r\n+//         scale: 0.9,\r\n+//         transformOrigin: 'center bottom',\r\n+//       }, 0);\r\n+//     setPopupCloseTl(popupCloseTl);\r\n+//   };\r\n+\r\n+//   const showPopupAnimation = (lifted) => {\r\n+//     if (lifted) {\r\n+//       let positionLifted = pointer.position.clone();\r\n+//       positionLifted.multiplyScalar(1.3);\r\n+//       gsap.from(pointer.position, {\r\n+//         duration: 0.25,\r\n+//         x: positionLifted.x,\r\n+//         y: positionLifted.y,\r\n+//         z: positionLifted.z,\r\n+//         ease: 'power3.out',\r\n+//       });\r\n+//     }\r\n+//     popupCloseTl.pause(0);\r\n+//     popupOpenTl.play(0);\r\n+//   };\r\n+\r\n+//   const updateOverlayGraphic = () => {\r\n+//     const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+//     let activePointPosition = pointer.position.clone();\r\n+//     activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+//     const activePointPositionProjected = activePointPosition.clone();\r\n+//     activePointPositionProjected.project(camera);\r\n+//     const coordinates2D = [\r\n+//       (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+//       (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+//     ];\r\n+\r\n+//     const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+//     activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+//     if (activePointPosition.z > -1) {\r\n+//       if (!popupVisible) {\r\n+//         setPopupVisible(true);\r\n+//         showPopupAnimation(false);\r\n+//       }\r\n+\r\n+//       let popupX = coordinates2D[0];\r\n+//       popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+//       let popupY = coordinates2D[1];\r\n+//       const upDown = activePointPositionProjected.y > 0.6;\r\n+//       popupY += upDown ? 20 : -20;\r\n+\r\n+//       gsap.set(popupRef.current, {\r\n+//         x: popupX,\r\n+//         y: popupY,\r\n+//         xPercent: -35,\r\n+//         yPercent: upDown ? 0 : -100,\r\n+//       });\r\n+\r\n+//       popupY += upDown ? -5 : 5;\r\n+//       const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+//       const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+//       drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+//     } else {\r\n+//       if (popupVisible) {\r\n+//         popupOpenTl.pause(0);\r\n+//         popupCloseTl.play(0);\r\n+//       }\r\n+//       setPopupVisible(false);\r\n+//     }\r\n+//   };\r\n+\r\n+//   const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+//     ctx.strokeStyle = '#000000';\r\n+//     ctx.lineWidth = 3;\r\n+//     ctx.lineCap = 'round';\r\n+//     ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+//     ctx.beginPath();\r\n+//     ctx.moveTo(startX, startY);\r\n+//     ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+//     ctx.stroke();\r\n+//   };\r\n+\r\n+//   return (\r\n+//     <div className='page'>\r\n+//       {/* <div className='title'>Click to add a pointer</div> */}\r\n+//       <div className='globe-wrapper' ref={containerRef}>\r\n+//         <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+//         <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+//         <div id='globe-popup-overlay'>\r\n+//           <div className='globe-popup' ref={popupRef}></div>\r\n+//         </div>\r\n+//       </div>\r\n+//     </div>\r\n+//   );\r\n+// };\r\n+\r\n+// export default Globe;\r\n+\r\n+import React from \"react\";\r\n+// import '../../public/'\r\n+\r\n+const Globe = () => {\r\n+  return (\r\n+    <iframe\r\n+      src={`../../public/three/index.html`}\r\n+      title=\"Three.js Globe\"\r\n+      width=\"100%\"\r\n+      height=\"500px\"\r\n+      style={{ border: \"none\" }}\r\n+    ></iframe>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n"
                },
                {
                    "date": 1708594235206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -418,439 +418,11 @@\n     <iframe\r\n       src={`../../public/three/index.html`}\r\n       title=\"Three.js Globe\"\r\n       width=\"100%\"\r\n-      height=\"500px\"\r\n+    //   height=\"500px\"\r\n       style={{ border: \"none\" }}\r\n     ></iframe>\r\n   );\r\n };\r\n \r\n export default Globe;\r\n-// import React, { useEffect, useRef, useState } from 'react';\r\n-// import * as THREE from 'three';\r\n-// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n-// import { gsap } from 'gsap';\r\n-// import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// // Vertex shader\r\n-// const vertexShader = `\r\n-//     uniform sampler2D u_map_tex;\r\n-//     uniform float u_dot_size;\r\n-//     uniform float u_time_since_click;\r\n-//     uniform vec3 u_pointer;\r\n-\r\n-//     #define PI 3.14159265359\r\n-\r\n-//     varying float vOpacity;\r\n-//     varying vec2 vUv;\r\n-\r\n-//     void main() {\r\n-//         vUv = uv;\r\n-\r\n-//         // mask with world map\r\n-//         float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-//         gl_PointSize = visibility * u_dot_size;\r\n-\r\n-//         // make back dots semi-transparent\r\n-//         vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-//         vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-//         vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-//         // add ripple\r\n-//         float t = u_time_since_click - .1;\r\n-//         t = max(0., t);\r\n-//         float max_amp = .15;\r\n-//         float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-//         float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-//         float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-//         delta *= 1. - smoothstep(.8, 1., dist);\r\n-//         vec3 pos = position;\r\n-//         pos *= (1. + delta);\r\n-\r\n-//         gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-//     }\r\n-// `;\r\n-\r\n-// // Fragment shader\r\n-// const fragmentShader = `\r\n-//     uniform sampler2D u_map_tex;\r\n-\r\n-//     varying float vOpacity;\r\n-//     varying vec2 vUv;\r\n-\r\n-//     void main() {\r\n-//         vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n-//         color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-//         float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-//         if (dot < 0.5) discard;\r\n-//         gl_FragColor = vec4(color, dot * vOpacity);\r\n-//     }\r\n-// `;\r\n-\r\n-// const Globe = () => {\r\n-//   const containerRef = useRef(null);\r\n-//   const canvas3DRef = useRef(null);\r\n-//   const canvas2DRef = useRef(null);\r\n-//   const popupRef = useRef(null);\r\n-\r\n-//   const [renderer, setRenderer] = useState(null);\r\n-//   const [scene, setScene] = useState(new THREE.Scene());\r\n-//   const [camera, setCamera] = useState(null);\r\n-//   const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n-//   const [controls, setControls] = useState(null);\r\n-//   const [pointer, setPointer] = useState(null);\r\n-//   const [globe, setGlobe] = useState(null);\r\n-//   const [globeMesh, setGlobeMesh] = useState(null);\r\n-//   const [mapMaterial, setMapMaterial] = useState(null);\r\n-//   const [popupVisible, setPopupVisible] = useState(false);\r\n-//   const [pointerPos, setPointerPos] = useState(null);\r\n-//   const [clock, setClock] = useState(new THREE.Clock());\r\n-//   const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-//   const [dragged, setDragged] = useState(false);\r\n-//   const [earthTexture, setEarthTexture] = useState(null);\r\n-//   const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-//   const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-//   useEffect(() => {\r\n-//     initScene();\r\n-//     window.addEventListener('resize', updateSize);\r\n-//     return () => {\r\n-//       window.removeEventListener('resize', updateSize);\r\n-//     };\r\n-//   }, []);\r\n-\r\n-//   useEffect(() => {\r\n-//     if (renderer && scene && camera) {\r\n-//       updateSize();\r\n-//       render();\r\n-//     }\r\n-//   }, [renderer, scene, camera]);\r\n-\r\n-//   const initScene = () => {\r\n-//     const renderer = new THREE.WebGLRenderer({\r\n-//       canvas: canvas3DRef.current,\r\n-//       alpha: true,\r\n-//     });\r\n-//     renderer.setPixelRatio(window.devicePixelRatio);\r\n-//     setRenderer(renderer);\r\n-\r\n-//     const camera = new THREE.OrthographicCamera(\r\n-//       -1.1,\r\n-//       1.1,\r\n-//       1.1,\r\n-//       -1.1,\r\n-//       0,\r\n-//       3\r\n-//     );\r\n-//     camera.position.z = 1.1;\r\n-//     setCamera(camera);\r\n-\r\n-//     createOrbitControls(camera, renderer.domElement);\r\n-\r\n-//     new THREE.TextureLoader().load(\r\n-//       'https://ksenia-k.com/img/earth-map-colored.png',\r\n-//       (mapTex) => {\r\n-//         setEarthTexture(mapTex);\r\n-//         mapTex.repeat.set(1, 1);\r\n-//         createGlobe(mapTex);\r\n-//         createPointer();\r\n-//         createPopupTimelines();\r\n-//         addCanvasEvents();\r\n-//         updateSize(); // Update the size of the renderer and camera\r\n-//         render(); // Start the rendering loop\r\n-//       }\r\n-//     );\r\n-//   };\r\n-\r\n-//   const createOrbitControls = (camera, canvas) => {\r\n-//     const controls = new OrbitControls(camera, canvas);\r\n-//     controls.enablePan = false;\r\n-//     controls.enableZoom = false;\r\n-//     controls.enableDamping = true;\r\n-//     controls.minPolarAngle = 0.4 * Math.PI;\r\n-//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n-//     controls.autoRotate = true;\r\n-\r\n-//     let timestamp;\r\n-//     controls.addEventListener('start', () => {\r\n-//       timestamp = Date.now();\r\n-//     });\r\n-//     controls.addEventListener('end', () => {\r\n-//       setDragged(Date.now() - timestamp > 600);\r\n-//     });\r\n-\r\n-//     setControls(controls);\r\n-//   };\r\n-\r\n-//   const createGlobe = (earthTexture) => {\r\n-//     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-//     const mapMaterial = new THREE.ShaderMaterial({\r\n-//       vertexShader: vertexShader,\r\n-//       fragmentShader: fragmentShader,\r\n-//       uniforms: {\r\n-//         u_map_tex: { type: 't', value: earthTexture },\r\n-//         u_dot_size: { type: 'f', value: 0 },\r\n-//         u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n-//         u_time_since_click: { value: 0 },\r\n-//       },\r\n-//       alphaTest: false,\r\n-//       transparent: true,\r\n-//     });\r\n-//     setMapMaterial(mapMaterial);\r\n-\r\n-//     const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-//     scene.add(globe);\r\n-//     setGlobe(globe);\r\n-\r\n-//     const globeMesh = new THREE.Mesh(\r\n-//       globeGeometry,\r\n-//       new THREE.MeshBasicMaterial({\r\n-//         color: 0x222222,\r\n-//         transparent: true,\r\n-//         opacity: 0.05,\r\n-//       })\r\n-//     );\r\n-//     scene.add(globeMesh);\r\n-//     setGlobeMesh(globeMesh);\r\n-//   };\r\n-\r\n-//   const createPointer = () => {\r\n-//     const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-//     const material = new THREE.MeshBasicMaterial({\r\n-//       color: 0x000000,\r\n-//       transparent: true,\r\n-//       opacity: 0,\r\n-//     });\r\n-//     const pointer = new THREE.Mesh(geometry, material);\r\n-//     scene.add(pointer);\r\n-//     setPointer(pointer);\r\n-//   };\r\n-\r\n-//   const addCanvasEvents = () => {\r\n-//     containerRef.current.addEventListener('mousemove', (e) => {\r\n-//       updateMousePosition(e.clientX, e.clientY);\r\n-//     });\r\n-\r\n-//     containerRef.current.addEventListener('click', (e) => {\r\n-//       if (!dragged) {\r\n-//         updateMousePosition(\r\n-//           e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-//           e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-//         );\r\n-\r\n-//         const res = checkIntersects();\r\n-//         if (res.length) {\r\n-//           const newPointerPos = res[0].face.normal.clone();\r\n-//           setPointerPos(newPointerPos);\r\n-//           pointer.position.set(\r\n-//             newPointerPos.x,\r\n-//             newPointerPos.y,\r\n-//             newPointerPos.z\r\n-//           );\r\n-//           mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-//           popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-//           showPopupAnimation(true);\r\n-//           clock.start();\r\n-//         }\r\n-//       }\r\n-//     });\r\n-//   };\r\n-\r\n-//   const updateMousePosition = (eX, eY) => {\r\n-//     const rect = containerRef.current.getBoundingClientRect();\r\n-//     mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-//     mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-//   };\r\n-\r\n-//   const checkIntersects = () => {\r\n-//     if (!globeMesh) return [];\r\n-//     rayCaster.setFromCamera(mouse, camera);\r\n-//     const intersects = rayCaster.intersectObject(globeMesh);\r\n-//     if (intersects.length) {\r\n-//       document.body.style.cursor = 'pointer';\r\n-//     } else {\r\n-//       document.body.style.cursor = 'auto';\r\n-//     }\r\n-//     return intersects;\r\n-//   };\r\n-\r\n-//   const render = () => {\r\n-//     if (mapMaterial) {\r\n-//       mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-//     }\r\n-//     checkIntersects();\r\n-//     if (pointer) {\r\n-//       updateOverlayGraphic();\r\n-//     }\r\n-//     controls.update();\r\n-//     renderer.render(scene, camera);\r\n-//     requestAnimationFrame(render);\r\n-//   };\r\n-\r\n-//   const updateSize = () => {\r\n-//     if (!renderer) return;\r\n-//     const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-//     containerRef.current.style.width = `${minSide}px`;\r\n-//     containerRef.current.style.height = `${minSide}px`;\r\n-//     renderer.setSize(minSide, minSide);\r\n-//     canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-//     if (mapMaterial) {\r\n-//       mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-//     }\r\n-//   };\r\n-\r\n-//   const cartesianToLatLong = (pos) => {\r\n-//     const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-//     const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-//     return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n-//       lng,\r\n-//       'E',\r\n-//       'W'\r\n-//     )}`;\r\n-//   };\r\n-\r\n-//   const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-//     const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-//     return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-//   };\r\n-\r\n-//   const createPopupTimelines = () => {\r\n-//     const popupOpenTl = gsap.timeline({ paused: true })\r\n-//       .to(pointer.material, {\r\n-//         duration: 0.2,\r\n-//         opacity: 1,\r\n-//       }, 0)\r\n-//       .fromTo(\r\n-//         canvas2DRef.current,\r\n-//         { opacity: 0 },\r\n-//         { duration: 0.3, opacity: 1 },\r\n-//         0.15\r\n-//       )\r\n-//       .fromTo(\r\n-//         popupRef.current,\r\n-//         { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n-//         { duration: 0.1, opacity: 1, scale: 1 },\r\n-//         0.25\r\n-//       );\r\n-//     setPopupOpenTl(popupOpenTl);\r\n-\r\n-//     const popupCloseTl = gsap.timeline({ paused: true })\r\n-//       .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-//       .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-//       .to(popupRef.current, {\r\n-//         duration: 0.3,\r\n-//         opacity: 0,\r\n-//         scale: 0.9,\r\n-//         transformOrigin: 'center bottom',\r\n-//       }, 0);\r\n-//     setPopupCloseTl(popupCloseTl);\r\n-//   };\r\n-\r\n-//   const showPopupAnimation = (lifted) => {\r\n-//     if (lifted) {\r\n-//       let positionLifted = pointer.position.clone();\r\n-//       positionLifted.multiplyScalar(1.3);\r\n-//       gsap.from(pointer.position, {\r\n-//         duration: 0.25,\r\n-//         x: positionLifted.x,\r\n-//         y: positionLifted.y,\r\n-//         z: positionLifted.z,\r\n-//         ease: 'power3.out',\r\n-//       });\r\n-//     }\r\n-//     popupCloseTl.pause(0);\r\n-//     popupOpenTl.play(0);\r\n-//   };\r\n-\r\n-//   const updateOverlayGraphic = () => {\r\n-//     const overlayCtx = canvas2DRef.current.getContext('2d');\r\n-//     let activePointPosition = pointer.position.clone();\r\n-//     activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-//     const activePointPositionProjected = activePointPosition.clone();\r\n-//     activePointPositionProjected.project(camera);\r\n-//     const coordinates2D = [\r\n-//       (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-//       (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-//     ];\r\n-\r\n-//     const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-//     activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-//     if (activePointPosition.z > -1) {\r\n-//       if (!popupVisible) {\r\n-//         setPopupVisible(true);\r\n-//         showPopupAnimation(false);\r\n-//       }\r\n-\r\n-//       let popupX = coordinates2D[0];\r\n-//       popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-//       let popupY = coordinates2D[1];\r\n-//       const upDown = activePointPositionProjected.y > 0.6;\r\n-//       popupY += upDown ? 20 : -20;\r\n-\r\n-//       gsap.set(popupRef.current, {\r\n-//         x: popupX,\r\n-//         y: popupY,\r\n-//         xPercent: -35,\r\n-//         yPercent: upDown ? 0 : -100,\r\n-//       });\r\n-\r\n-//       popupY += upDown ? -5 : 5;\r\n-//       const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-//       const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-//       drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-//     } else {\r\n-//       if (popupVisible) {\r\n-//         popupOpenTl.pause(0);\r\n-//         popupCloseTl.play(0);\r\n-//       }\r\n-//       setPopupVisible(false);\r\n-//     }\r\n-//   };\r\n-\r\n-//   const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-//     ctx.strokeStyle = '#000000';\r\n-//     ctx.lineWidth = 3;\r\n-//     ctx.lineCap = 'round';\r\n-//     ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-//     ctx.beginPath();\r\n-//     ctx.moveTo(startX, startY);\r\n-//     ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-//     ctx.stroke();\r\n-//   };\r\n-\r\n-//   return (\r\n-//     <div className='page'>\r\n-//       {/* <div className='title'>Click to add a pointer</div> */}\r\n-//       <div className='globe-wrapper' ref={containerRef}>\r\n-//         <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n-//         <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n-//         <div id='globe-popup-overlay'>\r\n-//           <div className='globe-popup' ref={popupRef}></div>\r\n-//         </div>\r\n-//       </div>\r\n-//     </div>\r\n-//   );\r\n-// };\r\n-\r\n-// export default Globe;\r\n-\r\n-import React from \"react\";\r\n-\r\n-\r\n-const Globe = () => {\r\n-  return (\r\n-    <iframe\r\n-      src={`${process.env.PUBLIC_URL}/three/index.html`}\r\n-      title=\"Three.js Globe\"\r\n-      width=\"100%\"\r\n-      height=\"500px\"\r\n-      style={{ border: \"none\" }}\r\n-    ></iframe>\r\n-  );\r\n-};\r\n-\r\n-export default Globe;\r\n"
                },
                {
                    "date": 1708594255553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -418,9 +418,9 @@\n     <iframe\r\n       src={`../../public/three/index.html`}\r\n       title=\"Three.js Globe\"\r\n       width=\"100%\"\r\n-    //   height=\"500px\"\r\n+      height=\"70vh\"\r\n       style={{ border: \"none\" }}\r\n     ></iframe>\r\n   );\r\n };\r\n"
                },
                {
                    "date": 1708594267989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -418,9 +418,9 @@\n     <iframe\r\n       src={`../../public/three/index.html`}\r\n       title=\"Three.js Globe\"\r\n       width=\"100%\"\r\n-      height=\"70vh\"\r\n+      height=\"600px\"\r\n       style={{ border: \"none\" }}\r\n     ></iframe>\r\n   );\r\n };\r\n"
                },
                {
                    "date": 1708594286986,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -418,9 +418,9 @@\n     <iframe\r\n       src={`../../public/three/index.html`}\r\n       title=\"Three.js Globe\"\r\n       width=\"100%\"\r\n-      height=\"600px\"\r\n+      height=\"100%\"\r\n       style={{ border: \"none\" }}\r\n     ></iframe>\r\n   );\r\n };\r\n"
                },
                {
                    "date": 1708594370715,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -419,9 +419,9 @@\n       src={`../../public/three/index.html`}\r\n       title=\"Three.js Globe\"\r\n       width=\"100%\"\r\n       height=\"100%\"\r\n-      style={{ border: \"none\" }}\r\n+      style={{ border: \"none\", overflow:\"hidden\" }}\r\n     ></iframe>\r\n   );\r\n };\r\n \r\n"
                },
                {
                    "date": 1708594383079,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -419,9 +419,9 @@\n       src={`../../public/three/index.html`}\r\n       title=\"Three.js Globe\"\r\n       width=\"100%\"\r\n       height=\"100%\"\r\n-      style={{ border: \"none\", overflow:\"hidden\" }}\r\n+      style={{ border: \"none\" }}\r\n     ></iframe>\r\n   );\r\n };\r\n \r\n"
                },
                {
                    "date": 1708594549567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,428 @@\n+// import React, { useEffect, useRef, useState } from 'react';\r\n+// import * as THREE from 'three';\r\n+// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+// import { gsap } from 'gsap';\r\n+// import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// // Vertex shader\r\n+// const vertexShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+//     uniform float u_dot_size;\r\n+//     uniform float u_time_since_click;\r\n+//     uniform vec3 u_pointer;\r\n+\r\n+//     #define PI 3.14159265359\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vUv = uv;\r\n+\r\n+//         // mask with world map\r\n+//         float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+//         gl_PointSize = visibility * u_dot_size;\r\n+\r\n+//         // make back dots semi-transparent\r\n+//         vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+//         vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+//         vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+//         // add ripple\r\n+//         float t = u_time_since_click - .1;\r\n+//         t = max(0., t);\r\n+//         float max_amp = .15;\r\n+//         float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+//         float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+//         float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+//         delta *= 1. - smoothstep(.8, 1., dist);\r\n+//         vec3 pos = position;\r\n+//         pos *= (1. + delta);\r\n+\r\n+//         gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+//     }\r\n+// `;\r\n+\r\n+// // Fragment shader\r\n+// const fragmentShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+//         color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+//         float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+//         if (dot < 0.5) discard;\r\n+//         gl_FragColor = vec4(color, dot * vOpacity);\r\n+//     }\r\n+// `;\r\n+\r\n+// const Globe = () => {\r\n+//   const containerRef = useRef(null);\r\n+//   const canvas3DRef = useRef(null);\r\n+//   const canvas2DRef = useRef(null);\r\n+//   const popupRef = useRef(null);\r\n+\r\n+//   const [renderer, setRenderer] = useState(null);\r\n+//   const [scene, setScene] = useState(new THREE.Scene());\r\n+//   const [camera, setCamera] = useState(null);\r\n+//   const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+//   const [controls, setControls] = useState(null);\r\n+//   const [pointer, setPointer] = useState(null);\r\n+//   const [globe, setGlobe] = useState(null);\r\n+//   const [globeMesh, setGlobeMesh] = useState(null);\r\n+//   const [mapMaterial, setMapMaterial] = useState(null);\r\n+//   const [popupVisible, setPopupVisible] = useState(false);\r\n+//   const [pointerPos, setPointerPos] = useState(null);\r\n+//   const [clock, setClock] = useState(new THREE.Clock());\r\n+//   const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+//   const [dragged, setDragged] = useState(false);\r\n+//   const [earthTexture, setEarthTexture] = useState(null);\r\n+//   const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+//   const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+//   useEffect(() => {\r\n+//     initScene();\r\n+//     window.addEventListener('resize', updateSize);\r\n+//     return () => {\r\n+//       window.removeEventListener('resize', updateSize);\r\n+//     };\r\n+//   }, []);\r\n+\r\n+//   useEffect(() => {\r\n+//     if (renderer && scene && camera) {\r\n+//       updateSize();\r\n+//       render();\r\n+//     }\r\n+//   }, [renderer, scene, camera]);\r\n+\r\n+//   const initScene = () => {\r\n+//     const renderer = new THREE.WebGLRenderer({\r\n+//       canvas: canvas3DRef.current,\r\n+//       alpha: true,\r\n+//     });\r\n+//     renderer.setPixelRatio(window.devicePixelRatio);\r\n+//     setRenderer(renderer);\r\n+\r\n+//     const camera = new THREE.OrthographicCamera(\r\n+//       -1.1,\r\n+//       1.1,\r\n+//       1.1,\r\n+//       -1.1,\r\n+//       0,\r\n+//       3\r\n+//     );\r\n+//     camera.position.z = 1.1;\r\n+//     setCamera(camera);\r\n+\r\n+//     createOrbitControls(camera, renderer.domElement);\r\n+\r\n+//     new THREE.TextureLoader().load(\r\n+//       'https://ksenia-k.com/img/earth-map-colored.png',\r\n+//       (mapTex) => {\r\n+//         setEarthTexture(mapTex);\r\n+//         mapTex.repeat.set(1, 1);\r\n+//         createGlobe(mapTex);\r\n+//         createPointer();\r\n+//         createPopupTimelines();\r\n+//         addCanvasEvents();\r\n+//         updateSize(); // Update the size of the renderer and camera\r\n+//         render(); // Start the rendering loop\r\n+//       }\r\n+//     );\r\n+//   };\r\n+\r\n+//   const createOrbitControls = (camera, canvas) => {\r\n+//     const controls = new OrbitControls(camera, canvas);\r\n+//     controls.enablePan = false;\r\n+//     controls.enableZoom = false;\r\n+//     controls.enableDamping = true;\r\n+//     controls.minPolarAngle = 0.4 * Math.PI;\r\n+//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n+//     controls.autoRotate = true;\r\n+\r\n+//     let timestamp;\r\n+//     controls.addEventListener('start', () => {\r\n+//       timestamp = Date.now();\r\n+//     });\r\n+//     controls.addEventListener('end', () => {\r\n+//       setDragged(Date.now() - timestamp > 600);\r\n+//     });\r\n+\r\n+//     setControls(controls);\r\n+//   };\r\n+\r\n+//   const createGlobe = (earthTexture) => {\r\n+//     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+//     const mapMaterial = new THREE.ShaderMaterial({\r\n+//       vertexShader: vertexShader,\r\n+//       fragmentShader: fragmentShader,\r\n+//       uniforms: {\r\n+//         u_map_tex: { type: 't', value: earthTexture },\r\n+//         u_dot_size: { type: 'f', value: 0 },\r\n+//         u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+//         u_time_since_click: { value: 0 },\r\n+//       },\r\n+//       alphaTest: false,\r\n+//       transparent: true,\r\n+//     });\r\n+//     setMapMaterial(mapMaterial);\r\n+\r\n+//     const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+//     scene.add(globe);\r\n+//     setGlobe(globe);\r\n+\r\n+//     const globeMesh = new THREE.Mesh(\r\n+//       globeGeometry,\r\n+//       new THREE.MeshBasicMaterial({\r\n+//         color: 0x222222,\r\n+//         transparent: true,\r\n+//         opacity: 0.05,\r\n+//       })\r\n+//     );\r\n+//     scene.add(globeMesh);\r\n+//     setGlobeMesh(globeMesh);\r\n+//   };\r\n+\r\n+//   const createPointer = () => {\r\n+//     const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+//     const material = new THREE.MeshBasicMaterial({\r\n+//       color: 0x000000,\r\n+//       transparent: true,\r\n+//       opacity: 0,\r\n+//     });\r\n+//     const pointer = new THREE.Mesh(geometry, material);\r\n+//     scene.add(pointer);\r\n+//     setPointer(pointer);\r\n+//   };\r\n+\r\n+//   const addCanvasEvents = () => {\r\n+//     containerRef.current.addEventListener('mousemove', (e) => {\r\n+//       updateMousePosition(e.clientX, e.clientY);\r\n+//     });\r\n+\r\n+//     containerRef.current.addEventListener('click', (e) => {\r\n+//       if (!dragged) {\r\n+//         updateMousePosition(\r\n+//           e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+//           e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+//         );\r\n+\r\n+//         const res = checkIntersects();\r\n+//         if (res.length) {\r\n+//           const newPointerPos = res[0].face.normal.clone();\r\n+//           setPointerPos(newPointerPos);\r\n+//           pointer.position.set(\r\n+//             newPointerPos.x,\r\n+//             newPointerPos.y,\r\n+//             newPointerPos.z\r\n+//           );\r\n+//           mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+//           popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+//           showPopupAnimation(true);\r\n+//           clock.start();\r\n+//         }\r\n+//       }\r\n+//     });\r\n+//   };\r\n+\r\n+//   const updateMousePosition = (eX, eY) => {\r\n+//     const rect = containerRef.current.getBoundingClientRect();\r\n+//     mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+//     mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+//   };\r\n+\r\n+//   const checkIntersects = () => {\r\n+//     if (!globeMesh) return [];\r\n+//     rayCaster.setFromCamera(mouse, camera);\r\n+//     const intersects = rayCaster.intersectObject(globeMesh);\r\n+//     if (intersects.length) {\r\n+//       document.body.style.cursor = 'pointer';\r\n+//     } else {\r\n+//       document.body.style.cursor = 'auto';\r\n+//     }\r\n+//     return intersects;\r\n+//   };\r\n+\r\n+//   const render = () => {\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+//     }\r\n+//     checkIntersects();\r\n+//     if (pointer) {\r\n+//       updateOverlayGraphic();\r\n+//     }\r\n+//     controls.update();\r\n+//     renderer.render(scene, camera);\r\n+//     requestAnimationFrame(render);\r\n+//   };\r\n+\r\n+//   const updateSize = () => {\r\n+//     if (!renderer) return;\r\n+//     const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+//     containerRef.current.style.width = `${minSide}px`;\r\n+//     containerRef.current.style.height = `${minSide}px`;\r\n+//     renderer.setSize(minSide, minSide);\r\n+//     canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+//     }\r\n+//   };\r\n+\r\n+//   const cartesianToLatLong = (pos) => {\r\n+//     const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+//     const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+//     return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+//       lng,\r\n+//       'E',\r\n+//       'W'\r\n+//     )}`;\r\n+//   };\r\n+\r\n+//   const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+//     const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+//     return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+//   };\r\n+\r\n+//   const createPopupTimelines = () => {\r\n+//     const popupOpenTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, {\r\n+//         duration: 0.2,\r\n+//         opacity: 1,\r\n+//       }, 0)\r\n+//       .fromTo(\r\n+//         canvas2DRef.current,\r\n+//         { opacity: 0 },\r\n+//         { duration: 0.3, opacity: 1 },\r\n+//         0.15\r\n+//       )\r\n+//       .fromTo(\r\n+//         popupRef.current,\r\n+//         { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+//         { duration: 0.1, opacity: 1, scale: 1 },\r\n+//         0.25\r\n+//       );\r\n+//     setPopupOpenTl(popupOpenTl);\r\n+\r\n+//     const popupCloseTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+//       .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+//       .to(popupRef.current, {\r\n+//         duration: 0.3,\r\n+//         opacity: 0,\r\n+//         scale: 0.9,\r\n+//         transformOrigin: 'center bottom',\r\n+//       }, 0);\r\n+//     setPopupCloseTl(popupCloseTl);\r\n+//   };\r\n+\r\n+//   const showPopupAnimation = (lifted) => {\r\n+//     if (lifted) {\r\n+//       let positionLifted = pointer.position.clone();\r\n+//       positionLifted.multiplyScalar(1.3);\r\n+//       gsap.from(pointer.position, {\r\n+//         duration: 0.25,\r\n+//         x: positionLifted.x,\r\n+//         y: positionLifted.y,\r\n+//         z: positionLifted.z,\r\n+//         ease: 'power3.out',\r\n+//       });\r\n+//     }\r\n+//     popupCloseTl.pause(0);\r\n+//     popupOpenTl.play(0);\r\n+//   };\r\n+\r\n+//   const updateOverlayGraphic = () => {\r\n+//     const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+//     let activePointPosition = pointer.position.clone();\r\n+//     activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+//     const activePointPositionProjected = activePointPosition.clone();\r\n+//     activePointPositionProjected.project(camera);\r\n+//     const coordinates2D = [\r\n+//       (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+//       (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+//     ];\r\n+\r\n+//     const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+//     activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+//     if (activePointPosition.z > -1) {\r\n+//       if (!popupVisible) {\r\n+//         setPopupVisible(true);\r\n+//         showPopupAnimation(false);\r\n+//       }\r\n+\r\n+//       let popupX = coordinates2D[0];\r\n+//       popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+//       let popupY = coordinates2D[1];\r\n+//       const upDown = activePointPositionProjected.y > 0.6;\r\n+//       popupY += upDown ? 20 : -20;\r\n+\r\n+//       gsap.set(popupRef.current, {\r\n+//         x: popupX,\r\n+//         y: popupY,\r\n+//         xPercent: -35,\r\n+//         yPercent: upDown ? 0 : -100,\r\n+//       });\r\n+\r\n+//       popupY += upDown ? -5 : 5;\r\n+//       const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+//       const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+//       drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+//     } else {\r\n+//       if (popupVisible) {\r\n+//         popupOpenTl.pause(0);\r\n+//         popupCloseTl.play(0);\r\n+//       }\r\n+//       setPopupVisible(false);\r\n+//     }\r\n+//   };\r\n+\r\n+//   const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+//     ctx.strokeStyle = '#000000';\r\n+//     ctx.lineWidth = 3;\r\n+//     ctx.lineCap = 'round';\r\n+//     ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+//     ctx.beginPath();\r\n+//     ctx.moveTo(startX, startY);\r\n+//     ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+//     ctx.stroke();\r\n+//   };\r\n+\r\n+//   return (\r\n+//     <div className='page'>\r\n+//       {/* <div className='title'>Click to add a pointer</div> */}\r\n+//       <div className='globe-wrapper' ref={containerRef}>\r\n+//         <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+//         <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+//         <div id='globe-popup-overlay'>\r\n+//           <div className='globe-popup' ref={popupRef}></div>\r\n+//         </div>\r\n+//       </div>\r\n+//     </div>\r\n+//   );\r\n+// };\r\n+\r\n+// export default Globe;\r\n+\r\n+import React from \"react\";\r\n+// import '../../public/'\r\n+\r\n+const Globe = () => {\r\n+  return (\r\n+    <iframe\r\n+      src={`../../public/three/index.html`}\r\n+      title=\"Three.js Globe\"\r\n+      width=\"100%\"\r\n+    //   height=\"100%\"\r\n+      style={{ border: \"none\" }}\r\n+    ></iframe>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n"
                },
                {
                    "date": 1708594586991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -418,436 +418,8 @@\n     <iframe\r\n       src={`../../public/three/index.html`}\r\n       title=\"Three.js Globe\"\r\n       width=\"100%\"\r\n-    //   height=\"100%\"\r\n-      style={{ border: \"none\" }}\r\n-    ></iframe>\r\n-  );\r\n-};\r\n-\r\n-export default Globe;\r\n-// import React, { useEffect, useRef, useState } from 'react';\r\n-// import * as THREE from 'three';\r\n-// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n-// import { gsap } from 'gsap';\r\n-// import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n-\r\n-// // Vertex shader\r\n-// const vertexShader = `\r\n-//     uniform sampler2D u_map_tex;\r\n-//     uniform float u_dot_size;\r\n-//     uniform float u_time_since_click;\r\n-//     uniform vec3 u_pointer;\r\n-\r\n-//     #define PI 3.14159265359\r\n-\r\n-//     varying float vOpacity;\r\n-//     varying vec2 vUv;\r\n-\r\n-//     void main() {\r\n-//         vUv = uv;\r\n-\r\n-//         // mask with world map\r\n-//         float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n-//         gl_PointSize = visibility * u_dot_size;\r\n-\r\n-//         // make back dots semi-transparent\r\n-//         vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n-//         vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n-//         vOpacity = clamp(vOpacity, .03, 1.);\r\n-\r\n-//         // add ripple\r\n-//         float t = u_time_since_click - .1;\r\n-//         t = max(0., t);\r\n-//         float max_amp = .15;\r\n-//         float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n-//         float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n-//         float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n-//         delta *= 1. - smoothstep(.8, 1., dist);\r\n-//         vec3 pos = position;\r\n-//         pos *= (1. + delta);\r\n-\r\n-//         gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n-//     }\r\n-// `;\r\n-\r\n-// // Fragment shader\r\n-// const fragmentShader = `\r\n-//     uniform sampler2D u_map_tex;\r\n-\r\n-//     varying float vOpacity;\r\n-//     varying vec2 vUv;\r\n-\r\n-//     void main() {\r\n-//         vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n-//         color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n-//         float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n-//         if (dot < 0.5) discard;\r\n-//         gl_FragColor = vec4(color, dot * vOpacity);\r\n-//     }\r\n-// `;\r\n-\r\n-// const Globe = () => {\r\n-//   const containerRef = useRef(null);\r\n-//   const canvas3DRef = useRef(null);\r\n-//   const canvas2DRef = useRef(null);\r\n-//   const popupRef = useRef(null);\r\n-\r\n-//   const [renderer, setRenderer] = useState(null);\r\n-//   const [scene, setScene] = useState(new THREE.Scene());\r\n-//   const [camera, setCamera] = useState(null);\r\n-//   const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n-//   const [controls, setControls] = useState(null);\r\n-//   const [pointer, setPointer] = useState(null);\r\n-//   const [globe, setGlobe] = useState(null);\r\n-//   const [globeMesh, setGlobeMesh] = useState(null);\r\n-//   const [mapMaterial, setMapMaterial] = useState(null);\r\n-//   const [popupVisible, setPopupVisible] = useState(false);\r\n-//   const [pointerPos, setPointerPos] = useState(null);\r\n-//   const [clock, setClock] = useState(new THREE.Clock());\r\n-//   const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n-//   const [dragged, setDragged] = useState(false);\r\n-//   const [earthTexture, setEarthTexture] = useState(null);\r\n-//   const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n-//   const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n-\r\n-//   useEffect(() => {\r\n-//     initScene();\r\n-//     window.addEventListener('resize', updateSize);\r\n-//     return () => {\r\n-//       window.removeEventListener('resize', updateSize);\r\n-//     };\r\n-//   }, []);\r\n-\r\n-//   useEffect(() => {\r\n-//     if (renderer && scene && camera) {\r\n-//       updateSize();\r\n-//       render();\r\n-//     }\r\n-//   }, [renderer, scene, camera]);\r\n-\r\n-//   const initScene = () => {\r\n-//     const renderer = new THREE.WebGLRenderer({\r\n-//       canvas: canvas3DRef.current,\r\n-//       alpha: true,\r\n-//     });\r\n-//     renderer.setPixelRatio(window.devicePixelRatio);\r\n-//     setRenderer(renderer);\r\n-\r\n-//     const camera = new THREE.OrthographicCamera(\r\n-//       -1.1,\r\n-//       1.1,\r\n-//       1.1,\r\n-//       -1.1,\r\n-//       0,\r\n-//       3\r\n-//     );\r\n-//     camera.position.z = 1.1;\r\n-//     setCamera(camera);\r\n-\r\n-//     createOrbitControls(camera, renderer.domElement);\r\n-\r\n-//     new THREE.TextureLoader().load(\r\n-//       'https://ksenia-k.com/img/earth-map-colored.png',\r\n-//       (mapTex) => {\r\n-//         setEarthTexture(mapTex);\r\n-//         mapTex.repeat.set(1, 1);\r\n-//         createGlobe(mapTex);\r\n-//         createPointer();\r\n-//         createPopupTimelines();\r\n-//         addCanvasEvents();\r\n-//         updateSize(); // Update the size of the renderer and camera\r\n-//         render(); // Start the rendering loop\r\n-//       }\r\n-//     );\r\n-//   };\r\n-\r\n-//   const createOrbitControls = (camera, canvas) => {\r\n-//     const controls = new OrbitControls(camera, canvas);\r\n-//     controls.enablePan = false;\r\n-//     controls.enableZoom = false;\r\n-//     controls.enableDamping = true;\r\n-//     controls.minPolarAngle = 0.4 * Math.PI;\r\n-//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n-//     controls.autoRotate = true;\r\n-\r\n-//     let timestamp;\r\n-//     controls.addEventListener('start', () => {\r\n-//       timestamp = Date.now();\r\n-//     });\r\n-//     controls.addEventListener('end', () => {\r\n-//       setDragged(Date.now() - timestamp > 600);\r\n-//     });\r\n-\r\n-//     setControls(controls);\r\n-//   };\r\n-\r\n-//   const createGlobe = (earthTexture) => {\r\n-//     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n-//     const mapMaterial = new THREE.ShaderMaterial({\r\n-//       vertexShader: vertexShader,\r\n-//       fragmentShader: fragmentShader,\r\n-//       uniforms: {\r\n-//         u_map_tex: { type: 't', value: earthTexture },\r\n-//         u_dot_size: { type: 'f', value: 0 },\r\n-//         u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n-//         u_time_since_click: { value: 0 },\r\n-//       },\r\n-//       alphaTest: false,\r\n-//       transparent: true,\r\n-//     });\r\n-//     setMapMaterial(mapMaterial);\r\n-\r\n-//     const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n-//     scene.add(globe);\r\n-//     setGlobe(globe);\r\n-\r\n-//     const globeMesh = new THREE.Mesh(\r\n-//       globeGeometry,\r\n-//       new THREE.MeshBasicMaterial({\r\n-//         color: 0x222222,\r\n-//         transparent: true,\r\n-//         opacity: 0.05,\r\n-//       })\r\n-//     );\r\n-//     scene.add(globeMesh);\r\n-//     setGlobeMesh(globeMesh);\r\n-//   };\r\n-\r\n-//   const createPointer = () => {\r\n-//     const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n-//     const material = new THREE.MeshBasicMaterial({\r\n-//       color: 0x000000,\r\n-//       transparent: true,\r\n-//       opacity: 0,\r\n-//     });\r\n-//     const pointer = new THREE.Mesh(geometry, material);\r\n-//     scene.add(pointer);\r\n-//     setPointer(pointer);\r\n-//   };\r\n-\r\n-//   const addCanvasEvents = () => {\r\n-//     containerRef.current.addEventListener('mousemove', (e) => {\r\n-//       updateMousePosition(e.clientX, e.clientY);\r\n-//     });\r\n-\r\n-//     containerRef.current.addEventListener('click', (e) => {\r\n-//       if (!dragged) {\r\n-//         updateMousePosition(\r\n-//           e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n-//           e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n-//         );\r\n-\r\n-//         const res = checkIntersects();\r\n-//         if (res.length) {\r\n-//           const newPointerPos = res[0].face.normal.clone();\r\n-//           setPointerPos(newPointerPos);\r\n-//           pointer.position.set(\r\n-//             newPointerPos.x,\r\n-//             newPointerPos.y,\r\n-//             newPointerPos.z\r\n-//           );\r\n-//           mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n-//           popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n-//           showPopupAnimation(true);\r\n-//           clock.start();\r\n-//         }\r\n-//       }\r\n-//     });\r\n-//   };\r\n-\r\n-//   const updateMousePosition = (eX, eY) => {\r\n-//     const rect = containerRef.current.getBoundingClientRect();\r\n-//     mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n-//     mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n-//   };\r\n-\r\n-//   const checkIntersects = () => {\r\n-//     if (!globeMesh) return [];\r\n-//     rayCaster.setFromCamera(mouse, camera);\r\n-//     const intersects = rayCaster.intersectObject(globeMesh);\r\n-//     if (intersects.length) {\r\n-//       document.body.style.cursor = 'pointer';\r\n-//     } else {\r\n-//       document.body.style.cursor = 'auto';\r\n-//     }\r\n-//     return intersects;\r\n-//   };\r\n-\r\n-//   const render = () => {\r\n-//     if (mapMaterial) {\r\n-//       mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n-//     }\r\n-//     checkIntersects();\r\n-//     if (pointer) {\r\n-//       updateOverlayGraphic();\r\n-//     }\r\n-//     controls.update();\r\n-//     renderer.render(scene, camera);\r\n-//     requestAnimationFrame(render);\r\n-//   };\r\n-\r\n-//   const updateSize = () => {\r\n-//     if (!renderer) return;\r\n-//     const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n-//     containerRef.current.style.width = `${minSide}px`;\r\n-//     containerRef.current.style.height = `${minSide}px`;\r\n-//     renderer.setSize(minSide, minSide);\r\n-//     canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n-//     if (mapMaterial) {\r\n-//       mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n-//     }\r\n-//   };\r\n-\r\n-//   const cartesianToLatLong = (pos) => {\r\n-//     const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n-//     const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n-//     return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n-//       lng,\r\n-//       'E',\r\n-//       'W'\r\n-//     )}`;\r\n-//   };\r\n-\r\n-//   const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n-//     const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n-//     return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n-//   };\r\n-\r\n-//   const createPopupTimelines = () => {\r\n-//     const popupOpenTl = gsap.timeline({ paused: true })\r\n-//       .to(pointer.material, {\r\n-//         duration: 0.2,\r\n-//         opacity: 1,\r\n-//       }, 0)\r\n-//       .fromTo(\r\n-//         canvas2DRef.current,\r\n-//         { opacity: 0 },\r\n-//         { duration: 0.3, opacity: 1 },\r\n-//         0.15\r\n-//       )\r\n-//       .fromTo(\r\n-//         popupRef.current,\r\n-//         { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n-//         { duration: 0.1, opacity: 1, scale: 1 },\r\n-//         0.25\r\n-//       );\r\n-//     setPopupOpenTl(popupOpenTl);\r\n-\r\n-//     const popupCloseTl = gsap.timeline({ paused: true })\r\n-//       .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n-//       .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n-//       .to(popupRef.current, {\r\n-//         duration: 0.3,\r\n-//         opacity: 0,\r\n-//         scale: 0.9,\r\n-//         transformOrigin: 'center bottom',\r\n-//       }, 0);\r\n-//     setPopupCloseTl(popupCloseTl);\r\n-//   };\r\n-\r\n-//   const showPopupAnimation = (lifted) => {\r\n-//     if (lifted) {\r\n-//       let positionLifted = pointer.position.clone();\r\n-//       positionLifted.multiplyScalar(1.3);\r\n-//       gsap.from(pointer.position, {\r\n-//         duration: 0.25,\r\n-//         x: positionLifted.x,\r\n-//         y: positionLifted.y,\r\n-//         z: positionLifted.z,\r\n-//         ease: 'power3.out',\r\n-//       });\r\n-//     }\r\n-//     popupCloseTl.pause(0);\r\n-//     popupOpenTl.play(0);\r\n-//   };\r\n-\r\n-//   const updateOverlayGraphic = () => {\r\n-//     const overlayCtx = canvas2DRef.current.getContext('2d');\r\n-//     let activePointPosition = pointer.position.clone();\r\n-//     activePointPosition.applyMatrix4(globe.matrixWorld);\r\n-//     const activePointPositionProjected = activePointPosition.clone();\r\n-//     activePointPositionProjected.project(camera);\r\n-//     const coordinates2D = [\r\n-//       (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n-//       (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n-//     ];\r\n-\r\n-//     const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n-//     activePointPosition.applyMatrix4(matrixWorldInverse);\r\n-\r\n-//     if (activePointPosition.z > -1) {\r\n-//       if (!popupVisible) {\r\n-//         setPopupVisible(true);\r\n-//         showPopupAnimation(false);\r\n-//       }\r\n-\r\n-//       let popupX = coordinates2D[0];\r\n-//       popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n-\r\n-//       let popupY = coordinates2D[1];\r\n-//       const upDown = activePointPositionProjected.y > 0.6;\r\n-//       popupY += upDown ? 20 : -20;\r\n-\r\n-//       gsap.set(popupRef.current, {\r\n-//         x: popupX,\r\n-//         y: popupY,\r\n-//         xPercent: -35,\r\n-//         yPercent: upDown ? 0 : -100,\r\n-//       });\r\n-\r\n-//       popupY += upDown ? -5 : 5;\r\n-//       const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n-//       const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n-\r\n-//       drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n-\r\n-//     } else {\r\n-//       if (popupVisible) {\r\n-//         popupOpenTl.pause(0);\r\n-//         popupCloseTl.play(0);\r\n-//       }\r\n-//       setPopupVisible(false);\r\n-//     }\r\n-//   };\r\n-\r\n-//   const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n-//     ctx.strokeStyle = '#000000';\r\n-//     ctx.lineWidth = 3;\r\n-//     ctx.lineCap = 'round';\r\n-//     ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n-//     ctx.beginPath();\r\n-//     ctx.moveTo(startX, startY);\r\n-//     ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n-//     ctx.stroke();\r\n-//   };\r\n-\r\n-//   return (\r\n-//     <div className='page'>\r\n-//       {/* <div className='title'>Click to add a pointer</div> */}\r\n-//       <div className='globe-wrapper' ref={containerRef}>\r\n-//         <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n-//         <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n-//         <div id='globe-popup-overlay'>\r\n-//           <div className='globe-popup' ref={popupRef}></div>\r\n-//         </div>\r\n-//       </div>\r\n-//     </div>\r\n-//   );\r\n-// };\r\n-\r\n-// export default Globe;\r\n-\r\n-import React from \"react\";\r\n-// import '../../public/'\r\n-\r\n-const Globe = () => {\r\n-  return (\r\n-    <iframe\r\n-      src={`../../public/three/index.html`}\r\n-      title=\"Three.js Globe\"\r\n-      width=\"100%\"\r\n       height=\"100%\"\r\n       style={{ border: \"none\" }}\r\n     ></iframe>\r\n   );\r\n"
                },
                {
                    "date": 1708594913562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -409,20 +409,43 @@\n // };\r\n \r\n // export default Globe;\r\n \r\n-import React from \"react\";\r\n-// import '../../public/'\r\n+// import React from \"react\";\r\n+// // import '../../public/'\r\n \r\n+// const Globe = () => {\r\n+//   return (\r\n+//     <iframe\r\n+//       src={`../../public/three/index.html`}\r\n+//       title=\"Three.js Globe\"\r\n+//       width=\"100%\"\r\n+//       height=\"100%\"\r\n+//       style={{ border: \"none\" }}\r\n+//     ></iframe>\r\n+//   );\r\n+// };\r\n+\r\n+// export default Globe;\r\n+\r\n+import React, { useEffect, useState } from \"react\";\r\n+\r\n const Globe = () => {\r\n+  const [htmlContent, setHtmlContent] = useState(\"\");\r\n+\r\n+  useEffect(() => {\r\n+    // Fetch the HTML content from the file\r\n+    fetch(\"../../public/three/index.html\")\r\n+      .then((response) => response.text())\r\n+      .then((data) => {\r\n+        setHtmlContent(data);\r\n+      });\r\n+  }, []);\r\n   return (\r\n-    <iframe\r\n-      src={`../../public/three/index.html`}\r\n-      title=\"Three.js Globe\"\r\n-      width=\"100%\"\r\n-      height=\"100%\"\r\n-      style={{ border: \"none\" }}\r\n-    ></iframe>\r\n+    <div\r\n+      className=\"globe-container\"\r\n+      dangerouslySetInnerHTML={{ __html: htmlContent }}\r\n+    ></div>\r\n   );\r\n };\r\n \r\n export default Globe;\r\n"
                },
                {
                    "date": 1708595114916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -426,21 +426,34 @@\n // };\r\n \r\n // export default Globe;\r\n \r\n-import React, { useEffect, useState } from \"react\";\r\n+import React, { useState, useEffect } from 'react';\r\n \r\n const Globe = () => {\r\n-  const [htmlContent, setHtmlContent] = useState(\"\");\r\n+  const [htmlContent, setHtmlContent] = useState('');\r\n \r\n   useEffect(() => {\r\n-    // Fetch the HTML content from the file\r\n-    fetch(\"../../public/three/index.html\")\r\n+    fetch('../../public/three/index.html')\r\n       .then((response) => response.text())\r\n       .then((data) => {\r\n         setHtmlContent(data);\r\n+        executeScripts(data);\r\n       });\r\n   }, []);\r\n+\r\n+  const executeScripts = (html) => {\r\n+    const parser = new DOMParser();\r\n+    const doc = parser.parseFromString(html, 'text/html');\r\n+    const scripts = doc.querySelectorAll('script');\r\n+    scripts.forEach((script) => {\r\n+      const newScript = document.createElement('script');\r\n+      newScript.text = script.text;\r\n+      document.body.appendChild(newScript);\r\n+      document.body.removeChild(newScript);\r\n+    });\r\n+  };\r\n+\r\n   return (\r\n     <div\r\n       className=\"globe-container\"\r\n       dangerouslySetInnerHTML={{ __html: htmlContent }}\r\n@@ -448,4 +461,5 @@\n   );\r\n };\r\n \r\n export default Globe;\r\n+\r\n"
                },
                {
                    "date": 1708595160004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -409,57 +409,57 @@\n // };\r\n \r\n // export default Globe;\r\n \r\n-// import React from \"react\";\r\n-// // import '../../public/'\r\n+import React from \"react\";\r\n+// import '../../public/'\r\n \r\n-// const Globe = () => {\r\n-//   return (\r\n-//     <iframe\r\n-//       src={`../../public/three/index.html`}\r\n-//       title=\"Three.js Globe\"\r\n-//       width=\"100%\"\r\n-//       height=\"100%\"\r\n-//       style={{ border: \"none\" }}\r\n-//     ></iframe>\r\n-//   );\r\n-// };\r\n+const Globe = () => {\r\n+  return (\r\n+    <iframe\r\n+      src={`../../public/three/index.html`}\r\n+      title=\"Three.js Globe\"\r\n+      width=\"100%\"\r\n+      height=\"100%\"\r\n+      style={{ border: \"none\" }}\r\n+    ></iframe>\r\n+  );\r\n+};\r\n \r\n-// export default Globe;\r\n+export default Globe;\r\n \r\n-import React, { useState, useEffect } from 'react';\r\n+// import React, { useState, useEffect } from 'react';\r\n \r\n-const Globe = () => {\r\n-  const [htmlContent, setHtmlContent] = useState('');\r\n+// const Globe = () => {\r\n+//   const [htmlContent, setHtmlContent] = useState('');\r\n \r\n-  useEffect(() => {\r\n-    fetch('../../public/three/index.html')\r\n-      .then((response) => response.text())\r\n-      .then((data) => {\r\n-        setHtmlContent(data);\r\n-        executeScripts(data);\r\n-      });\r\n-  }, []);\r\n+//   useEffect(() => {\r\n+//     fetch('../../public/three/index.html')\r\n+//       .then((response) => response.text())\r\n+//       .then((data) => {\r\n+//         setHtmlContent(data);\r\n+//         executeScripts(data);\r\n+//       });\r\n+//   }, []);\r\n \r\n-  const executeScripts = (html) => {\r\n-    const parser = new DOMParser();\r\n-    const doc = parser.parseFromString(html, 'text/html');\r\n-    const scripts = doc.querySelectorAll('script');\r\n-    scripts.forEach((script) => {\r\n-      const newScript = document.createElement('script');\r\n-      newScript.text = script.text;\r\n-      document.body.appendChild(newScript);\r\n-      document.body.removeChild(newScript);\r\n-    });\r\n-  };\r\n+//   const executeScripts = (html) => {\r\n+//     const parser = new DOMParser();\r\n+//     const doc = parser.parseFromString(html, 'text/html');\r\n+//     const scripts = doc.querySelectorAll('script');\r\n+//     scripts.forEach((script) => {\r\n+//       const newScript = document.createElement('script');\r\n+//       newScript.text = script.text;\r\n+//       document.body.appendChild(newScript);\r\n+//       document.body.removeChild(newScript);\r\n+//     });\r\n+//   };\r\n \r\n-  return (\r\n-    <div\r\n-      className=\"globe-container\"\r\n-      dangerouslySetInnerHTML={{ __html: htmlContent }}\r\n-    ></div>\r\n-  );\r\n-};\r\n+//   return (\r\n+//     <div\r\n+//       className=\"globe-container\"\r\n+//       dangerouslySetInnerHTML={{ __html: htmlContent }}\r\n+//     ></div>\r\n+//   );\r\n+// };\r\n \r\n-export default Globe;\r\n+// export default Globe;\r\n \r\n"
                },
                {
                    "date": 1708595200029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -419,9 +419,9 @@\n       src={`../../public/three/index.html`}\r\n       title=\"Three.js Globe\"\r\n       width=\"100%\"\r\n       height=\"100%\"\r\n-      style={{ border: \"none\" }}\r\n+      style={{ border: \"none\", overflow: \"hidden\" }}\r\n     ></iframe>\r\n   );\r\n };\r\n \r\n"
                },
                {
                    "date": 1708595364828,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,465 @@\n+// import React, { useEffect, useRef, useState } from 'react';\r\n+// import * as THREE from 'three';\r\n+// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+// import { gsap } from 'gsap';\r\n+// import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// // Vertex shader\r\n+// const vertexShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+//     uniform float u_dot_size;\r\n+//     uniform float u_time_since_click;\r\n+//     uniform vec3 u_pointer;\r\n+\r\n+//     #define PI 3.14159265359\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vUv = uv;\r\n+\r\n+//         // mask with world map\r\n+//         float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+//         gl_PointSize = visibility * u_dot_size;\r\n+\r\n+//         // make back dots semi-transparent\r\n+//         vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+//         vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+//         vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+//         // add ripple\r\n+//         float t = u_time_since_click - .1;\r\n+//         t = max(0., t);\r\n+//         float max_amp = .15;\r\n+//         float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+//         float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+//         float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+//         delta *= 1. - smoothstep(.8, 1., dist);\r\n+//         vec3 pos = position;\r\n+//         pos *= (1. + delta);\r\n+\r\n+//         gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+//     }\r\n+// `;\r\n+\r\n+// // Fragment shader\r\n+// const fragmentShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+//         color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+//         float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+//         if (dot < 0.5) discard;\r\n+//         gl_FragColor = vec4(color, dot * vOpacity);\r\n+//     }\r\n+// `;\r\n+\r\n+// const Globe = () => {\r\n+//   const containerRef = useRef(null);\r\n+//   const canvas3DRef = useRef(null);\r\n+//   const canvas2DRef = useRef(null);\r\n+//   const popupRef = useRef(null);\r\n+\r\n+//   const [renderer, setRenderer] = useState(null);\r\n+//   const [scene, setScene] = useState(new THREE.Scene());\r\n+//   const [camera, setCamera] = useState(null);\r\n+//   const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+//   const [controls, setControls] = useState(null);\r\n+//   const [pointer, setPointer] = useState(null);\r\n+//   const [globe, setGlobe] = useState(null);\r\n+//   const [globeMesh, setGlobeMesh] = useState(null);\r\n+//   const [mapMaterial, setMapMaterial] = useState(null);\r\n+//   const [popupVisible, setPopupVisible] = useState(false);\r\n+//   const [pointerPos, setPointerPos] = useState(null);\r\n+//   const [clock, setClock] = useState(new THREE.Clock());\r\n+//   const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+//   const [dragged, setDragged] = useState(false);\r\n+//   const [earthTexture, setEarthTexture] = useState(null);\r\n+//   const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+//   const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+//   useEffect(() => {\r\n+//     initScene();\r\n+//     window.addEventListener('resize', updateSize);\r\n+//     return () => {\r\n+//       window.removeEventListener('resize', updateSize);\r\n+//     };\r\n+//   }, []);\r\n+\r\n+//   useEffect(() => {\r\n+//     if (renderer && scene && camera) {\r\n+//       updateSize();\r\n+//       render();\r\n+//     }\r\n+//   }, [renderer, scene, camera]);\r\n+\r\n+//   const initScene = () => {\r\n+//     const renderer = new THREE.WebGLRenderer({\r\n+//       canvas: canvas3DRef.current,\r\n+//       alpha: true,\r\n+//     });\r\n+//     renderer.setPixelRatio(window.devicePixelRatio);\r\n+//     setRenderer(renderer);\r\n+\r\n+//     const camera = new THREE.OrthographicCamera(\r\n+//       -1.1,\r\n+//       1.1,\r\n+//       1.1,\r\n+//       -1.1,\r\n+//       0,\r\n+//       3\r\n+//     );\r\n+//     camera.position.z = 1.1;\r\n+//     setCamera(camera);\r\n+\r\n+//     createOrbitControls(camera, renderer.domElement);\r\n+\r\n+//     new THREE.TextureLoader().load(\r\n+//       'https://ksenia-k.com/img/earth-map-colored.png',\r\n+//       (mapTex) => {\r\n+//         setEarthTexture(mapTex);\r\n+//         mapTex.repeat.set(1, 1);\r\n+//         createGlobe(mapTex);\r\n+//         createPointer();\r\n+//         createPopupTimelines();\r\n+//         addCanvasEvents();\r\n+//         updateSize(); // Update the size of the renderer and camera\r\n+//         render(); // Start the rendering loop\r\n+//       }\r\n+//     );\r\n+//   };\r\n+\r\n+//   const createOrbitControls = (camera, canvas) => {\r\n+//     const controls = new OrbitControls(camera, canvas);\r\n+//     controls.enablePan = false;\r\n+//     controls.enableZoom = false;\r\n+//     controls.enableDamping = true;\r\n+//     controls.minPolarAngle = 0.4 * Math.PI;\r\n+//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n+//     controls.autoRotate = true;\r\n+\r\n+//     let timestamp;\r\n+//     controls.addEventListener('start', () => {\r\n+//       timestamp = Date.now();\r\n+//     });\r\n+//     controls.addEventListener('end', () => {\r\n+//       setDragged(Date.now() - timestamp > 600);\r\n+//     });\r\n+\r\n+//     setControls(controls);\r\n+//   };\r\n+\r\n+//   const createGlobe = (earthTexture) => {\r\n+//     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+//     const mapMaterial = new THREE.ShaderMaterial({\r\n+//       vertexShader: vertexShader,\r\n+//       fragmentShader: fragmentShader,\r\n+//       uniforms: {\r\n+//         u_map_tex: { type: 't', value: earthTexture },\r\n+//         u_dot_size: { type: 'f', value: 0 },\r\n+//         u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+//         u_time_since_click: { value: 0 },\r\n+//       },\r\n+//       alphaTest: false,\r\n+//       transparent: true,\r\n+//     });\r\n+//     setMapMaterial(mapMaterial);\r\n+\r\n+//     const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+//     scene.add(globe);\r\n+//     setGlobe(globe);\r\n+\r\n+//     const globeMesh = new THREE.Mesh(\r\n+//       globeGeometry,\r\n+//       new THREE.MeshBasicMaterial({\r\n+//         color: 0x222222,\r\n+//         transparent: true,\r\n+//         opacity: 0.05,\r\n+//       })\r\n+//     );\r\n+//     scene.add(globeMesh);\r\n+//     setGlobeMesh(globeMesh);\r\n+//   };\r\n+\r\n+//   const createPointer = () => {\r\n+//     const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+//     const material = new THREE.MeshBasicMaterial({\r\n+//       color: 0x000000,\r\n+//       transparent: true,\r\n+//       opacity: 0,\r\n+//     });\r\n+//     const pointer = new THREE.Mesh(geometry, material);\r\n+//     scene.add(pointer);\r\n+//     setPointer(pointer);\r\n+//   };\r\n+\r\n+//   const addCanvasEvents = () => {\r\n+//     containerRef.current.addEventListener('mousemove', (e) => {\r\n+//       updateMousePosition(e.clientX, e.clientY);\r\n+//     });\r\n+\r\n+//     containerRef.current.addEventListener('click', (e) => {\r\n+//       if (!dragged) {\r\n+//         updateMousePosition(\r\n+//           e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+//           e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+//         );\r\n+\r\n+//         const res = checkIntersects();\r\n+//         if (res.length) {\r\n+//           const newPointerPos = res[0].face.normal.clone();\r\n+//           setPointerPos(newPointerPos);\r\n+//           pointer.position.set(\r\n+//             newPointerPos.x,\r\n+//             newPointerPos.y,\r\n+//             newPointerPos.z\r\n+//           );\r\n+//           mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+//           popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+//           showPopupAnimation(true);\r\n+//           clock.start();\r\n+//         }\r\n+//       }\r\n+//     });\r\n+//   };\r\n+\r\n+//   const updateMousePosition = (eX, eY) => {\r\n+//     const rect = containerRef.current.getBoundingClientRect();\r\n+//     mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+//     mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+//   };\r\n+\r\n+//   const checkIntersects = () => {\r\n+//     if (!globeMesh) return [];\r\n+//     rayCaster.setFromCamera(mouse, camera);\r\n+//     const intersects = rayCaster.intersectObject(globeMesh);\r\n+//     if (intersects.length) {\r\n+//       document.body.style.cursor = 'pointer';\r\n+//     } else {\r\n+//       document.body.style.cursor = 'auto';\r\n+//     }\r\n+//     return intersects;\r\n+//   };\r\n+\r\n+//   const render = () => {\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+//     }\r\n+//     checkIntersects();\r\n+//     if (pointer) {\r\n+//       updateOverlayGraphic();\r\n+//     }\r\n+//     controls.update();\r\n+//     renderer.render(scene, camera);\r\n+//     requestAnimationFrame(render);\r\n+//   };\r\n+\r\n+//   const updateSize = () => {\r\n+//     if (!renderer) return;\r\n+//     const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+//     containerRef.current.style.width = `${minSide}px`;\r\n+//     containerRef.current.style.height = `${minSide}px`;\r\n+//     renderer.setSize(minSide, minSide);\r\n+//     canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+//     }\r\n+//   };\r\n+\r\n+//   const cartesianToLatLong = (pos) => {\r\n+//     const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+//     const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+//     return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+//       lng,\r\n+//       'E',\r\n+//       'W'\r\n+//     )}`;\r\n+//   };\r\n+\r\n+//   const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+//     const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+//     return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+//   };\r\n+\r\n+//   const createPopupTimelines = () => {\r\n+//     const popupOpenTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, {\r\n+//         duration: 0.2,\r\n+//         opacity: 1,\r\n+//       }, 0)\r\n+//       .fromTo(\r\n+//         canvas2DRef.current,\r\n+//         { opacity: 0 },\r\n+//         { duration: 0.3, opacity: 1 },\r\n+//         0.15\r\n+//       )\r\n+//       .fromTo(\r\n+//         popupRef.current,\r\n+//         { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+//         { duration: 0.1, opacity: 1, scale: 1 },\r\n+//         0.25\r\n+//       );\r\n+//     setPopupOpenTl(popupOpenTl);\r\n+\r\n+//     const popupCloseTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+//       .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+//       .to(popupRef.current, {\r\n+//         duration: 0.3,\r\n+//         opacity: 0,\r\n+//         scale: 0.9,\r\n+//         transformOrigin: 'center bottom',\r\n+//       }, 0);\r\n+//     setPopupCloseTl(popupCloseTl);\r\n+//   };\r\n+\r\n+//   const showPopupAnimation = (lifted) => {\r\n+//     if (lifted) {\r\n+//       let positionLifted = pointer.position.clone();\r\n+//       positionLifted.multiplyScalar(1.3);\r\n+//       gsap.from(pointer.position, {\r\n+//         duration: 0.25,\r\n+//         x: positionLifted.x,\r\n+//         y: positionLifted.y,\r\n+//         z: positionLifted.z,\r\n+//         ease: 'power3.out',\r\n+//       });\r\n+//     }\r\n+//     popupCloseTl.pause(0);\r\n+//     popupOpenTl.play(0);\r\n+//   };\r\n+\r\n+//   const updateOverlayGraphic = () => {\r\n+//     const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+//     let activePointPosition = pointer.position.clone();\r\n+//     activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+//     const activePointPositionProjected = activePointPosition.clone();\r\n+//     activePointPositionProjected.project(camera);\r\n+//     const coordinates2D = [\r\n+//       (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+//       (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+//     ];\r\n+\r\n+//     const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+//     activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+//     if (activePointPosition.z > -1) {\r\n+//       if (!popupVisible) {\r\n+//         setPopupVisible(true);\r\n+//         showPopupAnimation(false);\r\n+//       }\r\n+\r\n+//       let popupX = coordinates2D[0];\r\n+//       popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+//       let popupY = coordinates2D[1];\r\n+//       const upDown = activePointPositionProjected.y > 0.6;\r\n+//       popupY += upDown ? 20 : -20;\r\n+\r\n+//       gsap.set(popupRef.current, {\r\n+//         x: popupX,\r\n+//         y: popupY,\r\n+//         xPercent: -35,\r\n+//         yPercent: upDown ? 0 : -100,\r\n+//       });\r\n+\r\n+//       popupY += upDown ? -5 : 5;\r\n+//       const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+//       const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+//       drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+//     } else {\r\n+//       if (popupVisible) {\r\n+//         popupOpenTl.pause(0);\r\n+//         popupCloseTl.play(0);\r\n+//       }\r\n+//       setPopupVisible(false);\r\n+//     }\r\n+//   };\r\n+\r\n+//   const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+//     ctx.strokeStyle = '#000000';\r\n+//     ctx.lineWidth = 3;\r\n+//     ctx.lineCap = 'round';\r\n+//     ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+//     ctx.beginPath();\r\n+//     ctx.moveTo(startX, startY);\r\n+//     ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+//     ctx.stroke();\r\n+//   };\r\n+\r\n+//   return (\r\n+//     <div className='page'>\r\n+//       {/* <div className='title'>Click to add a pointer</div> */}\r\n+//       <div className='globe-wrapper' ref={containerRef}>\r\n+//         <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+//         <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+//         <div id='globe-popup-overlay'>\r\n+//           <div className='globe-popup' ref={popupRef}></div>\r\n+//         </div>\r\n+//       </div>\r\n+//     </div>\r\n+//   );\r\n+// };\r\n+\r\n+// export default Globe;\r\n+\r\n+import React from \"react\";\r\n+// import '../../public/'\r\n+\r\n+const Globe = () => {\r\n+  return (\r\n+    <iframe\r\n+      src={`../../public/three/index.html`}\r\n+      title=\"Three.js Globe\"\r\n+      width=\"100%\"\r\n+      height=\"80%\"\r\n+      style={{ border: \"none\", overflow: \"hidden\" }}\r\n+    ></iframe>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n+\r\n+// import React, { useState, useEffect } from 'react';\r\n+\r\n+// const Globe = () => {\r\n+//   const [htmlContent, setHtmlContent] = useState('');\r\n+\r\n+//   useEffect(() => {\r\n+//     fetch('../../public/three/index.html')\r\n+//       .then((response) => response.text())\r\n+//       .then((data) => {\r\n+//         setHtmlContent(data);\r\n+//         executeScripts(data);\r\n+//       });\r\n+//   }, []);\r\n+\r\n+//   const executeScripts = (html) => {\r\n+//     const parser = new DOMParser();\r\n+//     const doc = parser.parseFromString(html, 'text/html');\r\n+//     const scripts = doc.querySelectorAll('script');\r\n+//     scripts.forEach((script) => {\r\n+//       const newScript = document.createElement('script');\r\n+//       newScript.text = script.text;\r\n+//       document.body.appendChild(newScript);\r\n+//       document.body.removeChild(newScript);\r\n+//     });\r\n+//   };\r\n+\r\n+//   return (\r\n+//     <div\r\n+//       className=\"globe-container\"\r\n+//       dangerouslySetInnerHTML={{ __html: htmlContent }}\r\n+//     ></div>\r\n+//   );\r\n+// };\r\n+\r\n+// export default Globe;\r\n+\r\n"
                },
                {
                    "date": 1708595476673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,465 @@\n+// import React, { useEffect, useRef, useState } from 'react';\r\n+// import * as THREE from 'three';\r\n+// import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\n+// import { gsap } from 'gsap';\r\n+// import './Globe.css'; // Assuming you've moved the CSS to a separate file\r\n+\r\n+// // Vertex shader\r\n+// const vertexShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+//     uniform float u_dot_size;\r\n+//     uniform float u_time_since_click;\r\n+//     uniform vec3 u_pointer;\r\n+\r\n+//     #define PI 3.14159265359\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vUv = uv;\r\n+\r\n+//         // mask with world map\r\n+//         float visibility = step(.2, texture2D(u_map_tex, uv).r);\r\n+//         gl_PointSize = visibility * u_dot_size;\r\n+\r\n+//         // make back dots semi-transparent\r\n+//         vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n+//         vOpacity = (1. / length(mvPosition.xyz) - .7);\r\n+//         vOpacity = clamp(vOpacity, .03, 1.);\r\n+\r\n+//         // add ripple\r\n+//         float t = u_time_since_click - .1;\r\n+//         t = max(0., t);\r\n+//         float max_amp = .15;\r\n+//         float dist = 1. - .5 * length(position - u_pointer); // 0 .. 1\r\n+//         float damping = 1. / (1. + 20. * t); // 1 .. 0\r\n+//         float delta = max_amp * damping * sin(5. * t * (1. + 2. * dist) - PI);\r\n+//         delta *= 1. - smoothstep(.8, 1., dist);\r\n+//         vec3 pos = position;\r\n+//         pos *= (1. + delta);\r\n+\r\n+//         gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\r\n+//     }\r\n+// `;\r\n+\r\n+// // Fragment shader\r\n+// const fragmentShader = `\r\n+//     uniform sampler2D u_map_tex;\r\n+\r\n+//     varying float vOpacity;\r\n+//     varying vec2 vUv;\r\n+\r\n+//     void main() {\r\n+//         vec3 color = texture2D(u_map_tex, vUv).rgb;\r\n+//         color -= .2 * length(gl_PointCoord.xy - vec2(.5));\r\n+//         float dot = 1. - smoothstep(.38, .4, length(gl_PointCoord.xy - vec2(.5)));\r\n+//         if (dot < 0.5) discard;\r\n+//         gl_FragColor = vec4(color, dot * vOpacity);\r\n+//     }\r\n+// `;\r\n+\r\n+// const Globe = () => {\r\n+//   const containerRef = useRef(null);\r\n+//   const canvas3DRef = useRef(null);\r\n+//   const canvas2DRef = useRef(null);\r\n+//   const popupRef = useRef(null);\r\n+\r\n+//   const [renderer, setRenderer] = useState(null);\r\n+//   const [scene, setScene] = useState(new THREE.Scene());\r\n+//   const [camera, setCamera] = useState(null);\r\n+//   const [rayCaster, setRayCaster] = useState(new THREE.Raycaster());\r\n+//   const [controls, setControls] = useState(null);\r\n+//   const [pointer, setPointer] = useState(null);\r\n+//   const [globe, setGlobe] = useState(null);\r\n+//   const [globeMesh, setGlobeMesh] = useState(null);\r\n+//   const [mapMaterial, setMapMaterial] = useState(null);\r\n+//   const [popupVisible, setPopupVisible] = useState(false);\r\n+//   const [pointerPos, setPointerPos] = useState(null);\r\n+//   const [clock, setClock] = useState(new THREE.Clock());\r\n+//   const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n+//   const [dragged, setDragged] = useState(false);\r\n+//   const [earthTexture, setEarthTexture] = useState(null);\r\n+//   const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n+//   const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n+\r\n+//   useEffect(() => {\r\n+//     initScene();\r\n+//     window.addEventListener('resize', updateSize);\r\n+//     return () => {\r\n+//       window.removeEventListener('resize', updateSize);\r\n+//     };\r\n+//   }, []);\r\n+\r\n+//   useEffect(() => {\r\n+//     if (renderer && scene && camera) {\r\n+//       updateSize();\r\n+//       render();\r\n+//     }\r\n+//   }, [renderer, scene, camera]);\r\n+\r\n+//   const initScene = () => {\r\n+//     const renderer = new THREE.WebGLRenderer({\r\n+//       canvas: canvas3DRef.current,\r\n+//       alpha: true,\r\n+//     });\r\n+//     renderer.setPixelRatio(window.devicePixelRatio);\r\n+//     setRenderer(renderer);\r\n+\r\n+//     const camera = new THREE.OrthographicCamera(\r\n+//       -1.1,\r\n+//       1.1,\r\n+//       1.1,\r\n+//       -1.1,\r\n+//       0,\r\n+//       3\r\n+//     );\r\n+//     camera.position.z = 1.1;\r\n+//     setCamera(camera);\r\n+\r\n+//     createOrbitControls(camera, renderer.domElement);\r\n+\r\n+//     new THREE.TextureLoader().load(\r\n+//       'https://ksenia-k.com/img/earth-map-colored.png',\r\n+//       (mapTex) => {\r\n+//         setEarthTexture(mapTex);\r\n+//         mapTex.repeat.set(1, 1);\r\n+//         createGlobe(mapTex);\r\n+//         createPointer();\r\n+//         createPopupTimelines();\r\n+//         addCanvasEvents();\r\n+//         updateSize(); // Update the size of the renderer and camera\r\n+//         render(); // Start the rendering loop\r\n+//       }\r\n+//     );\r\n+//   };\r\n+\r\n+//   const createOrbitControls = (camera, canvas) => {\r\n+//     const controls = new OrbitControls(camera, canvas);\r\n+//     controls.enablePan = false;\r\n+//     controls.enableZoom = false;\r\n+//     controls.enableDamping = true;\r\n+//     controls.minPolarAngle = 0.4 * Math.PI;\r\n+//     controls.maxPolarAngle = 0.4 * Math.PI;\r\n+//     controls.autoRotate = true;\r\n+\r\n+//     let timestamp;\r\n+//     controls.addEventListener('start', () => {\r\n+//       timestamp = Date.now();\r\n+//     });\r\n+//     controls.addEventListener('end', () => {\r\n+//       setDragged(Date.now() - timestamp > 600);\r\n+//     });\r\n+\r\n+//     setControls(controls);\r\n+//   };\r\n+\r\n+//   const createGlobe = (earthTexture) => {\r\n+//     const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n+//     const mapMaterial = new THREE.ShaderMaterial({\r\n+//       vertexShader: vertexShader,\r\n+//       fragmentShader: fragmentShader,\r\n+//       uniforms: {\r\n+//         u_map_tex: { type: 't', value: earthTexture },\r\n+//         u_dot_size: { type: 'f', value: 0 },\r\n+//         u_pointer: { type: 'v3', value: new THREE.Vector3(0, 0, 1) },\r\n+//         u_time_since_click: { value: 0 },\r\n+//       },\r\n+//       alphaTest: false,\r\n+//       transparent: true,\r\n+//     });\r\n+//     setMapMaterial(mapMaterial);\r\n+\r\n+//     const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n+//     scene.add(globe);\r\n+//     setGlobe(globe);\r\n+\r\n+//     const globeMesh = new THREE.Mesh(\r\n+//       globeGeometry,\r\n+//       new THREE.MeshBasicMaterial({\r\n+//         color: 0x222222,\r\n+//         transparent: true,\r\n+//         opacity: 0.05,\r\n+//       })\r\n+//     );\r\n+//     scene.add(globeMesh);\r\n+//     setGlobeMesh(globeMesh);\r\n+//   };\r\n+\r\n+//   const createPointer = () => {\r\n+//     const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n+//     const material = new THREE.MeshBasicMaterial({\r\n+//       color: 0x000000,\r\n+//       transparent: true,\r\n+//       opacity: 0,\r\n+//     });\r\n+//     const pointer = new THREE.Mesh(geometry, material);\r\n+//     scene.add(pointer);\r\n+//     setPointer(pointer);\r\n+//   };\r\n+\r\n+//   const addCanvasEvents = () => {\r\n+//     containerRef.current.addEventListener('mousemove', (e) => {\r\n+//       updateMousePosition(e.clientX, e.clientY);\r\n+//     });\r\n+\r\n+//     containerRef.current.addEventListener('click', (e) => {\r\n+//       if (!dragged) {\r\n+//         updateMousePosition(\r\n+//           e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n+//           e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n+//         );\r\n+\r\n+//         const res = checkIntersects();\r\n+//         if (res.length) {\r\n+//           const newPointerPos = res[0].face.normal.clone();\r\n+//           setPointerPos(newPointerPos);\r\n+//           pointer.position.set(\r\n+//             newPointerPos.x,\r\n+//             newPointerPos.y,\r\n+//             newPointerPos.z\r\n+//           );\r\n+//           mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n+//           popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n+//           showPopupAnimation(true);\r\n+//           clock.start();\r\n+//         }\r\n+//       }\r\n+//     });\r\n+//   };\r\n+\r\n+//   const updateMousePosition = (eX, eY) => {\r\n+//     const rect = containerRef.current.getBoundingClientRect();\r\n+//     mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n+//     mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n+//   };\r\n+\r\n+//   const checkIntersects = () => {\r\n+//     if (!globeMesh) return [];\r\n+//     rayCaster.setFromCamera(mouse, camera);\r\n+//     const intersects = rayCaster.intersectObject(globeMesh);\r\n+//     if (intersects.length) {\r\n+//       document.body.style.cursor = 'pointer';\r\n+//     } else {\r\n+//       document.body.style.cursor = 'auto';\r\n+//     }\r\n+//     return intersects;\r\n+//   };\r\n+\r\n+//   const render = () => {\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n+//     }\r\n+//     checkIntersects();\r\n+//     if (pointer) {\r\n+//       updateOverlayGraphic();\r\n+//     }\r\n+//     controls.update();\r\n+//     renderer.render(scene, camera);\r\n+//     requestAnimationFrame(render);\r\n+//   };\r\n+\r\n+//   const updateSize = () => {\r\n+//     if (!renderer) return;\r\n+//     const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n+//     containerRef.current.style.width = `${minSide}px`;\r\n+//     containerRef.current.style.height = `${minSide}px`;\r\n+//     renderer.setSize(minSide, minSide);\r\n+//     canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n+//     if (mapMaterial) {\r\n+//       mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n+//     }\r\n+//   };\r\n+\r\n+//   const cartesianToLatLong = (pos) => {\r\n+//     const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n+//     const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n+//     return `${formatCoordinate(lat, 'N', 'S')}, ${formatCoordinate(\r\n+//       lng,\r\n+//       'E',\r\n+//       'W'\r\n+//     )}`;\r\n+//   };\r\n+\r\n+//   const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n+//     const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n+//     return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n+//   };\r\n+\r\n+//   const createPopupTimelines = () => {\r\n+//     const popupOpenTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, {\r\n+//         duration: 0.2,\r\n+//         opacity: 1,\r\n+//       }, 0)\r\n+//       .fromTo(\r\n+//         canvas2DRef.current,\r\n+//         { opacity: 0 },\r\n+//         { duration: 0.3, opacity: 1 },\r\n+//         0.15\r\n+//       )\r\n+//       .fromTo(\r\n+//         popupRef.current,\r\n+//         { opacity: 0, scale: 0.9, transformOrigin: 'center bottom' },\r\n+//         { duration: 0.1, opacity: 1, scale: 1 },\r\n+//         0.25\r\n+//       );\r\n+//     setPopupOpenTl(popupOpenTl);\r\n+\r\n+//     const popupCloseTl = gsap.timeline({ paused: true })\r\n+//       .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n+//       .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n+//       .to(popupRef.current, {\r\n+//         duration: 0.3,\r\n+//         opacity: 0,\r\n+//         scale: 0.9,\r\n+//         transformOrigin: 'center bottom',\r\n+//       }, 0);\r\n+//     setPopupCloseTl(popupCloseTl);\r\n+//   };\r\n+\r\n+//   const showPopupAnimation = (lifted) => {\r\n+//     if (lifted) {\r\n+//       let positionLifted = pointer.position.clone();\r\n+//       positionLifted.multiplyScalar(1.3);\r\n+//       gsap.from(pointer.position, {\r\n+//         duration: 0.25,\r\n+//         x: positionLifted.x,\r\n+//         y: positionLifted.y,\r\n+//         z: positionLifted.z,\r\n+//         ease: 'power3.out',\r\n+//       });\r\n+//     }\r\n+//     popupCloseTl.pause(0);\r\n+//     popupOpenTl.play(0);\r\n+//   };\r\n+\r\n+//   const updateOverlayGraphic = () => {\r\n+//     const overlayCtx = canvas2DRef.current.getContext('2d');\r\n+//     let activePointPosition = pointer.position.clone();\r\n+//     activePointPosition.applyMatrix4(globe.matrixWorld);\r\n+//     const activePointPositionProjected = activePointPosition.clone();\r\n+//     activePointPositionProjected.project(camera);\r\n+//     const coordinates2D = [\r\n+//       (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n+//       (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n+//     ];\r\n+\r\n+//     const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n+//     activePointPosition.applyMatrix4(matrixWorldInverse);\r\n+\r\n+//     if (activePointPosition.z > -1) {\r\n+//       if (!popupVisible) {\r\n+//         setPopupVisible(true);\r\n+//         showPopupAnimation(false);\r\n+//       }\r\n+\r\n+//       let popupX = coordinates2D[0];\r\n+//       popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n+\r\n+//       let popupY = coordinates2D[1];\r\n+//       const upDown = activePointPositionProjected.y > 0.6;\r\n+//       popupY += upDown ? 20 : -20;\r\n+\r\n+//       gsap.set(popupRef.current, {\r\n+//         x: popupX,\r\n+//         y: popupY,\r\n+//         xPercent: -35,\r\n+//         yPercent: upDown ? 0 : -100,\r\n+//       });\r\n+\r\n+//       popupY += upDown ? -5 : 5;\r\n+//       const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n+//       const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n+\r\n+//       drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n+\r\n+//     } else {\r\n+//       if (popupVisible) {\r\n+//         popupOpenTl.pause(0);\r\n+//         popupCloseTl.play(0);\r\n+//       }\r\n+//       setPopupVisible(false);\r\n+//     }\r\n+//   };\r\n+\r\n+//   const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n+//     ctx.strokeStyle = '#000000';\r\n+//     ctx.lineWidth = 3;\r\n+//     ctx.lineCap = 'round';\r\n+//     ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n+//     ctx.beginPath();\r\n+//     ctx.moveTo(startX, startY);\r\n+//     ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n+//     ctx.stroke();\r\n+//   };\r\n+\r\n+//   return (\r\n+//     <div className='page'>\r\n+//       {/* <div className='title'>Click to add a pointer</div> */}\r\n+//       <div className='globe-wrapper' ref={containerRef}>\r\n+//         <canvas id='globe-3d' ref={canvas3DRef}></canvas>\r\n+//         <canvas id='globe-2d-overlay' ref={canvas2DRef}></canvas>\r\n+//         <div id='globe-popup-overlay'>\r\n+//           <div className='globe-popup' ref={popupRef}></div>\r\n+//         </div>\r\n+//       </div>\r\n+//     </div>\r\n+//   );\r\n+// };\r\n+\r\n+// export default Globe;\r\n+\r\n+import React from \"react\";\r\n+// import '../../public/'\r\n+\r\n+const Globe = () => {\r\n+  return (\r\n+    <iframe\r\n+      src={`../../public/three/index.html`}\r\n+      title=\"Three.js Globe\"\r\n+      width=\"100%\"\r\n+      height=\"100%\"\r\n+      style={{ border: \"none\", overflow: \"hidden\" }}\r\n+    ></iframe>\r\n+  );\r\n+};\r\n+\r\n+export default Globe;\r\n+\r\n+// import React, { useState, useEffect } from 'react';\r\n+\r\n+// const Globe = () => {\r\n+//   const [htmlContent, setHtmlContent] = useState('');\r\n+\r\n+//   useEffect(() => {\r\n+//     fetch('../../public/three/index.html')\r\n+//       .then((response) => response.text())\r\n+//       .then((data) => {\r\n+//         setHtmlContent(data);\r\n+//         executeScripts(data);\r\n+//       });\r\n+//   }, []);\r\n+\r\n+//   const executeScripts = (html) => {\r\n+//     const parser = new DOMParser();\r\n+//     const doc = parser.parseFromString(html, 'text/html');\r\n+//     const scripts = doc.querySelectorAll('script');\r\n+//     scripts.forEach((script) => {\r\n+//       const newScript = document.createElement('script');\r\n+//       newScript.text = script.text;\r\n+//       document.body.appendChild(newScript);\r\n+//       document.body.removeChild(newScript);\r\n+//     });\r\n+//   };\r\n+\r\n+//   return (\r\n+//     <div\r\n+//       className=\"globe-container\"\r\n+//       dangerouslySetInnerHTML={{ __html: htmlContent }}\r\n+//     ></div>\r\n+//   );\r\n+// };\r\n+\r\n+// export default Globe;\r\n+\r\n"
                }
            ],
            "date": 1708581691851,
            "name": "Commit-0",
            "content": "import React, { useEffect, useRef, useState } from \"react\";\r\nimport * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\nimport { gsap } from \"gsap\";\r\nimport \"./Globe.css\"; // Assuming you've moved the CSS to a separate file\r\n\r\nconst Globe = () => {\r\n  const containerRef = useRef(null);\r\n  const canvas3DRef = useRef(null);\r\n  const canvas2DRef = useRef(null);\r\n  const popupRef = useRef(null);\r\n\r\n  const [renderer, setRenderer] = useState(null);\r\n  const [scene, setScene] = useState(null);\r\n  const [camera, setCamera] = useState(null);\r\n  const [rayCaster, setRayCaster] = useState(null);\r\n  const [controls, setControls] = useState(null);\r\n  const [pointer, setPointer] = useState(null);\r\n  const [globe, setGlobe] = useState(null);\r\n  const [globeMesh, setGlobeMesh] = useState(null);\r\n  const [mapMaterial, setMapMaterial] = useState(null);\r\n  const [popupVisible, setPopupVisible] = useState(false);\r\n  const [pointerPos, setPointerPos] = useState(null);\r\n  const [clock, setClock] = useState(new THREE.Clock());\r\n  const [mouse, setMouse] = useState(new THREE.Vector2(-1, -1));\r\n  const [dragged, setDragged] = useState(false);\r\n  const [earthTexture, setEarthTexture] = useState(null);\r\n  const [popupOpenTl, setPopupOpenTl] = useState(null);\r\n  const [popupCloseTl, setPopupCloseTl] = useState(null);\r\n\r\n  useEffect(() => {\r\n    initScene();\r\n    window.addEventListener(\"resize\", updateSize);\r\n    return () => {\r\n      window.removeEventListener(\"resize\", updateSize);\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (renderer && scene && camera) {\r\n      updateSize();\r\n      render();\r\n    }\r\n  }, [renderer, scene, camera]);\r\n\r\n  const initScene = () => {\r\n    const renderer = new THREE.WebGLRenderer({\r\n      canvas: canvas3DRef.current,\r\n      alpha: true,\r\n    });\r\n    renderer.setPixelRatio(window.devicePixelRatio);\r\n    setRenderer(renderer);\r\n\r\n    const scene = new THREE.Scene();\r\n    setScene(scene);\r\n\r\n    const camera = new THREE.OrthographicCamera(\r\n      -1.1,\r\n      1.1,\r\n      1.1,\r\n      -1.1,\r\n      0,\r\n      3\r\n    );\r\n    camera.position.z = 1.1;\r\n    setCamera(camera);\r\n\r\n    const rayCaster = new THREE.Raycaster();\r\n    rayCaster.far = 1.15;\r\n    setRayCaster(rayCaster);\r\n\r\n    createOrbitControls(camera, renderer.domElement);\r\n\r\n    new THREE.TextureLoader().load(\r\n      \"https://ksenia-k.com/img/earth-map-colored.png\",\r\n      (mapTex) => {\r\n        setEarthTexture(mapTex);\r\n        mapTex.repeat.set(1, 1);\r\n        createGlobe(mapTex);\r\n        createPointer();\r\n        createPopupTimelines();\r\n        addCanvasEvents();\r\n      }\r\n    );\r\n  };\r\n\r\n  const createOrbitControls = (camera, canvas) => {\r\n    const controls = new OrbitControls(camera, canvas);\r\n    controls.enablePan = false;\r\n    controls.enableZoom = false;\r\n    controls.enableDamping = true;\r\n    controls.minPolarAngle = 0.4 * Math.PI;\r\n    controls.maxPolarAngle = 0.4 * Math.PI;\r\n    controls.autoRotate = true;\r\n\r\n    let timestamp;\r\n    controls.addEventListener(\"start\", () => {\r\n      timestamp = Date.now();\r\n    });\r\n    controls.addEventListener(\"end\", () => {\r\n      setDragged(Date.now() - timestamp > 600);\r\n    });\r\n\r\n    setControls(controls);\r\n  };\r\n\r\n  const createGlobe = (earthTexture) => {\r\n    const globeGeometry = new THREE.IcosahedronGeometry(1, 22);\r\n    const mapMaterial = new THREE.ShaderMaterial({\r\n      vertexShader: document.getElementById(\"vertex-shader-map\").textContent,\r\n      fragmentShader: document.getElementById(\"fragment-shader-map\").textContent,\r\n      uniforms: {\r\n        u_map_tex: { type: \"t\", value: earthTexture },\r\n        u_dot_size: { type: \"f\", value: 0 },\r\n        u_pointer: { type: \"v3\", value: new THREE.Vector3(0, 0, 1) },\r\n        u_time_since_click: { value: 0 },\r\n      },\r\n      alphaTest: false,\r\n      transparent: true,\r\n    });\r\n    setMapMaterial(mapMaterial);\r\n\r\n    const globe = new THREE.Points(globeGeometry, mapMaterial);\r\n    scene.add(globe);\r\n    setGlobe(globe);\r\n\r\n    const globeMesh = new THREE.Mesh(\r\n      globeGeometry,\r\n      new THREE.MeshBasicMaterial({\r\n        color: 0x222222,\r\n        transparent: true,\r\n        opacity: 0.05,\r\n      })\r\n    );\r\n    scene.add(globeMesh);\r\n    setGlobeMesh(globeMesh);\r\n  };\r\n\r\n  const createPointer = () => {\r\n    const geometry = new THREE.SphereGeometry(0.04, 16, 16);\r\n    const material = new THREE.MeshBasicMaterial({\r\n      color: 0x000000,\r\n      transparent: true,\r\n      opacity: 0,\r\n    });\r\n    const pointer = new THREE.Mesh(geometry, material);\r\n    scene.add(pointer);\r\n    setPointer(pointer);\r\n  };\r\n\r\n  const addCanvasEvents = () => {\r\n    containerRef.current.addEventListener(\"mousemove\", (e) => {\r\n      updateMousePosition(e.clientX, e.clientY);\r\n    });\r\n\r\n    containerRef.current.addEventListener(\"click\", (e) => {\r\n      if (!dragged) {\r\n        updateMousePosition(\r\n          e.targetTouches ? e.targetTouches[0].pageX : e.clientX,\r\n          e.targetTouches ? e.targetTouches[0].pageY : e.clientY\r\n        );\r\n\r\n        const res = checkIntersects();\r\n        if (res.length) {\r\n          const newPointerPos = res[0].face.normal.clone();\r\n          setPointerPos(newPointerPos);\r\n          pointer.position.set(\r\n            newPointerPos.x,\r\n            newPointerPos.y,\r\n            newPointerPos.z\r\n          );\r\n          mapMaterial.uniforms.u_pointer.value = newPointerPos;\r\n          popupRef.current.innerHTML = cartesianToLatLong(newPointerPos);\r\n          showPopupAnimation(true);\r\n          clock.start();\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  const updateMousePosition = (eX, eY) => {\r\n    const rect = containerRef.current.getBoundingClientRect();\r\n    mouse.x = ((eX - rect.left) / rect.width) * 2 - 1;\r\n    mouse.y = -(((eY - rect.top) / rect.height) * 2 - 1);\r\n  };\r\n\r\n  const checkIntersects = () => {\r\n    rayCaster.setFromCamera(mouse, camera);\r\n    const intersects = rayCaster.intersectObject(globeMesh);\r\n    if (intersects.length) {\r\n      document.body.style.cursor = \"pointer\";\r\n    } else {\r\n      document.body.style.cursor = \"auto\";\r\n    }\r\n    return intersects;\r\n  };\r\n\r\n  const render = () => {\r\n    if (mapMaterial) {\r\n      mapMaterial.uniforms.u_time_since_click.value = clock.getElapsedTime();\r\n    }\r\n    checkIntersects();\r\n    if (pointer) {\r\n      updateOverlayGraphic();\r\n    }\r\n    controls.update();\r\n    renderer.render(scene, camera);\r\n    requestAnimationFrame(render);\r\n  };\r\n\r\n  const updateSize = () => {\r\n    const minSide = 0.65 * Math.min(window.innerWidth, window.innerHeight);\r\n    containerRef.current.style.width = `${minSide}px`;\r\n    containerRef.current.style.height = `${minSide}px`;\r\n    renderer.setSize(minSide, minSide);\r\n    canvas2DRef.current.width = canvas2DRef.current.height = minSide;\r\n    if (mapMaterial) {\r\n      mapMaterial.uniforms.u_dot_size.value = 0.04 * minSide;\r\n    }\r\n  };\r\n\r\n  const cartesianToLatLong = (pos) => {\r\n    const lat = 90 - (Math.acos(pos.y) * 180) / Math.PI;\r\n    const lng = ((270 + (Math.atan2(pos.x, pos.z) * 180) / Math.PI) % 360) - 180;\r\n    return `${formatCoordinate(lat, \"N\", \"S\")}, ${formatCoordinate(\r\n      lng,\r\n      \"E\",\r\n      \"W\"\r\n    )}`;\r\n  };\r\n\r\n  const formatCoordinate = (coordinate, positiveDirection, negativeDirection) => {\r\n    const direction = coordinate >= 0 ? positiveDirection : negativeDirection;\r\n    return `${Math.abs(coordinate).toFixed(4)}° ${direction}`;\r\n  };\r\n\r\n  const createPopupTimelines = () => {\r\n    const popupOpenTl = gsap.timeline({ paused: true })\r\n      .to(pointer.material, {\r\n        duration: 0.2,\r\n        opacity: 1,\r\n      }, 0)\r\n      .fromTo(\r\n        canvas2DRef.current,\r\n        { opacity: 0 },\r\n        { duration: 0.3, opacity: 1 },\r\n        0.15\r\n      )\r\n      .fromTo(\r\n        popupRef.current,\r\n        { opacity: 0, scale: 0.9, transformOrigin: \"center bottom\" },\r\n        { duration: 0.1, opacity: 1, scale: 1 },\r\n        0.25\r\n      );\r\n    setPopupOpenTl(popupOpenTl);\r\n\r\n    const popupCloseTl = gsap.timeline({ paused: true })\r\n      .to(pointer.material, { duration: 0.3, opacity: 0.2 }, 0)\r\n      .to(canvas2DRef.current, { duration: 0.3, opacity: 0 }, 0)\r\n      .to(popupRef.current, {\r\n        duration: 0.3,\r\n        opacity: 0,\r\n        scale: 0.9,\r\n        transformOrigin: \"center bottom\",\r\n      }, 0);\r\n    setPopupCloseTl(popupCloseTl);\r\n  };\r\n\r\n  const showPopupAnimation = (lifted) => {\r\n    if (lifted) {\r\n      let positionLifted = pointer.position.clone();\r\n      positionLifted.multiplyScalar(1.3);\r\n      gsap.from(pointer.position, {\r\n        duration: 0.25,\r\n        x: positionLifted.x,\r\n        y: positionLifted.y,\r\n        z: positionLifted.z,\r\n        ease: \"power3.out\",\r\n      });\r\n    }\r\n    popupCloseTl.pause(0);\r\n    popupOpenTl.play(0);\r\n  };\r\n\r\n  const updateOverlayGraphic = () => {\r\n    const overlayCtx = canvas2DRef.current.getContext(\"2d\");\r\n    let activePointPosition = pointer.position.clone();\r\n    activePointPosition.applyMatrix4(globe.matrixWorld);\r\n    const activePointPositionProjected = activePointPosition.clone();\r\n    activePointPositionProjected.project(camera);\r\n    const coordinates2D = [\r\n      (activePointPositionProjected.x + 1) * containerRef.current.offsetWidth * 0.5,\r\n      (1 - activePointPositionProjected.y) * containerRef.current.offsetHeight * 0.5,\r\n    ];\r\n\r\n    const matrixWorldInverse = controls.object.matrixWorldInverse;\r\n    activePointPosition.applyMatrix4(matrixWorldInverse);\r\n\r\n    if (activePointPosition.z > -1) {\r\n      if (!popupVisible) {\r\n        setPopupVisible(true);\r\n        showPopupAnimation(false);\r\n      }\r\n\r\n      let popupX = coordinates2D[0];\r\n      popupX -= activePointPositionProjected.x * containerRef.current.offsetWidth * 0.3;\r\n\r\n      let popupY = coordinates2D[1];\r\n      const upDown = activePointPositionProjected.y > 0.6;\r\n      popupY += upDown ? 20 : -20;\r\n\r\n      gsap.set(popupRef.current, {\r\n        x: popupX,\r\n        y: popupY,\r\n        xPercent: -35,\r\n        yPercent: upDown ? 0 : -100,\r\n      });\r\n\r\n      popupY += upDown ? -5 : 5;\r\n      const curveMidX = popupX + activePointPositionProjected.x * 100;\r\n      const curveMidY = popupY + (upDown ? -0.5 : 0.1) * coordinates2D[1];\r\n\r\n      drawPopupConnector(overlayCtx, coordinates2D[0], coordinates2D[1], curveMidX, curveMidY, popupX, popupY);\r\n\r\n    } else {\r\n      if (popupVisible) {\r\n        popupOpenTl.pause(0);\r\n        popupCloseTl.play(0);\r\n      }\r\n      setPopupVisible(false);\r\n    }\r\n  };\r\n\r\n  const drawPopupConnector = (ctx, startX, startY, midX, midY, endX, endY) => {\r\n    ctx.strokeStyle = \"#000000\";\r\n    ctx.lineWidth = 3;\r\n    ctx.lineCap = \"round\";\r\n    ctx.clearRect(0, 0, containerRef.current.offsetWidth, containerRef.current.offsetHeight);\r\n    ctx.beginPath();\r\n    ctx.moveTo(startX, startY);\r\n    ctx.quadraticCurveTo(midX, midY, endX, endY);\r\n    ctx.stroke();\r\n  };\r\n\r\n  return (\r\n    <div className=\"page\">\r\n      <div className=\"title\">Click to add a pointer</div>\r\n      <div className=\"globe-wrapper\" ref={containerRef}>\r\n        <canvas id=\"globe-3d\" ref={canvas3DRef}></canvas>\r\n        <canvas id=\"globe-2d-overlay\" ref={canvas2DRef}></canvas>\r\n        <div id=\"globe-popup-overlay\">\r\n          <div className=\"globe-popup\" ref={popupRef}></div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Globe;\r\n"
        }
    ]
}